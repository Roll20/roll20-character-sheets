<!-- Character Sheet -->
<div>
<input name="attr_static_sheet_state_type" class="charactersheet-type" type="hidden" value="player" />
<!--// PLAYER SHEET //-->
    <div class="charactersheet-player">
        <div>
            <!-- Screen Title -->
            <input name="attr_static_screen_accordion_state" class="accordion-screen" type="checkbox" value="1" />
            <div class="grid-container-title-bar theme-border">
                <div class="grid-minor-title-buttons-left">
                    <!--
                    <button name="act_static_screen_rolls_button" class="styling-section-button wide-button button-click-animation theme-button" type="action">
                        <span class="d6font">C D</span>
                    </button>
                    -->
                </div>
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="character-screen">Character Screen</span>
                </div>
                <!-- Title Buttons -->
                <div class="grid-minor-title-buttons-right">
                    <button name="act_static_screen_help_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">help</span>
                    </button>
                    <button name="act_static_screen_accordion_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                </div>
            </div>
            <div class="styling-border theme-border">
                <div class="styling-background theme-background">
                    <div class="grid-major-screen-top">
                        <!-- Screen Top-Left -->
                        <div class="grid-minor-screen-name styling-pill theme-major">
                            <span data-i18n="name">Name</span>
                        </div>
                        <input name="attr_static_character_details_name" class="grid-minor-input-name styling-pill-input theme-input-major" type="text" value="" readonly />
                        
                        <button name="act_static_character_details_race" class="grid-minor-screen-race styling-pill button-click-animation input-button theme-major" type="action">
                        <!--<div class="styling-pill button-click-animation theme-major">-->
                            <span data-i18n="race">Race</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_details_race" class="grid-minor-input-race styling-pill-input theme-input-major" type="text" value="" readonly />
                        
                        <button name="act_static_character_details_class" class="grid-minor-screen-class styling-pill button-click-animation input-button theme-major" type="action">
                        <!--<div class="grid-minor-screen-class styling-pill theme-major">-->
                            <span data-i18n="class">Class</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_details_class" class="grid-minor-input-class styling-pill-input theme-input-major" type="text" value="" readonly />
                        <!-- Screen Top-Center -->
                        <div class="grid-minor-screen-logo"></div>
                        <!-- Screen Top-Right -->
                        <button name="act_static_character_details_height" class="grid-minor-screen-height styling-pill button-click-animation input-button theme-major" type="action">
                        <!--<div class="grid-minor-screen-height styling-pill theme-major">-->
                            <span data-i18n="height">Height</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_details_height" class="grid-minor-input-height styling-pill-input theme-input-major" type="text" value="" readonly />
                        
                        <button name="act_static_character_details_weight" class="grid-minor-screen-weight styling-pill button-click-animation input-button theme-major" type="action">
                        <!--<div class="grid-minor-screen-weight styling-pill theme-major">-->
                            <span data-i18n="weight">Weight</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_details_weight" class="grid-minor-input-weight styling-pill-input theme-input-major" type="text" value="" readonly />
                        
                        <div class="grid-minor-screen-totalcp styling-pill theme-major">
                            <span data-i18n="points">Points</span>
                        </div>
                        <input name="attr_static_character_points_total" class="grid-minor-input-totalcp styling-pill-input theme-input-major" type="text" value=0 readonly />
                        <!-- Screen Middle 1st Tier -->
                        <div class="grid-minor-screen-dm styling-big-pill theme-major">
                            <span data-i18n="damage-multiplier-u">DM</span>
                            <input name="attr_static_character_dm_base" class="grid-minor-input-dm styling-big-pill-input theme-input-major" type="text" value=5 readonly />
                        </div>
                        <div class="grid-minor-screen-acv styling-big-pill theme-major">
                            <span data-i18n="attack-combat-value-u">ACV</span>
                            <input name="attr_static_character_acv_base" class="grid-minor-input-acv styling-big-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <div class="grid-minor-screen-dcv styling-big-pill theme-major">
                            <span data-i18n="defense-combat-value-u">DCV</span>
                            <input name="attr_static_character_dcv_base" class="grid-minor-input-dcv styling-big-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <div class="grid-minor-screen-scv styling-big-pill theme-major">
                            <span data-i18n="social-combat-value-u">SCV</span>
                            <input name="attr_static_character_scv_base" class="grid-minor-input-scv styling-big-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <!-- Screen Middle 2nd Tier -->
                        <div class="grid-minor-screen-initiative styling-big-pill theme-major">
                            <span data-i18n="initiative">Initiative</span>
                            <input name="attr_static_character_initiative_base" class="grid-minor-input-initiative styling-big-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <div class="grid-minor-screen-actions styling-big-pill theme-major">
                            <span data-i18n="actions">Actions</span>
                            <input name="attr_static_character_actions_base" class="grid-minor-input-actions styling-big-pill-input theme-input-major" type="text" value=1 readonly />
                        </div>
                        <div class="grid-minor-screen-defenses styling-big-pill theme-major">
                            <span data-i18n="defenses">Defenses</span>
                            <input name="attr_static_character_defenses_base" class="grid-minor-input-defenses styling-big-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <div class="grid-minor-screen-shockvalue styling-big-pill theme-major">
                            <span data-i18n="shock-value">Shock Value</span>
                            <input name="attr_static_character_shockvalue_base" class="grid-minor-input-shockvalue styling-big-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                    </div>
                    <input name="attr_static_screen_accordion_state" class="accordion-screen" type="checkbox" value="1" />
                    <div class="grid-major-screen-bottom accordion-screen">
                        <!-- Sheet Details -->
                        <div class="grid-minor-details-header styling-pill-title theme-major">
                            <span data-i18n="details">Details</span>
                        </div>
                        <div class="grid-minor-screen-debug styling-pill theme-minor">
                            <span data-i18n="debug-level">Debug Level</span>
                        </div>
                        <input name="attr_static_sheet_settings_debug" class="grid-minor-input-debug styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_sheet_settings_player" class="grid-minor-screen-player styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-screen-player styling-pill theme-minor">-->
                            <span data-i18n="player-name">Player Name</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_sheet_settings_player" class="grid-minor-input-player styling-pill-input theme-input" type="text" value="" readonly />
                        
                        <button name="act_static_character_details_pronoun" class="grid-minor-screen-pronoun styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-screen-pronoun styling-pill theme-minor">-->
                            <span data-i18n="pronoun">Pronoun</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_details_pronoun" class="grid-minor-input-pronoun styling-pill-input theme-input" type="text" value="" readonly />
                        
                        <button name="act_static_sheet_settings_type" class="grid-minor-screen-type styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-screen-type styling-pill theme-minor">-->
                            <span data-i18n="sheet-type">Sheet Type</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_sheet_settings_type" class="grid-minor-input-type styling-pill-input theme-input" type="text" value="Player" readonly />
                        
                        <div class="grid-minor-screen-version styling-pill theme-minor">
                            <span data-i18n="sheet-version">Sheet Version</span>
                        </div>
                        <input name="attr_static_sheet_settings_version" class="grid-minor-input-version styling-pill-input theme-input" type="text" value="0.1" readonly />
                        
                        <button name="act_static_character_details_size" class="grid-minor-screen-size styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-screen-size styling-pill theme-minor">-->
                            <span data-i18n="size">Size</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_details_size" class="grid-minor-input-size styling-pill-input theme-input" type="text" value="Medium" readonly />
                        
                        <button name="act_static_sheet_settings_theme" class="grid-minor-screen-theme styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-screen-theme styling-pill theme-minor">-->
                            <span data-i18n="theme">Theme</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_sheet_settings_theme" class="grid-minor-input-theme styling-pill-input theme-input" type="text" value="Tri Stat Core" readonly />
                        
                        <div class="grid-minor-game-settings-header styling-pill-title theme-major">
                            <span data-i18n="game-settings">Game Settings</span>
                        </div>

                        <button name="act_static_sheet_settings_gm" class="grid-minor-screen-gmname styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-screen-gmname styling-pill theme-minor">-->
                            <span data-i18n="game-master-name">GM Name</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_sheet_settings_gm" class="grid-minor-input-gmname styling-pill-input theme-input" type="text" value="" readonly />
                        
                        <div class="grid-minor-screen-rules styling-big-pill theme-minor">
                            <span data-i18n="rules-enabled">Rules Enabled</span>
                            <textarea name="attr_static_sheet_settings_rules" class="styling-big-pill-textarea theme-input" wrap="soft" placeholder="Core Rulebook (default)" readonly></textarea>
                        </div>
                        <div class="grid-minor-character-points-header styling-pill-title theme-major">
                            <span data-i18n="character-points">Character Points</span>
                        </div>
                        
                        <button name="act_static_character_points_base" class="grid-minor-screen-basecp styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-screen-basecp styling-pill theme-minor">-->
                            <span data-i18n="base">Base</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_points_base" class="grid-minor-input-basecp styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_points_gained" class="grid-minor-screen-gainedcp styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-screen-gainedcp styling-pill theme-minor">-->
                            <span data-i18n="gained">Gained</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_points_gained" class="grid-minor-input-gainedcp styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <div class="grid-minor-screen-spentcp styling-pill theme-minor">
                            <span data-i18n="spent">Spent</span>
                        </div>
                        <input name="attr_static_character_points_spent" class="grid-minor-input-spentcp styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_points_temp" class="grid-minor-screen-temporarycp styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-screen-temporarycp styling-pill theme-minor">-->
                            <span data-i18n="temporary">Temporary</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_points_temp" class="grid-minor-input-temporarycp styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <div class="grid-minor-screen-remainingcp styling-pill theme-minor">
                            <span data-i18n="remaining">Remaining</span>
                        </div>
                        <input name="attr_static_character_points_remaining" class="grid-minor-input-remainingcp styling-pill-input theme-input" type="text" value=0 readonly />
                    </div>
                </div>
            </div>
        </div>
        <div class="section-break"></div>

        <div>
            <!-- Roll Title -->
            <input name="attr_static_roll_accordions_state" class="accordion-roll" type="checkbox" value="1" />
            <div class="grid-container-collapsible-title-bar theme-border">
                <!-- Title Buttons Left -->
                <div class="grid-minor-title-buttons-left">
                    <button name="act_static_roll_2d6_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">casino</span>
                    </button>
                    <button name="act_static_roll_attack_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-symbols-outlined">swords</span>
                    </button>
                    <button name="act_static_roll_attribute_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-symbols-outlined">cognition</span>
                    </button>
                    <button name="act_static_roll_initiative_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-symbols-outlined">acute</span>
                    </button>
                    <button name="act_static_roll_skill_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-symbols-outlined">multimodal_hand_eye</span>
                    </button>
                    <button name="act_static_roll_stat_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-symbols-outlined">person</span>
                    </button>
                </div>
                <!-- Title -->
                <div class="grid-minor-rollmacro-title theme-title">
                    <span data-i18n="rolls">Rolls</span>
                </div>
                <!-- Title Buttons Right -->
                <div class="grid-minor-title-buttons-right">
                    <button name="act_static_roll_add_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">add</span>
                    </button>
                    <button name="act_static_roll_delete_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">remove</span>
                    </button>
                    <button name="act_static_roll_accordions_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                </div>
            </div>
            <div class="styling-border theme-border accordion-roll">
                <div class="container-roll styling-background theme-background">
                    <fieldset class="repeating_roll">
                        <div class="repeating-break">
                        <input name="attr_state" class="accordion-roll" type="checkbox" value="1" />
                        <div class="grid-container-collapsible-title-bar theme-border">
                            <div class="grid-minor-title-buttons-left">
                                <input name="attr_button" class="block-switch" type="checkbox" value="1" />
                                <div class="block-a">
                                    <button name="act_rollmacro" class="styling-section-button button-click-animation theme-button" type="action">
                                        <span class="material-icons">casino</span>
                                    </button>
                                </div>
                                <div class="block-b">
                                    <button name="act_rollmacro" class="styling-section-button button-click-animation theme-button" type="action">
                                        <span name="attr_icon" class="material-symbols">casino</span>
                                        <input name="attr_icon" type="hidden" value="casino" />
                                    </button>
                                </div>
                            </div>
                            <div class="grid-minor-section-title theme-title">
                                <span name="attr_name"></span>
                                <input name="attr_name" type="hidden" value="Roll Macro" />
                            </div>
                            <div class="grid-minor-title-buttons-right">
                                <button name="act_accordion" class="styling-section-button button-click-animation theme-button" type="action">
                                    <span class="material-icons expand">expand_less</span>
                                </button>
                            </div>
                        </div>
                        <div class="styling-border theme-border accordion-roll">
                            <div class="styling-background theme-background">
                                <div class="grid-major-macro-roll grid-force-cell-size">
                                    <input name="attr_type" type="hidden" value="" readonly />
                                    
                                    <button name="act_name" class="grid-minor-rollname styling-pill button-click-animation input-button theme-minor" type="action">
                                        <span data-i18n="name">Name</span>
                                    </button>
                                    <input name="attr_name" class="grid-minor-input-rollname force-column-width styling-pill-input theme-input" type="text" value="" readonly />

                                    <button name="act_type" class="grid-minor-rolltype styling-pill button-click-animation input-button theme-minor" type="action">
                                        <span data-i18n="type">Type</span>
                                    </button>
                                    <input name="attr_type" class="grid-minor-input-rolltype force-column-width styling-pill-input theme-input" type="text" value="" readonly />

                                    <button name="act_modifier" class="grid-minor-modifier styling-pill button-click-animation input-button theme-minor" type="action">
                                        <span data-i18n="modifier">Modifier</span>
                                    </button>
                                    <input name="attr_modifier" class="grid-minor-input-modifier styling-pill-input theme-input" type="text" value="" readonly />

                                    <button name="act_attribute" class="grid-minor-rollattribute styling-pill button-click-animation input-button theme-minor" type="action">
                                        <span name="attr_attrlabel" data-i18n="attribute">Attribute</span>
                                        <input name="attr_attrlabel" type="hidden" value="" readonly />
                                    </button>
                                    <input name="attr_attribute" class="grid-minor-input-rollattribute styling-pill-input theme-input" type="text" value="" readonly />

                                    <button name="act_stat" class="grid-minor-rollstat styling-pill button-click-animation input-button theme-minor" type="action">
                                        <span data-i18n="stat">Stat</span>
                                    </button>
                                    <input name="attr_stat" class="grid-minor-input-rollstat styling-pill-input theme-input" type="text" value="" readonly />

                                    <button name="act_target" class="grid-minor-target styling-pill button-click-animation input-button theme-minor" type="action">
                                        <span data-i18n="target">Target</span>
                                    </button>
                                    <input name="attr_target" class="grid-minor-input-target styling-pill-input theme-input" type="text" value="" readonly />

                                    <button name="act_maneuver" class="grid-minor-maneuver styling-pill button-click-animation input-button theme-minor" type="action">
                                        <span name="attr_maneuverlabel" data-i18n="maneuver">Maneuver</span>
                                        <input name="attr_maneuverlabel" type="hidden" value="" readonly />
                                    </button>
                                    <input name="attr_maneuver" class="grid-minor-input-maneuver styling-pill-input theme-input" type="text" value="" readonly />
                                    
                                    <button name="act_enemy" class="grid-minor-enemy styling-pill button-click-animation input-button theme-minor" type="action">
                                        <span data-i18n="enemy">Enemy</span>
                                    </button>
                                    <input name="attr_enemy" class="grid-minor-input-enemy styling-pill-input theme-input" type="text" value="" readonly />
                                </div>
                            </div>
                        </div>
                        </div>
                    </fieldset>
                </div>
            </div>
        </div>
        <div class="section-break"></div>
        <div>
            <!-- Status Title -->
            <input name="attr_static_status_accordion_state" class="accordion-status" type="checkbox" value="1" />
            <div class="grid-container-title-bar theme-border">
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="status">Status</span>
                </div>
                <!-- Title Buttons -->
                <div class="grid-minor-title-buttons-right">
                    <button name="act_static_status_update_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">update</span>
                    </button>
                    <button name="act_static_status_add_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">add</span>
                    </button>
                    <button name="act_static_status_delete_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">remove</span>
                    </button>
                    <button name="act_static_status_accordion_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                </div>
            </div>
            <div class="styling-border theme-border">
                <div class="container-status styling-background theme-background">
                    <fieldset class="repeating_condition">
                        <div class="grid-major-status-conditions">
                            <input name="attr_name" type="hidden" value="" />
                            <!--<button name="act_delete" class="grid-minor-status-condition styling-pill button-click-animation input-button theme-major" type="action">-->
                            <div class="grid-minor-status-condition styling-pill theme-major">
                                <span name="attr_name"></span>
                            </div>
                            <!--</button>-->
                            <input name="attr_description" class="grid-minor-input-condition styling-pill-input theme-input-major" type="text" value="" readonly />
                        </div>
                    </fieldset>
                    <div class="grid-major-status-top">
                        <div class="grid-minor-status-energy styling-big-pill theme-major">
                            <span data-i18n="energy-points">Energy Points</span>
                            <input name="attr_static_sheet_energy_state" class="status-bar-energy" type="hidden" value=0 readonly />
                            <input name="attr_static_character_energy_status" class="grid-minor-input-energystatus styling-big-pill-input status-bar theme-input-major" type="text" value="Rested" readonly />
                        </div>
                        <div class="grid-minor-status-health styling-big-pill theme-major">
                            <span data-i18n="health-points">Health Points</span>
                            <input name="attr_static_sheet_health_state" class="status-bar-health" type="hidden" value=0 readonly />
                            <input name="attr_static_character_health_status" class="grid-minor-input-healthstatus styling-big-pill-input status-bar theme-input-major" type="text" value="Healthy" readonly />
                        </div>
                        <div class="grid-minor-status-sanity styling-big-pill theme-major">
                            <span data-i18n="sanity-points">Sanity Points</span>
                            <input name="attr_static_sheet_sanity_state" class="status-bar-sanity" type="hidden" value=0 readonly />
                            <input name="attr_static_character_sanity_status" class="grid-minor-input-sanitystatus styling-big-pill-input status-bar theme-input-major" type="text" value="Well" readonly />
                        </div>
                        <div class="grid-minor-status-society styling-big-pill theme-major">
                            <span data-i18n="society-points">Society Points</span>
                            <input name="attr_static_sheet_society_state" class="status-bar-society" type="hidden" value=0 readonly />
                            <input name="attr_static_character_society_status" class="grid-minor-input-societystatus styling-big-pill-input status-bar theme-input-major" type="text" value="Confident" readonly />
                        </div>
                    </div>
                    <input name="attr_static_status_accordion_state" class="accordion-status" type="checkbox" value="1" />
                    <div class="grid-major-status-bottom accordion-status">
                        <div class="grid-minor-remaining-energy styling-pill theme-minor">
                            <span data-i18n="remaining">Remaining</span>
                        </div>
                        <input name="attr_static_character_energy_remaining" class="grid-minor-input-remainingenergy styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-base-energy styling-pill theme-minor">
                            <span data-i18n="base">Base</span>
                        </div>
                        <input name="attr_static_character_energy_base" class="grid-minor-input-baseenergy styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_energy_temp" class="grid-minor-temp-energy styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-temp-energy styling-pill theme-minor">-->
                            <span data-i18n="temp">Temp</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_energy_temp" class="grid-minor-input-tempenergy styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_energy_damage" class="grid-minor-damage-energy styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-damage-energy styling-pill theme-minor">-->
                            <span data-i18n="damage">Damage</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_energy_damage" class="grid-minor-input-damageenergy styling-pill-input theme-input" type="text" value=0 readonly />

                        <div class="grid-minor-remaining-health styling-pill theme-minor">
                            <span data-i18n="remaining">Remaining</span>
                        </div>
                        <input name="attr_static_character_health_remaining" class="grid-minor-input-remaininghealth styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-base-health styling-pill theme-minor">
                            <span data-i18n="base">Base</span>
                        </div>
                        <input name="attr_static_character_health_base" class="grid-minor-input-basehealth styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_health_temp" class="grid-minor-temp-health styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-temp-health styling-pill theme-minor">-->
                            <span data-i18n="temp">Temp</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_health_temp" class="grid-minor-input-temphealth styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_health_damage" class="grid-minor-damage-health styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-damage-health styling-pill theme-minor">-->
                            <span data-i18n="damage">Damage</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_health_damage" class="grid-minor-input-damagehealth styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_health_stun" class="grid-minor-stun-health styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-stun-health styling-pill theme-minor">-->
                            <span data-i18n="stun">Stun</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_health_stun" class="grid-minor-input-stunhealth styling-pill-input theme-input" type="text" value=0 readonly />

                        <div class="grid-minor-remaining-sanity styling-pill theme-minor">
                            <span data-i18n="remaining">Remaining</span>
                        </div>
                        <input name="attr_static_character_sanity_remaining" class="grid-minor-input-remainingsanity styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-base-sanity styling-pill theme-minor">
                            <span data-i18n="base">Base</span>
                        </div>
                        <input name="attr_static_character_sanity_base" class="grid-minor-input-basesanity styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_sanity_temp" class="grid-minor-temp-sanity styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-temp-sanity styling-pill theme-minor">-->
                            <span data-i18n="temp">Temp</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_sanity_temp" class="grid-minor-input-tempsanity styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_sanity_damage" class="grid-minor-damage-sanity styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-damage-sanity styling-pill theme-minor">-->
                            <span data-i18n="damage">Damage</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_sanity_damage" class="grid-minor-input-damagesanity styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <div class="grid-minor-remaining-society styling-pill theme-minor">
                            <span data-i18n="remaining">Remaining</span>
                        </div>
                        <input name="attr_static_character_society_remaining" class="grid-minor-input-remainingsociety styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-base-society styling-pill theme-minor">
                            <span data-i18n="base">Base</span>
                        </div>
                        <input name="attr_static_character_society_base" class="grid-minor-input-basesociety styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_society_temp" class="grid-minor-temp-society styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-temp-society styling-pill theme-minor">-->
                            <span data-i18n="temp">Temp</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_society_temp" class="grid-minor-input-tempsociety styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_society_damage" class="grid-minor-damage-society styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-damage-society styling-pill theme-minor">-->
                            <span data-i18n="damage">Damage</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_society_damage" class="grid-minor-input-damagesociety styling-pill-input theme-input" type="text" value=0 readonly />
                    </div>
                </div>
            </div>
        </div>
        <div class="section-break"></div>
        <div>
            <!-- Stats Title -->
            <input name="attr_static_stats_accordion_state" class="accordion-stats" type="checkbox" value="1" />
            <div class="grid-container-title-bar theme-border">
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="stats">Stats</span>
                </div>
                <!-- Title Buttons -->
                <div class="grid-minor-title-buttons-right">
                    <!--
                    <button name="act_static_stats_edit_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">edit</span>
                    </button>
                    -->
                    <button name="act_static_stats_accordion_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                </div>
            </div>
            <div class="styling-border theme-border">
                <div class="styling-background theme-background">
                    <div class="grid-major-stats-top">
                        <div class="grid-minor-stats-body styling-big-pill theme-major">
                            <span data-i18n="body">Body</span>
                            <input name="attr_static_character_body_remaining" class="grid-minor-input-body styling-long-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <div class="grid-minor-stats-mind styling-big-pill theme-major">
                            <span data-i18n="mind">Mind</span>
                            <input name="attr_static_character_mind_remaining" class="grid-minor-input-mind styling-long-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <div class="grid-minor-stats-soul styling-big-pill theme-major">
                            <span data-i18n="soul">Soul</span>
                            <input name="attr_static_character_soul_remaining" class="grid-minor-input-soul styling-long-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                    </div>
                    <input name="attr_static_stats_accordion_state" class="accordion-stats" type="checkbox" value="1" />
                    <div class="grid-major-stats-bottom accordion-stats">
                        
                        <button name="act_static_character_body_base" class="grid-minor-base-body styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-base-body styling-pill theme-minor">-->
                            <span data-i18n="base">Base</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_body_base" class="grid-minor-input-basebody styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_body_temp" class="grid-minor-temp-body styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-temp-body styling-pill theme-minor">-->
                            <span data-i18n="temp">Temp</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_body_temp" class="grid-minor-input-tempbody styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_body_damage" class="grid-minor-damage-body styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-damage-body styling-pill theme-minor">-->
                            <span data-i18n="damage">Damage</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_body_damage" class="grid-minor-input-damagebody styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_mind_base" class="grid-minor-base-mind styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-base-mind styling-pill theme-minor">-->
                            <span data-i18n="base">Base</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_mind_base" class="grid-minor-input-basemind styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_mind_temp" class="grid-minor-temp-mind styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-temp-mind styling-pill theme-minor">-->
                            <span data-i18n="temp">Temp</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_mind_temp" class="grid-minor-input-tempmind styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_mind_damage" class="grid-minor-damage-mind styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-damage-mind styling-pill theme-minor">-->
                            <span data-i18n="damage">Damage</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_mind_damage" class="grid-minor-input-damagemind styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_soul_base" class="grid-minor-base-soul styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-base-soul styling-pill theme-minor">-->
                            <span data-i18n="base">Base</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_soul_base" class="grid-minor-input-basesoul styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_soul_temp" class="grid-minor-temp-soul styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-temp-soul styling-pill theme-minor">-->
                            <span data-i18n="temp">Temp</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_soul_temp" class="grid-minor-input-tempsoul styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <button name="act_static_character_soul_damage" class="grid-minor-damage-soul styling-pill button-click-animation input-button theme-minor" type="action">
                        <!--<div class="grid-minor-damage-soul styling-pill theme-minor">-->
                            <span data-i18n="damage">Damage</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_character_soul_damage" class="grid-minor-input-damagesoul styling-pill-input theme-input" type="text" value=0 readonly />
                    </div>
                </div>
            </div>
        </div>
        <div class="section-break"></div>
        <div>
            <!-- Capabilities Title -->
            <input name="attr_static_capabilities_accordion_state" class="accordion-capabilities" type="checkbox" value="1" />
            <div class="grid-container-collapsible-title-bar theme-border">
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="capabilities">Capabilities</span>
                </div>
                <!-- Title Buttons -->
                <div class="grid-minor-title-buttons-right">
                    <button name="act_static_capabilities_accordion_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                </div>
            </div>
            <div class="styling-border theme-border accordion-capabilities">
                <div class="styling-background force-width-83 theme-background">
                    <div class="grid-major-capabilities">
                        <div class="grid-minor-senses-header styling-pill-title theme-major">
                            <span data-i18n="senses">Senses</span>
                        </div>
                        <div class="grid-minor-senses-hearing styling-pill theme-minor">
                            <span data-i18n="hearing">Hearing</span>
                        </div>
                        <input name="attr_static_character_capabilities_hearing" class="grid-minor-input-hearing styling-pill-input theme-input" type="text" value="Normal" readonly />
                        <div class="grid-minor-senses-sight styling-pill theme-minor">
                            <span data-i18n="sight">Sight</span>
                        </div>
                        <input name="attr_static_character_capabilities_sight" class="grid-minor-input-sight styling-pill-input theme-input" type="text" value="Normal" readonly />
                        <div class="grid-minor-senses-smell styling-pill theme-minor">
                            <span data-i18n="smell">Smell</span>
                        </div>
                        <input name="attr_static_character_capabilities_smell" class="grid-minor-input-smell styling-pill-input theme-input" type="text" value="Normal" readonly />
                        <div class="grid-minor-senses-taste styling-pill theme-minor">
                            <span data-i18n="taste">Taste</span>
                        </div>
                        <input name="attr_static_character_capabilities_taste" class="grid-minor-input-taste styling-pill-input theme-input" type="text" value="Normal" readonly />
                        <div class="grid-minor-senses-touch styling-pill theme-minor">
                            <span data-i18n="touch">Touch</span>
                        </div>
                        <input name="attr_static_character_capabilities_touch" class="grid-minor-input-touch styling-pill-input theme-input" type="text" value="Normal" readonly />
                        <div class="grid-minor-senses-sixthsense styling-big-pill theme-minor">
                            <span data-i18n="sixthsense">Sixth Sense</span>
                        </div>
                        <textarea name="attr_static_character_capabilities_sixthsense" class="grid-minor-input-sixthsense styling-big-pill-textarea-capabilities theme-input" wrap="soft" placeholder="None" readonly></textarea>

                        <!--<input name="attr_static_character_capabilities_sixthsense" class="grid-minor-input-sixthsense styling-pill-input theme-input" type="text" value="None" readonly />-->
                        <div class="grid-minor-movement-header styling-pill-title theme-major">
                            <span data-i18n="movement">Movement</span>
                        </div>
                        <div class="grid-minor-movement-walk styling-pill theme-minor">
                            <span data-i18n="walk">Walk</span>
                        </div>
                        <input name="attr_static_character_capabilities_walk" class="grid-minor-input-walk styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-jog styling-pill theme-minor">
                            <span data-i18n="jog">Jog</span>
                        </div>
                        <input name="attr_static_character_capabilities_jog" class="grid-minor-input-jog styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-run styling-pill theme-minor">
                            <span data-i18n="run">Run</span>
                        </div>
                        <input name="attr_static_character_capabilities_run" class="grid-minor-input-run styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-sprint styling-pill theme-minor">
                            <span data-i18n="sprint">Sprint</span>
                        </div>
                        <input name="attr_static_character_capabilities_sprint" class="grid-minor-input-sprint styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-swim styling-pill theme-minor">
                            <span data-i18n="swim">Swim</span>
                        </div>
                        <input name="attr_static_character_capabilities_swim" class="grid-minor-input-swim styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-sprintswim styling-pill theme-minor">
                            <span data-i18n="sprint-swim">Sprint Swim</span>
                        </div>
                        <input name="attr_static_character_capabilities_sprintswim" class="grid-minor-input-sprintswim styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-jump styling-pill theme-minor">
                            <span data-i18n="jump">jump</span>
                        </div>
                        <input name="attr_static_character_capabilities_jump" class="grid-minor-input-jump styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-leap styling-pill theme-minor">
                            <span data-i18n="leap">Leap</span>
                        </div>
                        <input name="attr_static_character_capabilities_leap" class="grid-minor-input-leap styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-runningleap styling-pill theme-minor">
                            <span data-i18n="running-leap">Running Leap</span>
                        </div>
                        <input name="attr_static_character_capabilities_runningleap" class="grid-minor-input-runningleap styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-strength-header styling-pill-title theme-major">
                            <span data-i18n="strength">Strength</span>
                        </div>
                        <div class="grid-minor-strength-carry styling-pill theme-minor">
                            <span data-i18n="carry">Carry</span>
                        </div>
                        <input name="attr_static_character_capabilities_carry" class="grid-minor-input-carry styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-strength-lift styling-pill theme-minor">
                            <span data-i18n="lift">Lift</span>
                        </div>
                        <input name="attr_static_character_capabilities_lift" class="grid-minor-input-lift styling-pill-input theme-input" type="text" value="" readonly />
                    </div>
                </div>
            </div>
        </div>
        <div class="section-break"></div>
        <div>
            <!-- Attributes Title -->
            <input name="attr_static_attributes_accordions_state" class="accordion-attributes" type="checkbox" value="1" />
            <div class="grid-container-title-bar theme-border">
                <!-- Title Buttons on Left -->
                <div class="grid-minor-title-buttons-left">
                    <button name="act_static_attributes_grouptoggle_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">checklist</span>
                    </button>
                </div>
                <!-- Title -->
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="attributes-and-defects">Attributes and Defects</span>
                </div>
                <!-- Title Buttons on Right -->
                <div class="grid-minor-title-buttons-right">
                    <input name="attr_static_attributes_powervariation_state" class="block-switch" type="checkbox" value="1" />
                    <div class="block-a"></div>
                    <div class="block-b">
                        <button name="act_static_attributes_lock_button" class="styling-section-button button-click-animation theme-button" type="action">
                            <span class="material-icons" name="attr_static_attributes_lock_icon"></span>
                            <input type="hidden" name="attr_static_attributes_lock_icon" value="lock_open" />
                        </button>
                    </div>
                    <button name="act_static_attributes_groupselect_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">auto_stories</span>
                    </button>
                    <button name="act_static_attributes_add_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">add</span>
                    </button>
                    <button name="act_static_attributes_delete_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">remove</span>
                    </button>
                    <button name="act_static_attributes_accordions_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                    <input name="attr_static_attributes_accordions_state" type="hidden" value="1" />
                </div>
            </div>
            <div class="styling-border theme-border">
                <div class="container-attributes styling-background theme-background">
                    <div class="grid-major-attributes-grouphud">
                        
                        <button name="act_static_attribute_group_name" class="grid-minor-attributes-groupname styling-pill button-click-animation input-button theme-major" type="action">
                        <!--<div class="grid-minor-attributes-groupname styling-pill theme-major">-->
                            <span data-i18n="group-name">Group Name</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_attribute_group_name" class="grid-minor-input-groupname styling-long-pill-input theme-input-major" type="text" value="" readonly />
                        
                        <div class="grid-minor-attributes-grouppoints styling-pill theme-major">
                            <span data-i18n="group-points">Group Points</span>
                        </div>
                        <input name="attr_static_attribute_group_totalpoints" class="grid-minor-input-grouppoints styling-pill-input theme-input-major" type="text" value="" readonly />
                        
                        <button name="act_static_attribute_group_type" class="grid-minor-attributes-grouptype styling-pill button-click-animation input-button theme-major" type="action">
                        <!--<div class="grid-minor-attributes-grouptype styling-pill theme-major">-->
                            <span data-i18n="type">Type</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_attribute_group_type" class="grid-minor-input-grouptype styling-pill-input theme-input-major" type="text" value="" readonly />
                        
                        <button name="act_static_attribute_group_source" class="grid-minor-attributes-groupsource styling-pill button-click-animation input-button theme-major" type="action">
                        <!--<div class="grid-minor-attributes-groupsource styling-pill theme-major">-->
                            <span data-i18n="source">Source</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_attribute_group_source" class="grid-minor-input-groupsource styling-pill-input theme-input-major" type="text" value="" readonly />
                        
                        <button name="act_static_attribute_group_item" class="grid-minor-attributes-groupitem styling-pill button-click-animation input-button theme-major" type="action">
                        <!--<div class="grid-minor-attributes-groupitem styling-pill theme-major">-->
                            <span data-i18n="item">Item</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_attribute_group_item" class="grid-minor-input-groupitem styling-pill-input theme-input-major" type="text" value="" readonly />
                    </div>
                    <!--<input name="attr_static_attribute_group_state" class="nonstandard-group" type="checkbox" value="1" checked />-->
                    <div class="group-type-visibility">
                        <div class="grid-major-attributes-nonstandardgrouphud grid-force-cell-size">
                            <div class="grid-minor-pointpool styling-pill theme-minor">
                                <input name="attr_static_attribute_group_poolname" type="hidden" value="" readonly />
                                <span name="attr_static_attribute_group_poolname"></span>
                            </div>
                            <input name="attr_static_attribute_group_poolpoints" class="grid-minor-input-pointpool styling-pill-input theme-input" type="text" value="" readonly />

                            <button name="act_static_attribute_group_level" class="grid-minor-grouplevel styling-pill button-click-animation input-button theme-minor" type="action">
                            <!--<div class="grid-minor-grouplevel styling-pill theme-minor">-->
                                <span data-i18n="level">Level</span>
                            <!--</div>-->
                            </button>
                            <input name="attr_static_attribute_group_level" class="grid-minor-input-grouplevel styling-pill-input theme-input" type="text" value="" readonly />
                            
                            <button name="act_static_attribute_group_stat" class="grid-minor-groupstat styling-pill button-click-animation input-button theme-minor" type="action">
                            <!--<div class="grid-minor-groupstat styling-pill theme-minor">-->
                                <span data-i18n="stat">Stat</span>
                            <!--</div>-->
                            </button>
                            <input name="attr_static_attribute_group_stat" class="grid-minor-input-groupstat styling-pill-input theme-input" type="text" value="" readonly />

                            <div class="grid-minor-groupcost styling-pill theme-minor">
                                <span data-i18n="cost">Cost</span>
                            </div>
                            <input name="attr_static_attribute_group_cost" class="grid-minor-input-groupcost styling-pill-input theme-input" type="text" value="" readonly />

                            <div class="grid-minor-grouptypepoints styling-pill theme-minor">
                                <span data-i18n="points">Points</span>
                            </div>
                            <input name="attr_static_attribute_group_points" class="grid-minor-input-grouptypepoints styling-pill-input theme-input" type="text" value="" readonly />

                            <button name="act_static_attribute_group_configuration" class="grid-minor-groupdescription styling-big-pill-button button-click-animation input-button theme-minor" type="action">
                            <!--<div class="grid-minor-groupdescription styling-big-pill theme-minor">-->
                                <span data-i18n="configuration" class="styling-big-pill-button-span">Configuration</span>
                                
                                <!--<span data-i18n="description">Description</span>
                                <textarea name="attr_static_attribute_group_configuration" class="grid-minor-input-groupdescription styling-big-pill-textarea-attribute theme-input" wrap="soft"></textarea>-->
                            <!--</div>-->
                            </button>
                            <textarea name="attr_static_attribute_group_configuration" class="grid-minor-input-groupdescription styling-big-pill-textarea-button theme-input" wrap="soft" placeholder="No special configuration" readonly></textarea>

                            <button name="act_static_attribute_group_enhancements" class="grid-minor-groupenhancements styling-big-pill-button button-click-animation input-button theme-minor" type="action">
                            <!--<div class="grid-minor-groupenhancements styling-big-pill theme-minor">-->
                                <span data-i18n="enhancements" class="styling-big-pill-button-span">Enhancements</span>
                                
                            <!--</div>-->
                            </button>
                            <textarea name="attr_static_attribute_group_enhancements" class="grid-minor-input-groupenhancements styling-big-pill-textarea-button theme-input" wrap="soft" placeholder="No enhancements defined" readonly></textarea>

                            <button name="act_static_attribute_group_limiters" class="grid-minor-grouplimiters styling-big-pill-button button-click-animation input-button theme-minor" type="action">
                            <!--<div class="grid-minor-grouplimiters styling-big-pill theme-minor">-->
                                <span data-i18n="limiters" class="styling-big-pill-button-span">Limiters</span>
                                
                            <!--</div>-->
                            </button>
                            <textarea name="attr_static_attribute_group_limiters" class="grid-minor-input-grouplimiters styling-big-pill-textarea-button theme-input" wrap="soft" placeholder="No limiters defined" readonly></textarea>
                        </div>
                    </div>
                    <input name="attr_static_group_visible_id" type="hidden" value="0" readonly />
                    <fieldset class="repeating_attribute">
                        <input name="attr_visibility" class="attribute-visibility" type="hidden" value="1" readonly />
                        <div class="attribute-visibility-show">
                            <input name="attr_state" class="accordion-attribute" type="checkbox" value="1" />
                            <div class="grid-container-collapsible-title-bar theme-border">
                                <div class="grid-minor-title-buttons-left">
                                    <label class="attribute-active-switch">
                                        <input name="attr_active" class="attribute-active-status" type="checkbox" value="1" />
                                        <span class="attribute-active-slider theme-slider"></span>
                                    </label>
                                </div>
                                <div class="grid-minor-section-title theme-title">
                                    <span name="attr_name"></span>
                                    <input name="attr_name" type="hidden" value="Attribute Name" />
                                </div>
                                <div class="grid-minor-title-buttons-right">
                                    <button name="act_accordion" class="styling-section-button button-click-animation theme-button" type="action">
                                        <span class="material-icons expand">expand_less</span>
                                    </button>
                                </div>
                            </div>
                            <div class="styling-border theme-border accordion-attribute">
                                <div class="styling-background force-width-74 theme-background">
                                    <div class="grid-major-attribute grid-force-cell-size">
                                        <button name="act_attribute" class="grid-minor-attribute styling-pill button-click-animation input-button theme-minor" type="action">
                                            <span data-i18n="attribute">Attrtibute</span>
                                        </button>
                                        <input name="attr_attribute" class="grid-minor-input-attribute styling-pill-input theme-input" type="text" value="" readonly />

                                        <button name="act_level" class="grid-minor-level styling-pill button-click-animation input-button theme-minor" type="action">
                                            <span data-i18n="level">Level</span>
                                        </button>
                                        <input name="attr_level" class="grid-minor-input-level styling-pill-input theme-input" type="text" value="" readonly />
                                        
                                        <button name="act_stat" class="grid-minor-stat styling-pill button-click-animation input-button theme-minor" type="action">
                                            <span data-i18n="stat">Stat</span>
                                        </button>
                                        <input name="attr_stat" class="grid-minor-input-stat styling-pill-input theme-input" type="text" value="" readonly />

                                        <div class="grid-minor-cost styling-pill theme-minor">
                                            <span data-i18n="cost">Cost</span>
                                        </div>
                                        <input name="attr_cost" class="grid-minor-input-cost styling-pill-input theme-input" type="text" value="" readonly />

                                        <div class="grid-minor-points styling-pill theme-minor">
                                            <span data-i18n="points">Points</span>
                                        </div>
                                        <input name="attr_points" class="grid-minor-input-points styling-pill-input theme-input" type="text" value="" readonly />

                                        <button name="act_configuration" class="grid-minor-configuration styling-big-pill-button button-click-animation input-button theme-minor" type="action">
                                            <span data-i18n="configuration" class="styling-big-pill-button-span">Configuration</span>
                                        </button>
                                        <textarea name="attr_configuration" class="grid-minor-input-configuration styling-big-pill-textarea-button theme-input" wrap="soft" placeholder="No special configuration" readonly></textarea>

                                        <button name="act_enhancements" class="grid-minor-enhancements styling-big-pill-button button-click-animation input-button theme-minor" type="action">
                                            <span data-i18n="enhancements" class="styling-big-pill-button-span">Enhancements</span>
                                        </button>
                                        <textarea name="attr_enhancements" class="grid-minor-input-enhancements styling-big-pill-textarea-button theme-input" wrap="soft" placeholder="No enhancements defined" readonly></textarea>

                                        <button name="act_limiters" class="grid-minor-limiters styling-big-pill-button button-click-animation input-button theme-minor" type="action">
                                            <span data-i18n="limiters" class="styling-big-pill-button-span">Limiters</span>
                                        </button>
                                        <textarea name="attr_limiters" class="grid-minor-input-limiters styling-big-pill-textarea-button theme-input" wrap="soft" placeholder="No limiters defined" readonly></textarea>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="attribute-visibility-hide"></div>
                    </fieldset>
                    <fieldset class="repeating_defect">
                        <input name="attr_visibility" class="defect-visibility" type="hidden" value="1" readonly />
                        <div class="defect-visibility-show">
                            <input name="attr_state" class="accordion-defect" type="checkbox" value="1" />
                            <div class="grid-container-collapsible-title-bar theme-border">
                                <div class="grid-minor-title-buttons-left">
                                    <label class="attribute-active-switch">
                                        <input name="attr_active" class="attribute-active-status" type="checkbox" value="1" />
                                        <span class="attribute-active-slider theme-slider"></span>
                                    </label>
                                </div>
                                <div class="grid-minor-section-title theme-title">
                                    <span name="attr_name"></span>
                                    <input name="attr_name" type="hidden" value="Defect Name" />
                                </div>
                                <div class="grid-minor-title-buttons-right">
                                    <button name="act_accordion" class="styling-section-button button-click-animation theme-button" type="action">
                                        <span class="material-icons expand">expand_less</span>
                                    </button>
                                </div>
                            </div>
                            <div class="styling-border theme-border accordion-defect">
                                <div class="styling-background theme-background">
                                    <div class="grid-major-defect">
                                        <button name="act_defect" class="grid-minor-defect styling-pill button-click-animation input-button theme-minor" type="action">
                                        <!--<div class="grid-minor-defect styling-pill theme-minor">-->
                                            <span data-i18n="defect">Defect</span>
                                        <!--</div>-->
                                        </button>
                                        <input name="attr_defect" class="grid-minor-input-defect styling-pill-input theme-input" type="text" value="" readonly />
                                        
                                        <button name="act_rank" class="grid-minor-rank styling-pill button-click-animation input-button theme-minor" type="action">
                                        <!--<div class="grid-minor-rank styling-pill theme-minor">-->
                                            <span data-i18n="rank">Rank</span>
                                        <!--</div>-->
                                        </button>
                                        <input name="attr_rank" class="grid-minor-input-rank styling-pill-input theme-input" type="text" value="" readonly />
                                        
                                        <div class="grid-minor-points styling-pill theme-minor">
                                            <span data-i18n="points">Points</span>
                                        </div>
                                        <input name="attr_points" class="grid-minor-input-defectpoints styling-pill-input theme-input" type="text" value="" readonly />
                                        
                                        <button name="act_configuration" class="grid-minor-defectconfiguration styling-big-pill-button button-click-animation input-button theme-minor" type="action">
                                        <!--<div class="grid-minor-defectconfiguration styling-big-pill theme-minor">-->
                                            <span data-i18n="configuration">Configuration</span>
                                        <!--</div>-->
                                        </button>
                                        <textarea name="attr_configuration" class="grid-minor-input-defectconfiguration styling-big-pill-textarea-attribute theme-input" wrap="soft" placeholder="No special configuration" readonly></textarea>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="defect-visibility-hide"></div>
                    </fieldset>
                </div>
            </div>
        </div>

        
        <input name="attr_static_skills_show_state" class="show-skills" type="hidden" value="1" />
        <div class="skills-visibility-show">
            <div class="section-break"></div>
            <!-- Skills Title -->
            <input name="attr_static_skills_accordions_state" class="accordion-skills" type="checkbox" value="1" />
            <div class="grid-container-title-bar theme-border">
                <!-- Title Buttons on Left -->
                <div class="grid-minor-title-buttons-left">
                    <button name="act_static_skills_uitoggle_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">checklist</span>
                    </button>
                </div>
                <!-- Title -->
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="skills">Skills</span>
                </div>
                <!-- Title Buttons on Right -->
                <div class="grid-minor-title-buttons-right">
                    <button name="act_static_skills_uiselect_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">auto_stories</span>
                    </button>
                    <button name="act_static_skills_add_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">add</span>
                    </button>
                    <button name="act_static_skills_delete_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">remove</span>
                    </button>
                    <button name="act_static_skills_accordions_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                    <input name="attr_static_skills_accordions_state" type="hidden" value="1" />
                </div>
            </div>
            <div class="styling-border theme-border">
                <div class="container-skills styling-background theme-background">
                    <div class="grid-major-skills-uihud">
                        <div class="grid-minor-skills-attribute styling-pill theme-major">
                            <span data-i18n="skills-attribute">Skills Attribute</span>
                        </div>
                        <input name="attr_static_skills_attribute_name" class="grid-minor-input-skillsattribute styling-long-pill-input theme-input-major" type="text" value="" readonly />
                        
                        <div class="grid-minor-skills-totalpoints styling-pill theme-major">
                            <span data-i18n="total-points">Total Points</span>
                        </div>
                        <input name="attr_static_skills_points_total" class="grid-minor-input-totalpoints styling-pill-input theme-input-major" type="text" value="" readonly />
                        
                        <div class="grid-minor-skills-remainingpoints styling-pill theme-major">
                            <span data-i18n="remaining">Remaining</span>
                        </div>
                        <input name="attr_static_skills_points_remaining" class="grid-minor-input-remainingpoints styling-pill-input theme-input-major" type="text" value="" readonly />
                    </div>
                    <div class="section-break"></div>
                    <input name="attr_static_skills_visible_id" type="hidden" value="0" readonly />
                    <fieldset class="repeating_skill">
                        <input name="attr_visibility" class="attribute-visibility" type="hidden" value="1" readonly />
                        <div class="attribute-visibility-show">
                            <input name="attr_state" class="accordion-attribute" type="checkbox" value="1" />
                            <div class="grid-container-collapsible-title-bar theme-border">
                                <div class="grid-minor-title-buttons-left">
                                    <label class="skills-active-switch">
                                        <input name="attr_active" class="skills-active-status" type="checkbox" value="1" />
                                        <span class="skills-active-slider theme-slider"></span>
                                    </label>
                                </div>
                                <div class="grid-minor-section-title theme-title">
                                    <span name="attr_skill"></span>
                                    <input name="attr_skill" type="hidden" value="Skill Name" />
                                </div>
                                <div class="grid-minor-title-buttons-right">
                                    <button name="act_accordion" class="styling-section-button button-click-animation theme-button" type="action">
                                        <span class="material-icons expand">expand_less</span>
                                    </button>
                                </div>
                            </div>
                            <div class="styling-border theme-border accordion-attribute">
                                <div class="styling-background theme-background">
                                    <div class="grid-major-skill">
                                        <!--
                                        <div class="grid-minor-skill styling-pill theme-minor">
                                            <span data-i18n="skill">Skill</span>
                                        </div>
                                        <input name="attr_skill" class="grid-minor-input-skill styling-pill-input theme-input" type="text" value="" readonly />
                                        -->
                                        <button name="act_rank" class="grid-minor-rank styling-pill button-click-animation input-button theme-minor" type="action">
                                        <!--<div class="grid-minor-rank styling-pill theme-minor">-->
                                            <span data-i18n="rank">Rank</span>
                                        <!--</div>-->
                                        </button>
                                        <input name="attr_rank" class="grid-minor-input-skillrank styling-pill-input theme-input" type="text" value="" readonly />
                                        
                                        <button name="act_stat" class="grid-minor-skillstat styling-pill button-click-animation input-button theme-minor" type="action">
                                        <!--<div class="grid-minor-skillstat styling-pill theme-minor">-->
                                            <span data-i18n="stat">Stat</span>
                                        <!--</div>-->
                                        </button>
                                        <input name="attr_stat" class="grid-minor-input-skillstat styling-pill-input theme-input" type="text" value="" readonly />

                                        <div class="grid-minor-skillcost styling-pill theme-minor">
                                            <span data-i18n="cost">Cost</span>
                                        </div>
                                        <input name="attr_cost" class="grid-minor-input-skillcost styling-pill-input theme-input" type="text" value="" readonly />

                                        <div class="grid-minor-skillpoints styling-pill theme-minor">
                                            <span data-i18n="points">Points</span>
                                        </div>
                                        <input name="attr_points" class="grid-minor-input-skillpoints styling-pill-input theme-input" type="text" value="" readonly />

                                        <button name="act_specializations" class="grid-minor-specializations styling-big-pill-button button-click-animation input-button theme-minor" type="action">
                                        <!--<div class="grid-minor-specializations styling-big-pill theme-minor">-->
                                            <span data-i18n="specializations">specializations</span>
                                        <!--</div>-->
                                        </button>
                                        <textarea name="attr_specializations" class="grid-minor-input-specializations styling-big-pill-textarea-specializations theme-input" wrap="soft" placeholder="No specializations" readonly></textarea>
                                        <!--<textarea name="attr_specializations" class="grid-minor-input-specializations styling-big-pill-textarea-specializations theme-input" wrap="soft" placeholder="No specializations" readonly></textarea>-->
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="skills-visibility-hide"></div>
                    </fieldset>
                </div>
            </div>
        </div>
        <div class="section-break"></div>
        <div>
            <!-- Journal Title -->
            <input name="attr_static_journal_accordion_state" class="accordion-journal" type="checkbox" value="1" />
            <div class="grid-container-collapsible-title-bar theme-border">
                <!-- Title Buttons on Left -->
                <!-- Title -->
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="journal">Journal</span>
                </div>
                <!-- Title Buttons on Right -->
                <div class="grid-minor-title-buttons-right">
                    <button name="act_static_journal_save_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">save</span>
                    </button>
                    <button name="act_static_journal_select_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">auto_stories</span>
                    </button>
                    <button name="act_static_journal_add_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">add</span>
                    </button>
                    <button name="act_static_journal_delete_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">remove</span>
                    </button>
                    <button name="act_static_journal_accordion_button" class="styling-section-button accordion-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                    <input name="static_journal_accordion_state" type="hidden" value="1" />
                </div>
            </div>
            <div class="styling-border theme-border accordion-journal">
                <div class="container-journal styling-background theme-background">
                    <input name="attr_static_journal_visible_id" type="hidden" value="0" readonly />
                    <div class="grid-major-journal">
                        <button name="act_static_journal_page_number" class="grid-minor-journal-page styling-pill button-click-animation input-button theme-major" type="action">
                        <!--<div class="grid-minor-journal-page styling-pill theme-major">-->
                            <span data-i18n="page">Page</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_journal_page_number" class="grid-minor-input-page styling-pill-input theme-input-major" type="text" value="1" readonly />
                        <button name="act_static_journal_title_name" class="grid-minor-journal-title styling-pill button-click-animation input-button theme-major" type="action">
                        <!--<div class="grid-minor-journal-title styling-pill theme-major">-->
                            <span data-i18n="title">Title</span>
                        <!--</div>-->
                        </button>
                        <input name="attr_static_journal_title_name" class="grid-minor-input-title styling-long-pill-input theme-input-major" type="text" value="Default Journal Entry" readonly />
                        <textarea name="attr_static_journal_page_entry" class="grid-minor-input-entry styling-big-pill-textarea-journal theme-input-major" placeholder="Enter text here" wrap="soft"></textarea>
                    </div>
                </div>
            </div>
        </div>
    </div>
<!--// GM SHEET //-->
    <div class="charactersheet-gm">
        <div>
            <!-- GM Title -->
            <input name="attr_static_rules_accordion_state" class="accordion-rules" type="checkbox" value="1" />
            <div class="grid-container-title-bar theme-border">
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="rules">Rules</span>
                </div>
                <!-- Title Buttons -->
                <div class="grid-minor-title-buttons-right">
                    <!--
                    <button name="act_static_gmscreen_edit_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">edit</span>
                    </button>
                    -->
                    <button name="act_static_rules_accordion_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                </div>
            </div>
            <div class="styling-border theme-border">
                <div class="styling-background theme-background">
                    <div class="grid-major-rules-top">
                        <!-- Screen Top-Left -->
                        <div class="grid-minor-pill-spacer-1 gm-logo-spacer styling-pill">
                            <span>&nbsp;</span>
                        </div>
                        <div class="grid-minor-pill-spacer-2 gm-logo-spacer styling-pill">
                            <span>&nbsp;</span>
                        </div>
                        <div class="grid-minor-pill-spacer-3 gm-logo-spacer styling-pill">
                            <span>&nbsp;</span>
                        </div>
                        <!-- Screen Top-Center -->
                        <div class="grid-minor-rules-rulebook styling-big-pill theme-major">
                            <span data-i18n="rulebook">Rule Book</span>
                            <select name="attr_static_rules_base_default" class="grid-minor-input-rulebook styling-big-pill-select theme-input-major">
                                <option value="besm">BESM</option>
                                <option value="besmx">BESM Extras</option>
                                <option value="absolutepower">Absolute Power</option>
                                <option value="tristatcore">Tri-Stat Core</option>
                            </select>
                        </div>
                        
                        <div class="grid-minor-screen-logo">&nbsp;</div>
                        <!-- Screen Top-Right -->
                        <div class="grid-minor-pill-spacer-4 gm-logo-spacer styling-pill">
                            <span>&nbsp;</span>
                        </div>
                        <div class="grid-minor-pill-spacer-5 gm-logo-spacer styling-pill">
                            <span>&nbsp;</span>
                        </div>
                        <div class="grid-minor-pill-spacer-6 gm-logo-spacer styling-pill">
                            <span>&nbsp;</span>
                        </div>
                    </div>
                    <input name="attr_static_rules_accordion_state" class="accordion-screen" type="checkbox" value="1" />
                    <div class="grid-major-rules-bottom accordion-screen">
                        <div class="grid-minor-optionalrules-title styling-pill-title theme-major">
                            <span data-i18n="optional-rules">Optional Rules</span>
                        </div>
                        
                        <div class="grid-minor-damage-header styling-pill-title theme-major">
                            <span data-i18n="damage">Damage</span>
                        </div>
                        <div class="grid-minor-rules-shockvalue styling-pill theme-minor">
                            <span data-i18n="shock-value">Shock Value</span>
                        </div>
                        <div class="grid-minor-shockvalue-state grid-minor-justify-end">
                            <input name="attr_rules_optional_shockvalue_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_shockvalue_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_shockvalue_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_shockvalue_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-knockout styling-pill theme-minor">
                            <span data-i18n="knockout">Knockout</span>
                        </div>
                        <div class="grid-minor-knockout-state grid-minor-justify-end">
                            <input name="attr_rules_optional_knockout_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_knockout_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_knockout_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_knockout_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-seriousinjury styling-pill theme-minor">
                            <span data-i18n="serious-injury">Serious Injury</span>
                        </div>
                        <div class="grid-minor-seriousinjury-state grid-minor-justify-end">
                            <input name="attr_rules_optional_seriousinjury_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_seriousinjury_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_seriousinjury_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_seriousinjury_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-variable styling-pill theme-minor">
                            <span data-i18n="variable">Variable</span>
                        </div>
                        <div class="grid-minor-input-variable grid-minor-justify-end">
                            <select name="attr_rules_optional_variable_status" class="styling-pill-select theme-input-minor">
                                <option value="fixed">Fixed Value</option>
                                <option disabled class="option-group">Damange Multiplier</option>
                                <option value="mos-dm">Margin of Success</option>
                                <option value="attackroll-dm">Attack Roll</option>
                                <option value="damageroll-dm">Damage Roll</option>
                                <option disabled class="option-group">Total Damange</option>
                                <option value="mos-td">Margin of Success</option>
                                <option value="attackroll-td">Attack Roll</option>
                                <option value="damageroll-td">Damage Roll</option>
                            </select>
                        </div>

                        <div class="grid-minor-critical-header styling-pill-title theme-major">
                            <span data-i18n="critical">Critical</span>
                        </div>
                        <div class="grid-minor-rules-criticalhits styling-pill theme-minor">
                            <span data-i18n="hits">Hits</span>
                        </div>
                        <div class="grid-minor-input-criticalhits grid-minor-justify-end">
                            <select name="attr_rules_optional_criticalhits_status" class="styling-pill-select theme-input-minor">
                                <option value="none">None</option>
                                <option value="mos">Margin of Success</option>
                                <option value="natural12">Natural 12</option>
                            </select>
                        </div>
                        <div class="grid-minor-rules-criticalfailures styling-pill theme-minor">
                            <span data-i18n="failures">Failures</span>
                        </div>
                        <div class="grid-minor-input-criticalfailures grid-minor-justify-end">
                            <select name="attr_rules_optional_criticalfailures_status" class="styling-pill-select theme-input-minor">
                                <option value="none">None</option>
                                <option value="mos">Margin of Success</option>
                                <option value="natural2">Natural 2</option>
                            </select>
                        </div>

                        <div class="grid-minor-rolls-header styling-pill-title theme-major">
                            <span data-i18n="rolls">Rolls</span>
                        </div>
                        <div class="grid-minor-rules-dice styling-pill theme-minor">
                            <span data-i18n="dice">Dice</span>
                        </div>
                        <div class="grid-minor-input-dice grid-minor-justify-end">
                            <select name="attr_rules_optional_dice_status" class="styling-pill-select theme-input-minor">
                                <option value="normal">Normal</option>
                                <option value="spillover">Spillover</option>
                                <option value="rerolls">Rerolls</option>
                                <option value="exceed">Exceed Two Dice</option>
                            </select>
                        </div>
                        <div class="grid-minor-rules-mos styling-pill theme-minor">
                            <span data-i18n="show-margin-of-success">Show Margin of Success</span>
                        </div>
                        <div class="grid-minor-mos-state grid-minor-justify-end">
                            <input name="attr_rules_optional_mos_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_mos_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_mos_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_mos_icon" type="hidden" value="_" />
                            </button>
                        </div>

                        <div class="grid-minor-combat-header styling-pill-title theme-major">
                            <span data-i18n="combat">Combat</span>
                        </div>
                        <div class="grid-minor-rules-maneuvers styling-pill theme-minor">
                            <span data-i18n="combat-maneuvers">Combat Maneuvers</span>
                        </div>
                        <div class="grid-minor-maneuvers-state grid-minor-justify-end">
                            <input name="attr_rules_optional_maneuvers_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_maneuvers_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_maneuvers_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_maneuvers_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-extradamage styling-pill theme-minor">
                            <span data-i18n="extra-ranged-damage">Extra Ranged Damage</span>
                        </div>
                        <div class="grid-minor-extradamage-state grid-minor-justify-end">
                            <input name="attr_rules_optional_extradamage_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_extradamage_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_extradamage_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_extradamage_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-knockback styling-pill theme-minor">
                            <span data-i18n="knockback">Knockback</span>
                        </div>
                        <div class="grid-minor-knockback-state grid-minor-justify-end">
                            <input name="attr_rules_optional_knockback_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_knockback_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_knockback_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_knockback_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-movementpenalties styling-pill theme-minor">
                            <span data-i18n="movement-penalties">Movement Penalties</span>
                        </div>
                        <div class="grid-minor-movementpenalties-state grid-minor-justify-end">
                            <input name="attr_rules_optional_movementpenalties_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_movementpenalties_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_movementpenalties_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_movementpenalties_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-rangepenalties styling-pill theme-minor">
                            <span data-i18n="range-penalties">Range Penalties</span>
                        </div>
                        <div class="grid-minor-rangepenalties-state grid-minor-justify-end">
                            <input name="attr_rules_optional_rangepenalties_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_rangepenalties_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_rangepenalties_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_rangepenalties_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-spreadinitiative styling-pill theme-minor">
                            <span data-i18n="spread-initiative">Spread Initiative</span>
                        </div>
                        <div class="grid-minor-spreadinitiative-state grid-minor-justify-end">
                            <input name="attr_rules_optional_spreadinitiative_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_spreadinitiative_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_spreadinitiative_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_spreadinitiative_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-shield styling-pill theme-minor">
                            <span data-i18n="strike-shield">Striking a Shield</span>
                        </div>
                        <div class="grid-minor-shield-state grid-minor-justify-end">
                            <input name="attr_rules_optional_shield_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_shield_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_shield_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_shield_icon" type="hidden" value="_" />
                            </button>
                        </div>

                        <div class="grid-minor-skills-header styling-pill-title theme-major">
                            <span data-i18n="skills">Skills</span>
                        </div>
                        <div class="grid-minor-rules-individual styling-pill theme-minor">
                            <span data-i18n="individual-skills">Individual Skills</span>
                        </div>
                        <div class="grid-minor-individual-state grid-minor-justify-end">
                            <input name="attr_rules_optional_individual_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_individual_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_individual_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_individual_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-genre styling-pill theme-minor">
                            <span data-i18n="skill-genre">Skill Genre</span>
                        </div>
                        <div class="grid-minor-input-genre grid-minor-justify-end">
                            <select name="attr_rules_optional_genre_status" class="styling-pill-select theme-input-minor">
                                <option value="0">Multi-Genre</option>
                                <option value="1">Action Adventure</option>
                                <option value="2">Animal Adventures</option>
                                <option value="3">Classic Horror</option>
                                <option value="4">Detective</option>
                                <option value="5">Loony Cartoons</option>
                                <option value="6">Romantic Comedy</option>
                                <option value="7">Slice of Life</option>
                                <option value="8">Spy Thriller</option>
                                <option value="9">Supernatural Occult</option>
                                <option value="10">Eco Fantasy</option>
                                <option value="11">High Fantasy</option>
                                <option value="12">Low Fantasy</option>
                                <option value="13">Urban Fantasy</option>
                                <option value="14">Cyberpunk/Realitypunk</option>
                                <option value="15">Hard SF</option>
                                <option value="16">Mecha Drama</option>
                                <option value="17">Post-Apocalyptic</option>
                                <option value="18">Soft SF</option>
                                <option value="19">Space Opera</option>
                                <option value="20">20th Century War</option>
                                <option value="21">Age of Discovery</option>
                                <option value="22">Age of Pirates</option>
                                <option value="23">Age of Samurai</option>
                                <option value="24">Ancient Mediterranean</option>
                                <option value="25">Industrial Age</option>
                                <option value="26">Middle Ages</option>
                                <option value="27">Steampunk</option>
                                <option value="28">Stone Age</option>
                                <option value="29">Wild West</option>
                            </select>
                        </div>
                        
                        <div class="grid-minor-other-header styling-pill-title theme-major">
                            <span data-i18n="other">Other</span>
                        </div>
                        <div class="grid-minor-rules-enhancedrecovery styling-pill theme-minor">
                            <span data-i18n="enhanced-recovery">Enhanced Recovery</span>
                        </div>
                        <div class="grid-minor-enhancedrecovery-state grid-minor-justify-end">
                            <input name="attr_rules_optional_enhancedrecovery_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_enhancedrecovery_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_enhancedrecovery_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_enhancedrecovery_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-sanity styling-pill theme-minor">
                            <span data-i18n="sanity">Sanity</span>
                        </div>
                        <div class="grid-minor-sanity-state grid-minor-justify-end">
                            <input name="attr_rules_optional_sanity_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_sanity_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_sanity_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_sanity_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-society styling-pill theme-minor">
                            <span data-i18n="society">Society</span>
                        </div>
                        <div class="grid-minor-society-state grid-minor-justify-end">
                            <input name="attr_rules_optional_society_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_society_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_society_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_society_icon" type="hidden" value="_" />
                            </button>
                        </div>

                        <div class="grid-minor-normalize-title styling-pill-title theme-major">
                            <span data-i18n="normalize-rulebooks">Normalize Rulebooks</span>
                        </div>
                        <div class="grid-minor-attributes-header styling-pill-title theme-major">
                            <span data-i18n="attributes">Attributes</span>
                        </div>
                        <div class="grid-minor-rules-expertise styling-pill theme-minor">
                            <span data-i18n="expertise">Expertise</span>
                        </div>
                        <div class="grid-minor-expertise-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_expertise_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_expertise_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_expertise_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_expertise_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-extradefenses styling-pill theme-minor">
                            <span data-i18n="extra-defenses">Extra Defenses</span>
                        </div>
                        <div class="grid-minor-extradefenses-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_extradefenses_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_extradefenses_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_extradefenses_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_extradefenses_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-miniobject styling-pill theme-minor">
                            <span data-i18n="mini-object">Mini Object</span>
                        </div>
                        <div class="grid-minor-miniobject-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_miniobject_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_miniobject_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_miniobject_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_miniobject_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-taunt styling-pill theme-minor">
                            <span data-i18n="taunt">Taunt</span>
                        </div>
                        <div class="grid-minor-taunt-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_taunt_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_taunt_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_taunt_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_taunt_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-combattechnique styling-pill-title theme-minor">
                            <span data-i18n="combat-technique">Combat Technique</span>
                        </div>
                        <div class="grid-minor-rules-deathdodge styling-pill theme-minor">
                            <span data-i18n="death-dodge">Death Dodge</span>
                        </div>
                        <div class="grid-minor-deathdodge-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_deathdodge_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_deathdodge_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_deathdodge_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_deathdodge_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-debilitate styling-pill theme-minor">
                            <span data-i18n="debilitate">Debilitate</span>
                        </div>
                        <div class="grid-minor-debilitate-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_debilitate_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_debilitate_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_debilitate_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_debilitate_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-eknockback styling-pill theme-minor">
                            <span data-i18n="enhanced-knockback">Enhanced Knockback</span>
                        </div>
                        <div class="grid-minor-eknockback-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_eknockback_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_eknockback_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_eknockback_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_eknockback_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-flankdefense styling-pill theme-minor">
                            <span data-i18n="flanking-defense">Flanking Defense</span>
                        </div>
                        <div class="grid-minor-flankdefense-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_flankdefense_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_flankdefense_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_flankdefense_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_flankdefense_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-hardboiled styling-pill theme-minor">
                            <span data-i18n="hardboiled">Hardboiled</span>
                        </div>
                        <div class="grid-minor-hardboiled-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_hardboiled_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_hardboiled_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_hardboiled_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_hardboiled_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-tournament styling-pill theme-minor">
                            <span data-i18n="tournament-encyclopedia">Tournament Encyclopedia</span>
                        </div>
                        <div class="grid-minor-tournament-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_tournament_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_tournament_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_tournament_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_tournament_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-specialmovement styling-pill-title theme-minor">
                            <span data-i18n="special-movement">Special Movement</span>
                        </div>
                        <div class="grid-minor-rules-speedburst styling-pill theme-minor">
                            <span data-i18n="speedburst">Speedburst</span>
                        </div>
                        <div class="grid-minor-speedburst-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_speedburst_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_speedburst_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_speedburst_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_speedburst_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        
                        <div class="grid-minor-enhancements-header styling-pill-title theme-major">
                            <span data-i18n="enhancements">Enhancements</span>
                        </div>
                        <div class="grid-minor-rules-cognition styling-pill theme-minor">
                            <span data-i18n="cognition-p-area">Cognition.Area</span>
                        </div>
                        <div class="grid-minor-cognition-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_cognition_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_cognition_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_cognition_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_cognition_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-sixthsense styling-pill theme-minor">
                            <span data-i18n="sixthsense-p-range">Sixth Sense.Range</span>
                        </div>
                        <div class="grid-minor-sixthsense-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_sixthsense_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_sixthsense_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_sixthsense_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_sixthsense_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-summoncreature styling-pill theme-minor">
                            <span data-i18n="summon-creatures-p-area">Summon Creatures.Area</span>
                        </div>
                        <div class="grid-minor-summoncreature-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_summoncreatures_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_summoncreatures_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_summoncreatures_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_summoncreatures_icon" type="hidden" value="_" />
                            </button>
                        </div>

                        <div class="grid-minor-rules-transfer styling-pill theme-minor">
                            <span data-i18n="transfer-p-area-p-targets">Transfer.Area.Targets</span>
                        </div>
                        <div class="grid-minor-transfer-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_transfer_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_transfer_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_transfer_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_transfer_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-custenhancements-header styling-pill-title theme-major">
                            <span data-i18n="custom-enhancements">Custom Enhancements</span>
                        </div>
                        <div class="grid-minor-rules-absorption styling-pill theme-minor">
                            <span data-i18n="absorption-p-synergistic">Absorption.Synergistic</span>
                        </div>
                        <div class="grid-minor-absorption-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_absorption_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_absorption_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_absorption_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_absorption_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-conversion styling-pill theme-minor">
                            <span data-i18n="conversion-p-escalate">Conversion.Escalate</span>
                        </div>
                        <div class="grid-minor-conversion-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_conversion_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_conversion_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_conversion_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_conversion_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-forcefield styling-pill theme-minor">
                            <span data-i18n="forcefield-p-airtight">Forcefield.Air-tight</span>
                        </div>
                        <div class="grid-minor-forcefield-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_forcefield_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_forcefield_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_forcefield_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_forcefield_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-powerflux styling-pill theme-minor">
                            <span data-i18n="power-flux-p-debuff">Power Flux.Debuff</span>
                        </div>
                        <div class="grid-minor-powerflux-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_powerflux_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_powerflux_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_powerflux_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_powerflux_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-sizechange styling-pill theme-minor">
                            <span data-i18n="size-change-p-modified-shrinking">Size Change.Mod Shrinking</span>
                        </div>
                        <div class="grid-minor-sizechange-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_sizechange_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_sizechange_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_sizechange_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_sizechange_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-teleport styling-pill theme-minor">
                            <span data-i18n="teleport-p-blind">Teleport.Blind</span>
                        </div>
                        <div class="grid-minor-teleport-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_teleport_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_teleport_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_teleport_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_teleport_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-weaponenhancements-header styling-pill-title theme-major">
                            <span data-i18n="weapon-enhancements">Weapon Enhancements</span>
                        </div>
                        <div class="grid-minor-rules-weapon styling-pill theme-minor">
                            <span data-i18n="anemic-c-demoralize-c-lethargy">Anemic, Demoralize, Lethargy</span>
                        </div>
                        <div class="grid-minor-weapon-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_weapon_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_weapon_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_weapon_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_weapon_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-limiters-header styling-pill-title theme-major">
                            <span data-i18n="limiters">Limiters</span>
                        </div>
                        <div class="grid-minor-rules-timed styling-pill theme-minor">
                            <span data-i18n="timed">Timed</span>
                        </div>
                        <div class="grid-minor-timed-state grid-minor-justify-end">
                            <input name="attr_rules_limiter_timed_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_limiter_timed_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_limiter_timed_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_limiter_timed_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-custlimiters-header styling-pill-title theme-major">
                            <span data-i18n="custom-limiters">Custom Limiters</span>
                        </div>
                        <div class="grid-minor-rules-capped styling-pill theme-minor">
                            <span data-i18n="absorption-p-capped">Absorption.Capped</span>
                        </div>
                        <div class="grid-minor-capped-state grid-minor-justify-end">
                            <input name="attr_rules_limiter_absorption_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_limiter_absorption_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_limiter_absorption_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_limiter_absorption_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-proportionaldamage styling-pill theme-minor">
                            <span data-i18n="merge-p-proportionaldamage">Merge.Proportional Damage</span>
                        </div>
                        <div class="grid-minor-proportionaldamage-state grid-minor-justify-end">
                            <input name="attr_rules_limiter_merge_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_limiter_merge_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_limiter_merge_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_limiter_merge_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-plantcontrol styling-pill theme-minor">
                            <span data-i18n="plantcontrol-p-group-c-species">Plant Control.Group, Species</span>
                        </div>
                        <div class="grid-minor-plantcontrol-state grid-minor-justify-end">
                            <input name="attr_rules_limiter_plantcontrol_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_limiter_plantcontrol_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_limiter_plantcontrol_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_limiter_plantcontrol_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-skillflux styling-pill theme-minor">
                            <span data-i18n="powerflux-p-skillflux">Power Flux.Skill Flux</span>
                        </div>
                        <div class="grid-minor-skillflux-state grid-minor-justify-end">
                            <input name="attr_rules_limiter_powerflux_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_limiter_powerflux_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_limiter_powerflux_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_limiter_powerflux_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-transmute styling-pill theme-minor">
                            <span data-i18n="transmute-p-material-category">Transmute.Material Category</span>
                        </div>
                        <div class="grid-minor-transmute-state grid-minor-justify-end">
                            <input name="attr_rules_limiter_transmute_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_limiter_transmute_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_limiter_transmute_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_limiter_transmute_icon" type="hidden" value="_" />
                            </button>
                        </div>

                        <div class="grid-minor-defects-header styling-pill-title theme-major">
                            <span data-i18n="defects">Defects</span>
                        </div>
                        <div class="grid-minor-rules-nohealing styling-pill theme-minor">
                            <span data-i18n="no-healing">No Healing</span>
                        </div>
                        <div class="grid-minor-nohealing-state grid-minor-justify-end">
                            <input name="attr_rules_defect_nohealing_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_defect_nohealing_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_defect_nohealing_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_defect_nohealing_icon" type="hidden" value="_" />
                            </button>
                        </div>

                        <div class="grid-minor-homebrew-title styling-pill-title theme-major">
                            <span data-i18n="alternate-homebrew-and-beta">Alternate, Homebrew, and Beta</span>
                        </div>
                        <div class="grid-minor-altrules-header styling-pill-title theme-major">
                            <span data-i18n="alternate-rules">Alternate Rules</span>
                        </div>
                        <!--
                        <div class="grid-minor-rules-ammotracking styling-pill theme-minor">
                            <span data-i18n="ammo-tracking">Ammo Tracking</span>
                        </div>
                        <div class="grid-minor-ammotracking-state grid-minor-justify-end">
                            <input name="attr_rules_homebrew_ammotracking_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_homebrew_ammotracking_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_homebrew_ammotracking_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_homebrew_ammotracking_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-depletereserve styling-pill theme-minor">
                            <span data-i18n="easy-deplete">Easy Deplete</span>
                        </div>
                        <div class="grid-minor-depletereserve-state grid-minor-justify-end">
                            <input name="attr_rules_homebrew_depletereserve_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_homebrew_depletereserve_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_homebrew_depletereserve_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_homebrew_depletereserve_icon" type="hidden" value="_" />
                            </button>
                        </div>
                    -->

                        <div class="grid-minor-homebrewrules-header styling-pill-title theme-major">
                            <span data-i18n="homebrew-rules">Homebrew Rules</span>
                        </div>
                        <!--
                        <div class="grid-minor-rules-disperse styling-pill theme-minor">
                            <span data-i18n="armor-p-disperse">Armor.Disperse</span>
                        </div>
                        <div class="grid-minor-disperse-state grid-minor-justify-end">
                            <input name="attr_rules_homebrew_disperse_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_homebrew_disperse_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_homebrew_disperse_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_homebrew_disperse_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-specificlimiter styling-pill theme-minor">
                            <span data-i18n="forccefield-p-specific">Forcefield.Specific</span>
                        </div>
                        <div class="grid-minor-specificlimiter-state grid-minor-justify-end">
                            <input name="attr_rules_homebrew_specificlimiter_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_homebrew_specificlimiter_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_homebrew_specificlimiter_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_homebrew_specificlimiter_icon" type="hidden" value="_" />
                            </button>
                        </div>
                    -->
                        <div class="grid-minor-betafeatures-header styling-pill-title theme-major">
                            <span data-i18n="beta-features">Beta Features</span>
                        </div>
                        <div class="grid-minor-rules-donotconfirm styling-pill theme-minor">
                            <span data-i18n="quick-delete">Quick Delete</span>
                        </div>
                        <div class="grid-minor-donotconfirm-state grid-minor-justify-end">
                            <input name="attr_rules_homebrew_donotconfirm_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_homebrew_donotconfirm_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_homebrew_donotconfirm_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_homebrew_donotconfirm_icon" type="hidden" value="_" />
                            </button>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<!---->
<div style="display:none; visibility: hidden">
    <!-- React Buttons -->
    <button type="action" name="act_react_button_roll_defense"></button>
    <button type="action" name="act_react_button_roll_skill"></button>
    <button type="action" name="act_react_button_roll_stat"></button>
    <!-- Default Values -->
    <input type="hidden" name="attr_character_default_value_points" value="" />
</div>
<!-- Roll Templates -->
<rolltemplate class="sheet-rolltemplate-rolls">
    <div class="sheet-rt-outer {{color}}">
        <div class="sheet-rt-header">
            <div class="sheet-rt-title {{color}}"><span>{{title}}</span></div>
            {{#emote}}
            <div class="sheet-rt-emote">
                <span>{{emote}}</span>
            </div>
            {{/emote}}
        </div>
        <!-- BODY -->
        <div class="sheet-rt-body">
            {{#twodsix}}
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Dice Rolled</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll sheet-rt-d6font">
                    {{computed::dice0}}
                    {{computed::dice1}}
                    {{computed::dice2}}
                    {{computed::dice3}}
                    {{computed::dice4}}
                    {{computed::dice5}}
                    {{computed::dice6}}
                    {{computed::dice7}}
                    {{computed::dice8}}
                    {{computed::dice9}}
                    {{computed::dice10}}
                    {{computed::dice11}}
                </div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Total</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{computed::total}}</div>
            </div>
            {{/twodsix}} {{#attack}}
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Dice Rolled</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll sheet-rt-d6font">
                    {{computed::dice0}}
                    {{computed::dice1}}
                    {{computed::dice2}}
                    {{computed::dice3}}
                    {{computed::dice4}}
                    {{computed::dice5}}
                    {{computed::dice6}}
                    {{computed::dice7}}
                    {{computed::dice8}}
                    {{computed::dice9}}
                    {{computed::dice10}}
                    {{computed::dice11}}
                </div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Base</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{base}}</div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Total</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{computed::total}}</div>
            </div>
            {{/attack}} {{#initiative}}
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Dice Rolled</div>
                <!--<div class="sheet-rt-value sheet-sheet-mouseover-hideroll sheet-rt-d6font">{{computed::dice0}}{{computed::dice1}}{{computed::dice2}}{{computed::dice3}}</div>-->
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll sheet-rt-d6font">
                    {{computed::dice0}}
                    {{computed::dice1}}
                    {{computed::dice2}}
                    {{computed::dice3}}
                    {{computed::dice4}}
                    {{computed::dice5}}
                    {{computed::dice6}}
                    {{computed::dice7}}
                    {{computed::dice8}}
                    {{computed::dice9}}
                    {{computed::dice10}}
                    {{computed::dice11}}
                </div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Base</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{base}}</div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Total</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{computed::total}}</div>
            </div>
            {{/initiative}} {{#stat}}
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Dice Rolled</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll sheet-rt-d6font">
                    {{computed::dice0}}
                    {{computed::dice1}}
                    {{computed::dice2}}
                    {{computed::dice3}}
                    {{computed::dice4}}
                    {{computed::dice5}}
                    {{computed::dice6}}
                    {{computed::dice7}}
                    {{computed::dice8}}
                    {{computed::dice9}}
                    {{computed::dice10}}
                    {{computed::dice11}}
                </div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Base</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{base}}</div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Total</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{computed::total}}</div>
            </div>
            {{/stat}}
        </div>
    </div>
    {{#react}}
    <div class="sheet-rt-react-outer {{color-react}}">
        <div class="sheet-rt-react-header">
            <span>{{reactheader}}</span>
        </div>
        <div class="sheet-rt-row">
            <div class="sheet-rt-react-title">
                {{reacttitle}}
            </div>
            {{#react-button}}
            <div class="sheet-rt-react-button {{color-react}}">
                [{{reactlabel}}](~selected|{{reactlink}}||{{computed::reactdata}})
            </div>
            {{/react-button}} {{^react-button}}
            <div class="sheet-rt-react-tn {{color-react}}">
                {{react-tn}}
            </div>
            {{/react-button}}
        </div>
    </div>
    {{/react}}
</rolltemplate>

<rolltemplate class="sheet-rolltemplate-rolls-result">
    <div class="sheet-rt-result-outer {{result-spacer}} {{color}}">
        {{^resume}}
        <div class="sheet-header-spacer"></div>
        <div class="sheet-rt-header">
            <div class="sheet-rt-title {{color}}">
                {{result-header}}
            </div>
            {{#emote}}
            <div class="sheet-rt-emote">
                <span>{{emote}}</span>
            </div>
            {{/emote}}
        </div>
        {{/resume}}
        <div class="sheet-rt-body">
            {{#autofire}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Autofire Hits</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{autofire}}</div>
            </div>
            {{/autofire}} {{^defended}} {{#damage}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{stun}}Damage{{#autofire}} per hit{{/autofire}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">+{{damage}}</div>
            </div>
            {{/damage}} {{#penetrating}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Penetrating (armor)</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{penetrating}}</div>
            </div>
            {{/penetrating}} {{#piercing}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Piercing (force field)</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{piercing}}</div>
            </div>
            {{/piercing}} {{/defended}} {{#forcefield0key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{forcefield0key}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{forcefield0value}}</div>
            </div>
            {{/forcefield0key}} {{#shield}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{shieldname}} Stopped</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{shield}}</div>
            </div>
            {{/shield}} {{#armor0key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{armor0key}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{armor0value}}</div>
            </div>
            {{/armor0key}} {{#armor1key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{armor1key}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{armor1value}}</div>
            </div>
            {{/armor1key}} {{#armor2key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{armor2key}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{armor2value}}</div>
            </div>
            {{/armor2key}} {{#mindshield}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{mindshieldname}} Stopped</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{mindshield}}</div>
            </div>
            {{/mindshield}} {{#absorption0key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{absorption0key}} Absorbed</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{absorption0value}}</div>
            </div>
            {{/absorption0key}} {{#absorption1key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{absorption1key}} Absorbed</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{absorption1value}}</div>
            </div>
            {{/absorption1key}} {{#absorption2key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{absorption2key}} Absorbed</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{absorption2value}}</div>
            </div>
            {{/absorption2key}} {{#absorption3key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{absorption3key}} Absorbed</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{absorption3value}}</div>
            </div>
            {{/absorption3key}} {{#conversion0key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{conversion0key}} Converted</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{conversion0value}}</div>
            </div>
            {{/conversion0key}} {{#continuing}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Continuing Damage (+{{continuing}})</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{continuingrounds}} Rounds</div>
            </div>
            {{/continuing}} {{#blight}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Blight!</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">TN {{blight}}</div>
            </div>
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Blight Applies To</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{blightappliesto}}</div>
            </div>
            {{/blight}} {{#statroll}}
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Stat Roll Base</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{rollbase}}</div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Stat Roll</div>
                <div class="sheet-rt-value">{{statroll}}</div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Stat Roll Total</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{rolltotal}}</div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Stat Roll Result</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{#^rollLess() rolltotal target}}Success{{/^rollLess() rolltotal target}}{{#rollLess() rolltotal target}}Failed{{/rollLess() rolltotal target}}</div>
            </div>
            {{/statroll}} {{^blight}} {{#seriouswound}}
            <div class="sheet-result-fail sheet-rt-grid center">
                <span>Seriously Wounded!!!</span>
            </div>
            {{/seriouswound}} {{#damagetaken}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Damage Taken</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{damagetaken}}</div>
            </div>
            {{#catastrophictn}} 
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Catastrophic Damage!!!</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">TN {{catastrophictn}}</div>
            </div>
            {{/catastrophictn}} {{/damagetaken}} {{#shocktn}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">System Shock</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">TN {{shocktn}}</div>
            </div>
            {{/shocktn}} {{/blight}} {{#shock}} 
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{shockoutcome}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{shockrounds}}</div>
            </div>
            {{/shock}} {{#catastrophic}} 
            <div class="besm-emote">
                <span>{{catastrophicoutcome}}</span>
            </div>
            {{/catastrophic}} {{#reactvalue1}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey1}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue1}}</div>
            </div>
            {{/reactvalue1}} {{#reactvalue2}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey2}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue2}}</div>
            </div>
            {{/reactvalue2}} {{#reactvalue3}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey3}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue3}}</div>
            </div>
            {{/reactvalue3}} {{#reactvalue4}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey4}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue4}}</div>
            </div>
            {{/reactvalue4}} {{#reactvalue5}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey5}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue5}}</div>
            </div>
            {{/reactvalue5}} {{#reactvalue6}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey6}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue6}}</div>
            </div>
            {{/reactvalue6}} {{#reactvalue7}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey7}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue7}}</div>
            </div>
            {{/reactvalue7}} {{#reactvalue8}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey8}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue8}}</div>
            </div>
            {{/reactvalue8}} {{#reactvalue9}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey9}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue9}}</div>
            </div>
            {{/reactvalue9}} {{#reactvalue10}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey10}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue10}}</div>
            </div>
            {{/reactvalue10}} {{#reactvalue11}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey11}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue11}}</div>
            </div>
            {{/reactvalue11}}
        </div>
    </div>
    <div class="sheet-footer-spacer"></div>
    {{#react}}
    <div class="sheet-rt-react-outer {{color}}">
        <div class="sheet-rt-react-header">
            <span>Reactive Rolls:</span>
        </div>
        <div class="sheet-rt-row">
            <div class="sheet-rt-react-title">
                {{reacttitle}}
            </div>
            <div class="sheet-rt-react-button">
                [{{reactlabel}}](~selected|{{reactlink}}||{{computed::reactdata}})
            </div>
        </div>
    </div>
    {{/react}}
</rolltemplate>
<rolltemplate class="sheet-rolltemplate-display-help">
    <div>
        [Sheet Documentation](https://wiki.roll20.net/Big_Eyes_Small_Mouth_4E_-_Dyskami_Authorized)
    </div>
</rolltemplate>
<!-- Sheet Workers -->
<script type="text/worker">
    /* Global Variables */
    const global_sheet_current_version = 0.9;
    const all_attributes = ['absorption','alternate form','alternate identity','armor','attack mastery','augmented','capacity','change state','cognition','combat technique','companion','connected','control environment','conversion','data access','defense mastery','dimension walk','dynamic powers','elasticity','enemy attack','enemy defense','energized','exorcism','expertise','extra actions','extra arms','extra defenses','features','flight','force field','ground speed','healing','heightened awareness','heightened senses','illusion','immovable','immunity','immutable','inspire','jumping','massive damage','melee attack','melee defense','merge','metamorphosis','mimic','mind control','mind shield','minions','mulligan','nullify','plant control','pocket dimension','portal','power flux','power variation','projection','ranged attack','ranged defense','regeneration','reincarnation','resilient','sensory block','sixth sense','size change','skill group','skills','social mastery','spaceflight','special movement','summon creatures','supersense','superspeed','superstrength','swarm','taunt','telekinesis','telepathy','teleport','tough','transfer','transmute','tunneling','unaffected','unassailable','undetectable','unknown power','water speed','wealth','weapon'];
    const all_conditions = ['anemic','blinded','contagious','continuing','dead','demoralized','drained','incapacitated','incurable','irritant','lethargic','prone','serious injury','stunned','tangled','unconscious'];
    const all_defects = ['achilles heel','awkward size','bane','blind fury','conditional ownership','confined','cursed','demure','easily distracted','fragile','hounded','impaired manipulation','impaired speech','inept attack','inept defense','involuntary change','ism','magnet','marked','nemesis','nightmares','no healing','obligated','phobia','physical impairment','red tape','reduced damage','sensory impairment','shortcoming','significant other','skeleton in the closet','social fault','special requirement','unappealing','unique defect','unsettled','vulnerability','wanted','weak point'];
    const all_stats = ['body','mind','soul'];
    const all_optional_rules = ['optional_enhancedrecovery','optional_maneuvers','optional_extradamage','optional_individual','optional_knockback','optional_mos','optional_movementpenalties','optional_rangepenalties','optional_sanity','optional_shield','optional_society','optional_spreadinitiative'];
    const all_normalizations = ['attribute_deathdodge','attribute_debilitate','attribute_expertise','attribute_extradefenses','attribute_flankdefense','attribute_miniobject','attribute_speedburst','attribute_taunt','attribute_tournament','defect_nohealing','enhancement_absorption','enhancement_cognition','enhancement_conversion','enhancement_forcefield','enhancement_powerflux','enhancement_sixthsense','enhancement_sizechange','enhancement_summoncreature','enhancement_teleport','enhancement_transfer','enhancement_weapon','limiter_absorption','limiter_merge','limiter_plantcontrol','limiter_powerflux','limiter_timed','limiter_transmute'];
    const all_homebrew_rules = ['homebrew_ammotracking','homebrew_depletereserve','homebrew_disperse','homebrew_specificlimiter'];
    const base_attributes = ['absorption','alternate form','alternate identity','armor','attack mastery','augmented','capacity','change state','cognition','combat technique','companion','connected','control environment','conversion','data access','defense mastery','dimension walk','elasticity','enemy attack','enemy defense','energized','exorcism','extra actions','extra arms','features','flight','force field','ground speed','healing','heightened awareness','heightened senses','illusion','immunity','immutable','inspire','jumping','massive damage','melee attack','melee defense','merge','metamorphosis','mimic','mind control','mind shield','minions','mulligan','nullify','plant control','pocket dimension','portal','projection','ranged attack','ranged defense','regeneration','reincarnation','resilient','sensory block','sixth sense','size change','skill group','skills','spaceflight','special movement','summon creatures','supersense','superspeed','superstrength','swarm','telekinesis','telepathy','teleport','tough','transfer','transmute','tunneling','unaffected','undetectable','unknown power','water speed','wealth','weapon'];
    const tsc_ap_attributes = ['expertise','taunt'];
    const besmx_attributes = ['extra defenses'];
    const kb_attributes = ['immovable'];
    const dbs = ['attrdb','conditiondb','defectdb','groupdb','journaldb','rolldb','statsdb'];
    const all_skills = ['acrobatics','animal training','architecture','area knowledge','artisan','biological sciences','boating','burglary','business','civilisation','climbing','computers','controlled breathing','cultural arts','demolitions','disguise','domestic arts','driving','engineering','environmental sciences','electronics','empathy','etiquette','forgery','gaming','interrogation','intimidation','languages','law','leadership','listening','mechanics','medical','military sciences','naturopathy','navigation','occult','occupation','performing arts','persuasion','physical sciences','piloting','poisons','police sciences','power lifting','religion','riding','search','seduction','sleight of hand','social sciences','sports','stealth','street sense','survival','swimming','urban tracking','visual arts','wilderness tracking','writing'];
    const all_skill_groups = ['academic','adventuring','artistic','business','detective','domestic','military','occupation','scientific','social','street','technical'];
    const normalize_attributes = {
        'attribute_expertise':'expertise',
        'attribute_extradefenses':'extra defenses',
        'optional_knockback':'immovable',
        'optional_sanity':'unassailable',
        'optional_society':'social mastery',
        'attribute_taunt':'taunt'
    };
    const customization_type = ['enhancements', 'limiters'];
    const standard_enhancements = {
        'control environment':['area','duration','range'],
        'dimension walk':['area'],
        'dynamic powers':['area','duration','range','targets'],
        'exorcism':['area','range','targets'],
        'force field':['area','duration','range'],
        'healing':['area','range','targets'],
        'illusion':['area','duration','range','targets'],
        'merge':['duration'],
        'metamorphosis':['area','duration','range','targets'],
        'mimic':['duration','range'],
        'mind control':['area','duration','range','targets'],
        'nullify':['area','duration','range','targets'],
        'plant control':['duration'],
        'portal':['area','duration','range','targets'],
        'power flux':['area','duration','range','targets'],
        'power variation':['area','duration','range','targets'],
        'projection':['area','duration','range'],
        'sensory block':['area','duration','range'],
        'sixth sense':['area'],
        'size change':['duration'],
        'summon creatures':['duration'],
        'telekinesis':['area','range'],
        'telepathy':['area','range','targets'],
        'teleport':['area','range','targets'],
        'transfer':['duration','range'],
        'transmute':['duration','range','targets'],
        'unique attribute':['area','duration','range','targets'],
        'unknown power':['area','duration','range','targets'],
        'weapon':['area','duration','range'],
        'default':[]
    };
    const base_custom_enhancements = {
        'change state':['quick change'],
        'connected':['significant power','great power'],
        'dynamic powers':['major category','primal category'],
        'force field':['blocks incorporeal','blocks teleport','field-penetrating','offensive','regenerating'],
        'illusion':['extra sense','multiple illusions'],
        'inspire':['galvanize'],
        'metamorphosis':['multiform','any form'],
        'mimic':['all powers'],
        'nullify':['multiple attributes'],
        'power flux':['major category','primal category'],
        'projection':['few projections','several projections'],
        'reincarnation':['difficult to stop'],
        'resilient':['complete'],
        'size change':['both ways'],
        'summon creatures':['supernatural','dimensional'],
        'transfer':['all attributes'],
        'transmute':['resize','gaseous'],
        'unaffected':['all weapons','several attributes','many attributes','all attributes'],
        'weapon':['accurate','aura','autofire','blight','contact','contagious','continuing','drain','enervation','flare','flexible','helper','homing','incapacitating','inconspicuous','incurable','indirect','insidious','irritant','linked','multidimensional','muscle','penetrating','piercing','psychic','quake','reach','selective','spreading','stun','tangle','targeted','trap','vampiric'],
        'default':[]
    };
    const base_weapon_enhancements = ['accurate','aura','autofire','blight','contact','contagious','continuing','drain','enervation','flare','flexible','helper','homing','incapacitating','inconspicuous','incurable','indirect','insidious','irritant','linked','multidimensional','muscle','penetrating','piercing','psychic','quake','reach','selective','spreading','stun','tangle','targeted','trap','vampiric'];
    const tsc_ap_enhancements = {
        'absorption':['synergistic'],
        'conversion':['escalate'],
        'force field':['air-tight'],
        'power flux':['debuff'],
        'size change':['modified shrinking'],
        'teleport':['blind'],
        'default':[]
    };
    const enhancement_ranks = {
        'absorption':{'synergistic':{rank:1}},
        'alternate form':{},
        'alternate identity':{},
        'armor':{},
        'attack mastery':{},
        'augmented':{},
        'capacity':{},
        'change state':{'quick change':{rank:1}},
        'cognition':{},
        'combat technique':{},
        'companion':{},
        'connected':{'significant power':{rank:1},'great power':{rank:2}},
        'control environment':{},
        'conversion':{'escalate':{rank:2}},
        'data access':{},
        'defense mastery':{},
        'dimension walk':{},
        'dynamic powers':{'major category':{rank:1},'primal category':{rank:2}},
        'elasticity':{},
        'enemy attack':{},
        'enemy defense':{},
        'energized':{},
        'exorcism':{},
        'expertise':{},
        'extra actions':{},
        'extra defenses':{},
        'extra arms':{},
        'features':{},
        'flight':{},
        'force field':{'air-tight':{rank:1},'blocks incorporeal':{rank:1},'blocks teleport':{rank:1},'field-penetrating':{rank:1},'offensive':{rank:1},'regenerating':{rank:1}},
        'ground speed':{},
        'healing':{},
        'heightened awareness':{},
        'heightened senses':{},
        'illusion':{},
        'immovable':{},
        'immunity':{},
        'immutable':{},
        'inspire':{'galvanize':{rank:2}},
        'jumping':{},
        'massive damage':{},
        'melee attack':{},
        'melee defense':{},
        'merge':{},
        'metamorphosis':{'multiform':{rank:1},'any form':{rank:2}},
        'mimic':{'all powers':{rank:2}},
        'mind control':{},
        'mind shield':{},
        'mini object':{},
        'minions':{},
        'mulligan':{},
        'nullify':{'multiple attributes':{rank:2}},
        'plant control':{},
        'pocket dimension':{},
        'portal':{},
        'power flux':{'debuff':{rank:1},'major category':{rank:1},'primal category':{rank:2}},
        'power variation':{},
        'projection':{'few projections':{rank:1},'several projections':{rank:2}},
        'ranged attack':{},
        'ranged defense':{},
        'regeneration':{},
        'reincarnation':{'difficult to stop':{rank:1}},
        'resilient':{'complete':{rank:1}},
        'sensory block':{},
        'sixth sense':{},
        'size change':{'both ways':{rank:1},'modified shrinking':{rank:1}},
        'skill group':{},
        'social mastery':{},
        'spaceflight':{},
        'special movement':{},
        'summon creatures':{'supernatural':{rank:1},'dimensional':{rank:2}},
        'super sense':{},
        'super speed':{},
        'superstrength':{},
        'swarm':{},
        'taunt':{},
        'telekinesis':{},
        'telepathy':{},
        'teleport':{'blind':{rank:1}},
        'tough':{},
        'transfer':{'all attributes':{rank:2}},
        'transmute':{'resize':{rank:1},'gaseous':{rank:2},'material category':{rank:2}},
        'tunneling':{},
        'unaffected':{'all weapons':{rank:1},'several attributes':{rank:1},'many attributes':{rank:2},'all attributes':{rank:3}},
        'unassailable':{},
        'undetectable':{},
        'unique attribute':{},
        'unknown power':{},
        'water speed':{},
        'wealth':{},
        'weapon':{},
    };
    const base_limiters = ['activation','assisted','backlash','charges','concentration','consumable','delay','dependent','deplete','detectable','emotional','environmental','equipment','imbue','irreversible','localized','maximum','object','permanent','recovery','semi-permanent','unpredictable'];
    const tsc_ap_base_limiters = ['acceleration','haywire','ignore','timed'];
    const base_custom_limiters = {
        'armor':['emphasized','gap','optimized'],
        'flight':['glide','maintain','skim','spread'],
        'force field':['both directions','internal'],
        'ground speed':['road-bound'],
        'massive damage':['focussed damage','targeted damage'],
        'mind control':['broad category','narrow category','specific category','single category'],
        'regeneration':['conditional'],
        'summon creatures':['narrow category','specific category','single category'],
        'telekinesis':['focussed'],
        'telepathy':['broad category','narrow category','specific category','single category'],
        'transfer':['specific attribute'],
        'transmute':['broad category'],
        'undetectable':['nonadjacent'],
        'weapon':['alt-munition','ammo','backblast','exclusive','fieldless','hands','inaccurate','ingest','non-penetrating','stoppable','toxic','unreliable'],
        'default':[]
    };
    const tsc_custom_limiters = {
        'absorption':['capped'],
        'armor':['gap'],
        'force field':['impacting'],
        'plant control':['group','species'],
        'power flux':['skill flux'],
        'transmute':['material category'],
        'default':[]
    };
    const ap_custom_limiters = {
        'absorption':['capped'],
        'armor':['gap'],
        'force field':['impacting'],
        'merge':['proportional damage'],
        'plant control':['group','species'],
        'power flux':['skill flux'],
        'transmute':['material category'],
        'default':[]
    };
    const besmx_custom_limiters = {
        'absorption':['capped'],
        'armor':['gap'],
        'force field':['impacting'],
        'merge':['proportional damage'],
        'plant control':['group','species'],
        'power flux':['skill flux'],
        'default':[]
    };
    const customization_ranks = {
        'absorption':{'capped':{rank:1},'synergistic':{rank:1}},
        'alternate form':{},
        'alternate identity':{},
        'armor':{'disperse':{rank:1},'emphasized':{rank:1},'gap':{rank:1},'optimized':{rank:2}},
        'attack mastery':{},
        'augmented':{},
        'capacity':{},
        'change state':{'quick change':{rank:1}},
        'cognition':{},
        'combat technique':{},
        'companion':{},
        'connected':{'great power':{rank:2},'significant power':{rank:1}},
        'control environment':{},
        'conversion':{'escalate':{rank:2}},
        'data access':{},
        'defense mastery':{},
        'dimension walk':{},
        'dynamic powers':{'major category':{rank:1},'primal category':{rank:2}},
        'elasticity':{},
        'enemy attack':{},
        'enemy defense':{},
        'energized':{},
        'exorcism':{},
        'expertise':{},
        'extra actions':{},
        'extra defenses':{},
        'extra arms':{},
        'features':{},
        'flight':{'glide':{rank:1},'maintain':{rank:1},'skim':{rank:1},'spread':{rank:1}},
        'force field':{'air-tight':{rank:1},'blocks incorporeal':{rank:1},'blocks teleport':{rank:1},'field-penetrating':{rank:1},'offensive':{rank:1},'regenerating':{rank:1},'both directions':{rank:1},'specific':{rank:1},'impacting':{rank:1},'internal':{rank:1}},
        'ground speed':{'road-bound':{rank:1}},
        'healing':{},
        'heightened awareness':{},
        'heightened senses':{},
        'illusion':{},
        'immovable':{},
        'immunity':{},
        'immutable':{},
        'inspire':{'galvanize':{rank:2}},
        'jumping':{},
        'massive damage':{'focussed damage':{rank:1},'targeted damage':{rank:1}},
        'melee attack':{},
        'melee defense':{},
        'merge':{'proportional damage':{rank:1}},
        'metamorphosis':{'any form':{rank:2},'multiform':{rank:1}},
        'mimic':{'all powers':{rank:2}},
        'mind control':{'broad category':{rank:1},'narrow category':{rank:2},'single category':{rank:4},'specific category':{rank:3}},
        'mind shield':{},
        'mini object':{},
        'minions':{},
        'mulligan':{},
        'nullify':{'multiple attributes':{rank:2}},
        'plant control':{'group':{rank:1},'species':{rank:2}},
        'pocket dimension':{},
        'portal':{},
        'power flux':{'debuff':{rank:1},'major category':{rank:1},'primal category':{rank:2},'skill flux':{rank:1}},
        'power variation':{},
        'projection':{'few projections':{rank:1},'several projections':{rank:2}},
        'ranged attack':{},
        'ranged defense':{},
        'regeneration':{'conditional':{rank:1}},
        'reincarnation':{'difficult to stop':{rank:1}},
        'resilient':{'complete':{rank:1}},
        'sensory block':{},
        'sixth sense':{},
        'size change':{'both ways':{rank:1},'modified shrinking':{rank:1}},
        'skill group':{},
        'social mastery':{},
        'spaceflight':{},
        'special movement':{},
        'summon creatures':{'dimensional':{rank:2},'supernatural':{rank:1}},
        'super sense':{},
        'super speed':{},
        'superstrength':{},
        'swarm':{},
        'taunt':{},
        'telekinesis':{'focussed':{rank:1}},
        'telepathy':{'broad category':{rank:1},'narrow category':{rank:2},'single category':{rank:4},'specific category':{rank:3}},
        'teleport':{'blind':{rank:1}},
        'tough':{},
        'transfer':{'all attributes':{rank:2},'specific attribute':{rank:2}},
        'transmute':{'resize':{rank:1},'broad category':{rank:1},'gaseous':{rank:2},'material category':{rank:2}},
        'tunneling':{},
        'unaffected':{'all attributes':{rank:3},'all weapons':{rank:1},'many attributes':{rank:2},'several attributes':{rank:1}},
        'unassailable':{},
        'undetectable':{'nonadjacent':{rank:1}},
        'unique attribute':{},
        'unknown power':{},
        'water speed':{},
        'wealth':{},
        'weapon':{'alt-munition':{rank:1},'anemic':{rank:1},'aura':{rank:1},'autofire':{rank:3},'demoralize':{rank:1},'fieldless':{rank:1},'hands':{rank:1},'helper':{rank:1},'inconspicuous':{rank:3},'indirect':{rank:1},'ingest':{rank:1},'insidious':{rank:3},'linked':{rank:1},'multidimensional':{rank:1},'muscle':{rank:1},'non-penetrating':{},'psychic':{rank:4},'reach':{rank:1},'selective':{rank:1},'stun':{rank:1},'trap':{rank:1}}
    };
    const limiter_ranks = {
        'absorption':{'capped':{rank:1}},
        'alternate form':{},
        'alternate identity':{},
        'armor':{'disperse':{rank:1},'emphasized':{rank:1},'gap':{rank:1},'optimized':{rank:2}},
        'attack mastery':{},
        'augmented':{},
        'capacity':{},
        'change state':{},
        'cognition':{},
        'combat technique':{},
        'companion':{},
        'connected':{},
        'control environment':{},
        'conversion':{},
        'data access':{},
        'defense mastery':{},
        'dimension walk':{},
        'dynamic powers':{},
        'elasticity':{},
        'enemy attack':{},
        'enemy defense':{},
        'energized':{},
        'exorcism':{},
        'expertise':{},
        'extra actions':{},
        'extra defenses':{},
        'extra arms':{},
        'features':{},
        'flight':{'glide':{rank:1},'maintain':{rank:1},'skim':{rank:1},'spread':{rank:1}},
        'force field':{'both directions':{rank:1},'specific':{rank:1},'impacting':{rank:1},'internal':{rank:1}},
        'ground speed':{'road-bound':{rank:1}},
        'healing':{},
        'heightened awareness':{},
        'heightened senses':{},
        'illusion':{},
        'immovable':{},
        'immunity':{},
        'immutable':{},
        'inspire':{},
        'jumping':{},
        'massive damage':{'focussed damage':{rank:1},'targeted damage':{rank:1}},
        'melee attack':{},
        'melee defense':{},
        'merge':{'proportional damage':{rank:1}},
        'metamorphosis':{},
        'mimic':{},
        'mind control':{'broad category':{rank:1},'narrow category':{rank:2},'specific category':{rank:3},'single category':{rank:4}},
        'mind shield':{},
        'mini object':{},
        'minions':{},
        'mulligan':{},
        'nullify':{},
        'plant control':{'group':{rank:1},'species':{rank:2}},
        'pocket dimension':{},
        'portal':{},
        'power flux':{'skill flux':{rank:1}},
        'power variation':{},
        'projection':{},
        'ranged attack':{},
        'ranged defense':{},
        'regeneration':{'conditional':{rank:1}},
        'reincarnation':{},
        'resilient':{},
        'sensory block':{},
        'sixth sense':{},
        'size change':{},
        'skill group':{},
        'social mastery':{},
        'spaceflight':{},
        'special movement':{},
        'summon creatures':{'narrow category':{rank:1},'specific category':{rank:2},'single category':{rank:3}},
        'super sense':{},
        'super speed':{},
        'superstrength':{},
        'swarm':{},
        'taunt':{},
        'telekinesis':{'focussed':{rank:1}},
        'telepathy':{'broad category':{rank:1},'narrow category':{rank:2},'specific category':{rank:3},'single category':{rank:4}},
        'teleport':{},
        'tough':{},
        'transfer':{'specific attribute':{rank:2}},
        'transmute':{'broad category':{rank:1},'material category':{rank:2}},
        'tunneling':{},
        'unaffected':{},
        'unassailable':{},
        'undetectable':{'nonadjacent':{rank:1}},
        'unique attribute':{},
        'unknown power':{},
        'water speed':{},
        'wealth':{},
        'weapon':{'alt-munition':{rank:0},'fieldless':{rank:1},'hands':{rank:1},'ingest':{rank:1}}
    };
    const base_defects = ['achilles heel','awkward size','bane','blind fury','conditional ownership','confined','cursed','easily distracted','fragile','hounded','impaired manipulation','impaired speech','inept attack','inept defense','involuntary change','ism','magnet','marked','nemesis','nightmares','obligated','phobia','physical impairment','red tape','reduced damage','sensory impairment','shortcoming','significant other','skeleton in the closet','social fault','special requirement','unappealing','vulnerability','wanted','weak point'];
    const all_attributes_stats = {
        'absorption':'body',
        'alternate form':'body',
        'alternate identity':'body',
        'change state':'body',
        'cognition':'mind',
        'connected':'soul',
        'control environment':'soul',
        'conversion':'body',
        'data access':'mind',
        'dimension walk':'soul',
        'dynamic powers':'variable',
        'elasticity':'body',
        'exorcism':'soul',
        'extra defenses':'mind',
        'features':'variable',
        'flight':'body',
        'force field':'body',
        'ground speed':'body',
        'healing':'soul',
        'heightened awareness':'variable',
        'heightened senses':'variable',
        'illusion':'variable',
        'immovable':'body',
        'immunity':'body',
        'immutable':'variable',
        'inspire':'soul',
        'jumping':'body',
        'metamorphosis':'variable',
        'mimic':'mind',
        'mind control':'mind',
        'mind shield':'mind',
        'minions':'soul',
        'mulligan':'soul',
        'nullify':'variable',
        'plant control':'mind',
        'portal':'soul',
        'power flux':'variable',
        'power variation':'variable',
        'projection':'mind',
        'regeneration':'body',
        'reincarnation':'soul',
        'resilient':'body',
        'sensory block':'mind',
        'sixth sense':'soul',
        'size change':'body',
        'skill group':'variable',
        'spaceflight':'body',
        'special movement':'body',
        'summon creatures':'mind',
        'super sense':'mind',
        'super speed':'body',
        'superstrength':'body',
        'swarm':'mind',
        'telekinesis':'mind',
        'telepathy':'mind',
        'teleport':'mind',
        'transfer':'soul',
        'transmute':'variable',
        'tunneling':'body',
        'unaffected':'body',
        'undetectable':'body',
        'unique attribute':'variable',
        'water speed':'body',
        'default':'none'
    };
    const attribute_costs = {
        'absorption':5,
        'alternate form':4,
        'alternate identity':1,
        'armor':2,
        'attack mastery':1,
        'augmented':2,
        'capacity':1,
        'change state':3,
        'cognition':2,
        'combat technique':1,
        'companion':4,
        'connected':1,
        'control environment':1,
        'conversion':3,
        'data access':2,
        'defense mastery':1,
        'dimension walk':5,
        'dynamic powers':10,
        'elasticity':1,
        'enemy attack':1,
        'enemy defense':1,
        'energized':1,
        'exorcism':1,
        'expertise':1,
        'extra actions':4,
        'extra defenses':2,
        'extra arms':1,
        'features':1,
        'flight':3,
        'force field':4,
        'gear':1,
        'ground speed':1,
        'healing':1,
        'heightened awareness':1,
        'heightened senses':1,
        'illusion':1,
        'immovable':1,
        'immunity':3,
        'immutable':1,
        'inspire':1,
        'jumping':1,
        'massive damage':3,
        'melee attack':1,
        'melee defense':1,
        'merge':4,
        'metamorphosis':2,
        'mimic':2,
        'mind control':5,
        'mind shiled':1,
        'mini object':2,
        'minions':2,
        'mulligan':1,
        'nullify':5,
        'plant control':1,
        'pocket dimension':1,
        'portal':2,
        'power flux':10,
        'power variation':4,
        'projection':3,
        'ranged attack':1,
        'ranged defense':1,
        'regeneration':5,
        'reincarnation':2,
        'resilient':2,
        'sensory block':1,
        'sixth sense':1,
        'size change':10,
        'skill group':0,
        'skills':1,
        'social mastery':1,
        'spaceflight':1,
        'special movement':1,
        'summon creatures':2,
        'supersense':1,
        'superspeed':3,
        'superstrength':4,
        'swarm':2,
        'taunt':1,
        'telekinesis':4,
        'telepathy':3,
        'teleport':3,
        'tough':1,
        'transfer':3,
        'transmute':3,
        'tunneling':1,
        'unaffected':2,
        'unassailable':1,
        'undetectable':2,
        'unique attribute':0,
        'unknown power':0,
        'water speed':1,
        'wealth':3,
        'weapon':2
    };
    const skill_group_costs = {
        'background': 1,
        'field': 2,
        'action': 3
    };
    const defect_costs = {
        'achilles heel':2,
        'awkward size':2,
        'bane':2,
        'blind fury':2,
        'conditional ownership':1,
        'confined':3,
        'cursed':2,
        'demure':1,
        'easily distracted':1,
        'fragile':1,
        'hounded':2,
        'impaired manipulation':3,
        'impaired speech':3,
        'inept attack':1,
        'inept defense':1,
        'involuntary change':1,
        'ism':2,
        'magnet':1,
        'marked':1,
        'nemesis':1,
        'nightmares':1,
        'no healing':2,
        'obligated':2,
        'phobia':1,
        'physical impairment':3,
        'red tape':1,
        'reduced damage':3,
        'sensory impairment':3,
        'shortcoming':1,
        'significant other':1,
        'skeleton in the closet':2,
        'social fault':1,
        'special requirement':3,
        'unappealing':1,
        'unique defect':0,
        'unsettled':1,
        'vulnerability':2,
        'wanted':2,
        'weak point':2
    };
    const sources_4e = ['high-technology','magic','non-humans','psionics'];
    const sources_3e = ['divine','magical','mutation','natural','psionics','social','skilled','supernatural','technological'];
    const damage_types = ['acid','blunt','cold','disease','electric','heat','penetrating','psychosomatic','radiation','toxin'];
    const melee_types = ['exotic','hafted','hilted','polearm','unarmed'];
    const ranged_types = ['archery','artillery','hand gun','heavy weapon','long gun','special','thrown weapon','weaponry'];
    const senses = ['hearing','sight','smell','taste','touch'];
    const supersenses = ['echolocation','infrared vision','magnetic field detection','microscopic vision','radar','sonar','ultravision','vibration detection','x-ray vision'];
    const nested_enhancements = {
        'connected':['significant power','great power'],
        'dynamic powers':['major category','primal category'],
        'metamorphosis':['multiform','any form'],
        'power flux':['major category','primal category'],
        'projection':['few projections','several projections'],
        'summon creature':['supernatural','dimensional'],
        'unaffected':['several attributes','many attributes','all attributes'],
    };
    const nested_limiters = {
        'armor':['emphasized','gap','optimized'],
        'mind control':['broad category','narrow category','specific category','single category'],
        'plant control':['group','species'],
        'summon creature':['narrow category','specific category','single category'],
        'telepathy':['broad category','narrow category','specific category','single category'],
        'transmute':['broad category','material category'],
        
    };
    const shortcomings = [
        {
            aspect:'body',
            stat:'body',
            type:'all'
        },
        {
            aspect:'agility',
            stat:'body',
            type:'major'
        },
        {
            aspect:'endurance',
            stat:'body',
            type:'major'
        },
        {
            aspect:'strength',
            stat:'body',
            type:'major'
        },
        {
            aspect:'immune system',
            stat:'body',
            type:'minor'
        },
        {
            aspect:'manual dexterity',
            stat:'body',
            type:'minor'
        },
        {
            aspect:'running speed',
            stat:'body',
            type:'minor'
        },
        {
            aspect:'mind',
            stat:'mind',
            type:'all'
        },
        {
            aspect:'creativity',
            stat:'mind',
            type:'major'
        },
        {
            aspect:'perception',
            stat:'mind',
            type:'major'
        },
        {
            aspect:'reason',
            stat:'mind',
            type:'major'
        },
        {
            aspect:'common sense',
            stat:'mind',
            type:'minor'
        },
        {
            aspect:'intuition',
            stat:'mind',
            type:'minor'
        },
        {
            aspect:'memory',
            stat:'mind',
            type:'minor'
        },
        {
            aspect:'soul',
            stat:'soul',
            type:'all'
        },
        {
            aspect:'charisma',
            stat:'soul',
            type:'major'
        },{
            aspect:'luck',
            stat:'soul',
            type:'major'
        },{
            aspect:'willpower',
            stat:'soul',
            type:'major'
        },
        {
            aspect:'composure',
            stat:'soul',
            type:'minor'
        },{
            aspect:'empathy',
            stat:'soul',
            type:'minor'
        },{
            aspect:'self-discipline',
            stat:'soul',
            type:'minor'
        },
    ];
    const new_group_template = {
        attribute_ids: [],
        configuration: [],
        defect_ids: [],
        elevel: 0,
        enhancements: [],
        group_id: 0,
        group_points: 0,
        group_type: 'standard',
        item: 'no',
        level: 0,
        limiters: [],
        locked: false,
        name: 'Default Group',
        pool_name: '',
        pool_points: 0,
        points: 0,
        removed: false,
        source: 'high-technology',
        stat: 'none',
        totalpoints: 0,
    };
    const roll_macro_template = {
        attribute: {
            id: '',
            name: '',
        },
        enemy: {
            id: '',
            name: '',
        },
        id: '',
        maneuver: '',
        modifier: '',
        name: '',
        stat: '',
        target: '',
        type: '',
    };

    /* Custom Prototypes */
    String.prototype.toSnakeCase = function() {
        return this.replace(new RegExp(/\s+/g), '_');
    };

    Array.prototype.toSnakeCase = function() {
        const snaked = this.map(t => {
            const s = (typeof t === 'string' || t instanceof String) ? 
                t.replace(new RegExp(/\s+/g), '_') : t;
            return s;
        });
        return snaked;
    };

    String.prototype.toKebobCase = function() {
        return this.replace(new RegExp(/\s+/g), '-');
    };

    Array.prototype.toKebobCase = function() {
        const kebobed = this.map(t => {
            const s = (typeof t === 'string' || t instanceof String) ? 
                t.replace(new RegExp(/\s+/g), '-') : t;
            return s;
        });
        return kebobed;
    };

    String.prototype.capitalize = function() {
        const temp = {
            hyphens: /-/g.test(this),
            whitespace: /\s|_/g.test(this),
        };
        const dont_capitalize = /^a$|^an$|^and$|^as$|^at$|^but$|^by$|^for$|^in$|^nor$|^of$|^on$|^or$|^the$|^up$|^with$/g;
        temp.str = temp.whitespace ? this.split(/\s|_/g) : [`${this}`];
        for (let i = 0; i < temp.str.length; i++) {
            temp.str[i] = dont_capitalize.test(temp.str[i]) && (
                i !== 0 || i !== temp.str.length
            ) ? temp.str[i][0] + temp.str[i].substring(1) : 
                temp.str[i][0].toUpperCase() + temp.str[i].substring(1);
        }
        temp.str = temp.whitespace ? temp.str.join(" ") : temp.str[0];
        if (temp.hyphens) {
            temp.str = temp.hyphens ? temp.str.split("-") : [`${temp.str}`];
            for (let i = 0; i < temp.str.length; i++) {
                temp.str[i] = temp.str[i][0].toUpperCase() + temp.str[i].substring(1);
            }
            temp.str = temp.hyphens ? temp.str.join("-") : temp.str[0];
        }
        return temp.str;
    }

    Array.prototype.capitalize = function() {
        const result = this.map(r => {
            const temp = {
                hyphens: /-/g.test(r),
                whitespace: /\s/g.test(r),
            };
            const dont_capitalize = /^a$|^an$|^and$|^as$|^at$|^but$|^by$|^for$|^in$|^nor$|^of$|^on$|^or$|^the$|^up$|^with$/g;
            temp.str = temp.whitespace ? r.split(" ") : [`${r}`];
            for (let i = 0; i < temp.str.length; i++) {
                temp.str[i] = dont_capitalize.test(temp.str[i]) && (
                    i !== 0 || i !== temp.str.length
                ) ? temp.str[i][0] + temp.str[i].substring(1) : 
                    temp.str[i][0].toUpperCase() + temp.str[i].substring(1);
            }
            temp.str = temp.whitespace ? temp.str.join(" ") : temp.str[0];
            if (temp.hyphens) {
                temp.str = temp.hyphens ? temp.str.split("-") : [`${temp.str}`];
                for (let i = 0; i < temp.str.length; i++) {
                    temp.str[i] = temp.str[i][0].toUpperCase() + temp.str[i].substring(1);
                }
                temp.str = temp.hyphens ? temp.str.join("-") : temp.str[0];
            }
            return temp.str;
        });
        return result;
    }

    String.prototype.removeWhiteSpace = function() {
        if (this === undefined) {
            return false;
        } else {
            return this.replace(/\s+/g, '');
        }
    }

    String.prototype.fromSnakeCase = function() {
        return this.replace(/(?:_| |\b)(\w)/g, function($1){return $1.replace('_',' ');});
    }

    /* Async Functions by OnyxRing and Scott C */
    function isRunningOnServer(){ return self.dispatchEvent==undefined; }
    function setActiveCharacterId(charId){
        var oldAcid=getActiveCharacterId();
        var msg={"id":"0", "type":"setActiveCharacter", "data":charId};
        
        if(isRunningOnServer()==false){ //if in a browser, use "dispatchEvent" to process the message
            var ev = new CustomEvent("message");
            ev.data=msg; 
            self.dispatchEvent(ev);
        }else{ //otherwise, use the API (server) message processor, "onmessage"
            self.onmessage({data:msg});
        }
        return oldAcid; //return what the value used to be, so calling code can be a little cleaner 
    } 
    var _sIn=setInterval;
    setInterval=function(callback, timeout){
        var acid=getActiveCharacterId();
        _sIn(
            function(){
                var prevAcid=setActiveCharacterId(acid);
                callback();
                setActiveCharacterId(prevAcid);
            }
        ,timeout);
    }
    var _sto=setTimeout
    setTimeout=function(callback, timeout){
        var acid=getActiveCharacterId();
        _sto(
            function(){
                var prevAcid=setActiveCharacterId(acid);
                callback();
                setActiveCharacterId(prevAcid);
            }
        ,timeout);
    }
    function getAttrsAsync(props){
        var acid=getActiveCharacterId(); //save the current activeCharacterID in case it has changed when the promise runs 
        var prevAcid=null;               //local variable defined here, because it needs to be shared across the promise callbacks defined below
        return new Promise((resolve,reject)=>{
                prevAcid=setActiveCharacterId(acid);  //in case the activeCharacterId has changed, restore it to what we were expecting and save the current value to restore later
                try{
                    getAttrs(props,(values)=>{  resolve(values); }); 
                }
                catch{ reject(); }
        }).finally(()=>{
            setActiveCharacterId(prevAcid); //restore activeCharcterId to what it was when the promise first ran
        });
    }
    //use the same pattern for each of the following...
    function setAttrsAsync(propObj, options){
        var acid=getActiveCharacterId(); 
        var prevAcid=null;               
        return new Promise((resolve,reject)=>{
                prevAcid=setActiveCharacterId(acid);  
                try{
                    setAttrs(propObj,options,(values)=>{ resolve(values); });
                }
                catch{ reject(); }
        }).finally(()=>{
            setActiveCharacterId(prevAcid); 
        });
    }

    function getSectionIDsAsync(sectionName){
        var acid=getActiveCharacterId(); 
        var prevAcid=null;               
        return new Promise((resolve,reject)=>{
                prevAcid=setActiveCharacterId(acid);  
                try{
                    getSectionIDs(sectionName,(values)=>{ resolve(values); });
                }
                catch{ reject(); }
        }).finally(()=>{
            setActiveCharacterId(prevAcid); 
        });
    }
    function getSingleAttrAsync(prop){ 
        var acid=getActiveCharacterId(); 
        var prevAcid=null;               
        return new Promise((resolve,reject)=>{
                prevAcid=setActiveCharacterId(acid);  
                try{
                    getAttrs([prop],(values)=>{  resolve(values[prop]); }); 
                }
                catch{ reject(); }
        }).finally(()=>{
            setActiveCharacterId(prevAcid); 
        });
    }

    const rollEscape = {
        chars: {
            '"': '%quot;',
            ',': '%comma;',
            ':': '%colon;',
            '}': '%rcub;',
            '{': '%lcub;',
        },
        escape(str) {
            str = (typeof(str) === 'object') ? JSON.stringify(str) : (typeof(str) === 'string') ? str : null;
            return (str) ? `${str}`.replace(new RegExp(`[${Object.keys(this.chars)}]`, 'g'), (r) => this.chars[r]) : null;
        },
        unescape(str) {
            str = `${str}`.replace(new RegExp(`(${Object.values(this.chars).join('|')})`, 'g'), (r) => Object.entries(this.chars).find(e=>e[1]===r)[0]);
            return JSON.parse(str);
        }
    }

    /* Utility Functions */
    async function upgradeSheetVersion(cache, set_values) {
        const temp = {};
        temp.sheet_version = parseFloat(cache.static_sheet_settings_version);
        temp.current_version = global_sheet_current_version;
        clog(cache, temp, `upgradeSheetVersion()`);
        while (temp.sheet_version < temp.current_version) {
            //switch (temp.sheet_version) {
            if (temp.sheet_version <= 0.1) {
                //case 0.1:
                    const get_attr = ['attrdb','defectdb','statsdb'];
                    const get_attrs = await getAttrsAsync(get_attr);
                    cache.attrdb = JSON.parse(get_attrs.attrdb);
                    cache.defectdb = JSON.parse(get_attrs.defectdb);
                    cache.statsdb = JSON.parse(get_attrs.statsdb);
                    const statsdb_template={actions:{base:1,extra:0},acv:{base:0,mastery:0},body:{base:0,damage:0,temp:0,augmented:0},dcv:{base:0,mastery:0},defenses:{base:0,extra:0},dm:{base:5,massive:0},mind:{base:0,damage:0,temp:0,augmented:0},scv:{base:0,mastery:0},shockvalue:{base:0,hardboiled:0},soul:{base:0,damage:0,temp:0,augmented:0},energy:{base:0,damage:0,temp:0,energized:0},health:{base:0,damage:0,stun:0,temp:0,tough:0},sanity:{base:0,damage:0,temp:0,unassailable:0},society:{base:0,damage:0,temp:0,mastery:0},cp:{base:0,gained:0,spent:0,temp:0}};
                    const stats = Object.keys(statsdb_template);
                    const old_key = 'enemy defenses';
                    const new_key = 'enemy defense';
                    //=> Fix error in attrdb for "enemy defense"
                    if (cache.attrdb.hasOwnProperty(old_key)) {
                        cache.attrdb[new_key] = cache.attrdb[old_key];
                        delete cache.attrdb[old_key];
                    }
                    //=> convert old groupdb version to new groupdb version
                    for (let i = 0; i < cache.groupdb.length; i++) {
                        cache.groupdb[i] = copyAttributes(new_group_template, cache.groupdb[i]);
                        cache.groupdb[i].item = 
                            cache.groupdb[i].origin === 'innate' ? 'no' :
                            cache.groupdb[i].origin === 'item' ? 'yes' :
                            cache.groupdb[i].origin === 'gear' ? 'gear' :
                            'shield';
                    }
                    //=> Fix gear attribute costs
                    for (let i = 0; i < cache.groupdb.length; i++) {
                        temp.ids = cache.groupdb[i].attribute_ids;
                        if (cache.groupdb[i].group_type === 'gear') {
                            for (let x = 0; x < all_attributes.length; x++) {
                                for (let j = 0; j < cache.attrdb[all_attributes[x]].length; j++) {
                                    temp.id = cache.attrdb[all_attributes[x]][j].row_id;
                                    for (let y = 0; y < temp.ids.length; y++) {
                                        if (temp.ids[y] === temp.id) {
                                            cache.attrdb[all_attributes[x]][j].points = 0;
                                            set_values[`repeating_attribute_${cache.attrdb[all_attributes[x]][j].row_id.toLowerCase()}_points`] = 0;
                                        }
                                    }
                                }
                            }
                            setGroupCharacterPoints(cache, set_values);
                        }
                    }
                    //=> convert old statsdb to new statsdb version
                    for (let i = 0; i < stats.length; i++) {
                        if (cache.statsdb[stats[i]] === undefined) {
                            cache.statsdb[stats[i]] = {};
                        }
                        cache.statsdb[stats[i]] = copyAttributes(statsdb_template[stats[i]], cache.statsdb[stats[i]]);
                    }
                    //=> ensure character point base is a number
                    if (typeof cache.statsdb.cp.base !== 'number') {
                        cache.statsdb.cp.base = int(cache.statsdb.cp.base);
                    }
                    //=> save databases
                    set_values.attrdb = JSON.stringify(cache.attrdb);
                    set_values.groupdb = JSON.stringify(cache.groupdb);
                    set_values.statsdb = JSON.stringify(cache.statsdb);
                    temp.sheet_version = 0.2;
                //break;
            } else if (temp.sheet_version <= 0.5) {
                //case 0.5:
                    set_values.rolldb = [];
                    temp.sheet_version = 0.6;
                //break;
            } else if (temp.sheet_version <= 0.7) {
                if (cache.attrdb === undefined) {
                    const get_attr = ['attrdb'];
                    const get_attrs = await getAttrsAsync(get_attr);
                    cache.attrdb = JSON.parse(get_attrs.attrdb);
                }
                const get_configs = [];
                for (let i = 0; i < all_attributes.length; i++) {
                    for (let j = 0; j < cache.attrdb[all_attributes[i]].length; j++) {
                        const note_index = cache.attrdb[all_attributes[i]][j].config.indexOf('notes');
                        if (note_index === -1) {
                            const note = {
                                name: 'notes',
                                rank: '',
                            };
                            cache.attrdb[all_attributes[i]][j].config.push(note);
                            get_configs.push(`repeating_attribute_${cache.attrdb[all_attributes[i]][j].row_id}_configuration`);
                        }
                    }   
                }
                const configs = await getAttrsAsync(get_configs);
                const config_values = Object.values(configs);
                for (let i = 0; i < get_configs.length; i++) {
                    set_values[get_configs[i]] = `${config_values[i]}\nNotes ()`;
                }
                set_values.attrdb = JSON.stringify(cache.attrdb);
                temp.sheet_version = 0.8;
            } else {
                //default:
                    temp.sheet_version = temp.current_version;
            }
        }
        cache.static_sheet_settings_version = temp.current_version;
        set_values.static_sheet_settings_version = cache.static_sheet_settings_version;
    }

    function copyAttributes(source, target) {
        for (let key in source) {
            if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
                target[key] = source[key];
            }
        }
        return target;
    }

    function setTimer(cache) {
        cache.timer = {}
        cache.timer.start = Date.now();
        cache.timer.elapsed = 0;
        cache.timer.cache = 0;
    }

    function getTimestamp(cache) {
        const timeNow = Date.now();
        const timeElapsed = timeNow - cache.timer.start;
        cache.timer.cache = timeElapsed - cache.timer.elapsed;
        cache.timer.elapsed = timeElapsed;
    }

    function int(integer, fallback = 0) {
        return parseInt(integer) || fallback;
    }

    function get1or3(level, start) {
        let result = 0;
        if (start === 1) {
            result = (level & 1) ? 1 : 3;
        } else if (start === 3) {
            result = (level & 1) ? 3 : 1;
        }
        return result;
    }
    
    function get1or2andHalfor5(level) {
        const oneTwoAndHalfOrFive = mod =>
            mod === 0 ? 1 :
            mod === 1 ? 2.5 :
            mod === 2 ? 5 :
            0;
        return oneTwoAndHalfOrFive(level % 3);
    }

    function get1or5or25(level) {
        const oneFiveOrTwentyFive = mod =>
            mod === 0 ? 1 :
            mod === 1 ? 5 :
            mod === 2 ? 25 :
            0;
        return oneFiveOrTwentyFive(level % 3);
    }

    function isEven(number) {
        return number % 2 === 0;
    }

    function clog(cache, data, title, type = 'event') {
        //types = 'info', 'event'
        //debug = 0:none, 1:info, 2:event, 3:performance
        const debug = (cache.static_sheet_settings_debug || 'none').toLowerCase();
        const color = 
            type === 'info' ? 'color:#EE82EE' :
            type === 'start' ? 'color:#7CFC00' :
            type === 'end' ? 'color:#D50000' :
            'color:#00FFFF';
        const text = data === '' ? '' :
            _.isString(data) ? 'string:' :
            _.isNumber(data) ? 'number:' :
            _.isArray(data) ? 'array:' : 
            _.isObject(data) ? 'object:' :
            '';
        title = title ? `.[${title}]` : '+';
        title ? console.log(`%c+----.----.----${title}`,color) : false;
        console.log(`%c${text}`,color,data);
        if (debug === 'performance') {
            getTimestamp(cache);
            console.log(
                `%crunTime[${cache.timer.cache}] elapsedTime[${cache.timer.elapsed}]`,
                'color:yellow'
            );
        }
    }

    function isTruthly(value) {
        const is_truthly = 
            value === undefined ? false :
            value === '' ? false :
            int(value) === 0 ? false :
            true;
        return is_truthly;
    }

    function removeWhiteSpace(str){
        if (str === undefined) {
            return false;
        } else {
            return str.replace(/\s+/g, '');
        }
    }

    function isFloat(n) { return !!(n % 1); }

    function arraysAreEqual(arrayA, arrayB) {
        if (arrayA.length !== arrayB.length) { return false; } else {
            return arrayA.sort().join(",") === arrayB.sort().join(",");
        }
    }

    function isObjectEmpty(obj) { 
        for (let x in obj) { return false; }
        return true;
        }

    async function crpQuery(cache, query, tag = '') {
        const rxGrab = /^0\[(.*)\]\s*$/;
        clog(cache, query, `crpQuery(${tag})`);
        query.string = `! {{query=[[0[?{${query.title}${query.options}}] ]] }}`;
        query.crp = await startRoll(query.string);
        finishRoll(query.crp.rollId);
        query.match = query.crp.results.query.expression.match(rxGrab)[1];
        query.selection = 
            isNaN(query.match) ? query.match : 
            isFloat(query.match) ? parseFloat(query.match) : int(query.match);
    }

    async function crpRoll(cache, roll_string) {
        const roll = {};
        clog(cache, roll, `crpRoll()`);
        roll.string = roll_string;
        roll.crp = await startRoll(roll.string);
        finishRoll(roll.crp.rollId,{
            dice0: roll.crp.results.roll.dice[0],
            dice1: roll.crp.results.roll.dice[1],
            total: roll.crp.results.total.result,
        });
    }

    async function crpGet(cache, attributes) {
        // attrubutes can be a string or an object.
        // if a string, then the funtion will return a single value.
        // if an object, then the cache object will contain the fetched values
        // by the keys passed from attributes.
        const get = {};
        clog(cache, get, 'crpGet()');
        const rxGrab = /^0\[(.*)\]\s*$/;
        switch (true) {
            case _.isString(attributes):
                get.string = 
                `! {{get=[[0[@{${cache.static_sheet_settings_gm}|${attributes}}] ]]}}`;
                get.crp = await startRoll(get.string);
                get.value = get.crp.results.get.expression.match(rxGrab)[1];
                finishRoll(get.crp.rollId);
                get.value = isNaN(get.value) ? get.value : int(get.value);
                return get.value;
            break;
            case Array.isArray(attributes):
                get.keys = attributes.map(a => {
                    return `rules_${a}_status`;
                });
                get.string = '!';
                get.length = get.keys.length;
                for (let i = 0; i < get.length; i++) {
                    get.string += ` {{${get.keys[i]}=[[0[@{${cache.static_sheet_settings_gm}|${get.keys[i]}}]]]}}`;
                }
                get.crp = await startRoll(get.string);
                for (let i = 0; i < get.length; i++) {
                    const key = `${get.keys[i]}`;
                    get[key] = get.crp.results[key].expression.match(rxGrab)[1];
                    cache[key] = isNaN(get[key]) ? get[key] : int(get[key]);
                }
                finishRoll(get.crp.rollId);
            break;
            case _.isObject(attributes):
                get.keys = Object.keys(attributes);
                get.values = Object.values(attributes);
                get.length = get.keys.length;
                get.string = '!';
                for (let i = 0; i < get.length; i++) {
                    get.string += ` {{${get.keys[i]}=[[0[@{${cache.static_sheet_settings_gm}|${get.values[i]}}]]]}}`;
                }
                get.crp = await startRoll(get.string);
                for (let i = 0; i < get.length; i++) {
                    const key = `${get.keys[i]}`;
                    get[key] = get.crp.results[key].expression.match(rxGrab)[1];
                    cache[key] = isNaN(get[key]) ? get[key] : int(get[key]);
                }
                finishRoll(get.crp.rollId);
            break;
        }
    }

    function convertUnitMeasurement(cache, query, type) {
        const temp = {};
        clog(cache, temp, 'convertUnitMeasurement()');

        temp.length = n.length;
        if (n > 0) {
            if (temp.length - 1 > 3) {
                temp.measurement = int(n) / (10 ** (temp.length - 1));
                temp.unit = 'km';
            } else {
                temp.measurement = n;
                temp.unit = 'm';
            }
        } else if (n < 0) {
            temp.measurement = parseFloat(n) * (10 ** (temp.length - 2));
            if (temp.length === 4) {
                temp.unit = 'cm';
            } else if (temp.length === 5) {
                temp.unit = 'mm';
            } else {
                temp.unit = 'mcm';
            }
        }

        switch (type) {
            case 'height':
                temp.title_string = 
                    `${getTranslationByKey("enter-height-in")} ${query.template.height.unit} (` +
                    `${query.template.height.min}-${query.template.height.max}` +
                    ` ${query.template.height.unit_abv})`;
            break;
        }
    }

    function setDice (cache, roll, eo = 0) {
        const exceed2dice =
            cache.rulesdb.rules_optional_dice_status === 'exceed' ? true : false;
        const temp = {};
        clog(cache, temp, 'setDice()');
        temp.mod = roll.mod;
        temp.string = '{{total=[[';
        temp.d6 = ' [[1d6]]+[[1d6]]';
        temp.d6_value = ' {{dice0=$[[0]]}} {{dice1=$[[1]]}}';
        temp.eo = eo;
        temp.extra_dice = int((temp.mod.edge || 0) + (temp.mod.obstacle || 0 * -1) + temp.eo);
        temp.ndice = 
            (temp.extra_dice > 1 || temp.extra_dice < -1) ? 
                exceed2dice ? temp.extra_dice + 2 : 4 : 
            (temp.extra_dice === 1 || temp.extra_dice === -1) ? 3 : 2;
        for (let i = 2, n = temp.ndice; i < n; i++) {
            temp.d6 += '+[[1d6]]';
            temp.d6_value += ` {{dice${i}=$[[${i}]]}}`;
        }
        temp.string += `${temp.d6} ]]}} ${temp.d6_value}`;
        roll.dice = {
            number: temp.ndice,
            type: temp.extra_dice < 0 ? 'obstacle' : 
                temp.extra_dice > 0 ? 'edge' : 'normal',
        }
        return temp.string;
    }

    function getDiceIcon(dice_value, light_icon = false) {
        const icon_character = {
            1:'G',
            2:'H',
            3:'I',
            4:'J',
            5:'K',
            6:'L'
        };
        const dice_icon = icon_character[dice_value];
        return !light_icon ? dice_icon : dice_icon.toLowerCase();
    }

    function getRollDifficultyByTN(tn) {
        const difficulty = {
            6:'Simple',
            9:'Easy',
            12:'Average',
            15:'Difficult',
            18:'Challenging',
            21:'Unlikely',
            24:'Doubtful',
            27:'Improbable',
            30:'Inconceivable'
        }
        return difficulty[tn];
    }

    function getArrayPositionByID(cache, array, id) {
        const temp = {};
        clog(cache, temp, 'getArrayPositionByID()');
        temp.index = array.findIndex(a => {
            return a.id.toLowerCase() === id.toLowerCase();
        });
        return temp.index;
    }

    /* Group Show/Hide Functions */
    function showDynamicGroupFields(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'showDynamicGroupFields()');
        temp.group_type = cache.groupdb[cache.static_group_visible_id || 0].group_type;
        temp.remove = temp.group_type === 'standard' ? 'show' : 'hide';
        temp.add = temp.group_type === 'standard' ? 'hide' : 'show';
        $20(`.group-type-visibility`).removeClass(`group-type-visibility-${temp.remove}`);
        $20(`.group-type-visibility`).addClass(`group-type-visibility-${temp.add}`);
        set_values.static_attributes_powervariation_state = temp.group_type === 'power variation' ? 1 : 0;
    }

    function setAttributeGroupVisibility(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'setAttributeGroupVisibility()');
        temp.visible_id = cache.static_group_visible_id;
        for (let i = 0; i < cache.groupdb.length; i++) {
            temp.group_id = cache.groupdb[i].group_id;
            for (let j = 0; j < cache.groupdb[i].attribute_ids.length; j++) {
                const id = cache.groupdb[i].attribute_ids[j].toLowerCase();
                set_values[`repeating_attribute_${id}_visibility`] = 
                    temp.group_id === temp.visible_id ? 1 : 0;
            }
            for (let j = 0; j < cache.groupdb[i].defect_ids.length; j++) {
                const id = cache.groupdb[i].defect_ids[j].toLowerCase();
                set_values[`repeating_defect_${id}_visibility`] = 
                temp.group_id === temp.visible_id ? 1 : 0;
            }
            if (temp.group_id === temp.visible_id) {
                set_values.static_attribute_group_name = cache.groupdb[i].name;
                set_values.static_attribute_group_totalpoints = `${cache.groupdb[i].group_points}`;
                set_values.static_attribute_group_type = cache.groupdb[i].group_type.capitalize();
                set_values.static_attribute_group_item = cache.groupdb[i].item.capitalize();
                set_values.static_attribute_group_source = cache.groupdb[i].source.capitalize();
                if (cache.groupdb[i].group_type !== 'standard') {
                    switch (cache.groupdb[i].group_type) {
                        case 'power flux':
                            setPowerFluxPoolPoints(cache, set_values);
                            set_values.static_attribute_group_poolname = getTranslationByKey("power-flux");
                        break;
                        case 'power variation':
                            setPowerVariationPoolPoints(cache, set_values);
                            set_values.static_attribute_group_poolname = getTranslationByKey("power-variation");
                        break;
                        case 'dynamic powers':
                            setDynamicPowersPoolLevels(cache, set_values);
                            set_values.static_attribute_group_poolname = getTranslationByKey("dynamic-powers");
                        break;
                        case 'gear':
                            setGearPoolLevels(cache, set_values);
                            set_values.static_attribute_group_poolname = getTranslationByKey("gear");
                        break;
                    }
                    set_values.static_attribute_group_level = `${cache.groupdb[i].level || 0} (${cache.groupdb[i].elevel || 0})`;
                    set_values.static_attribute_group_stat = `${cache.groupdb[i].stat.capitalize() || 'None'}`;
                    set_values.static_attribute_group_points = cache.groupdb[i].points || 0;
                    set_values.static_attribute_group_configuration = cache.groupdb[i].description || '';
                    set_values.static_attribute_group_enhancements = 
                        customizationsToString(cache, cache.groupdb[i].enhancements) || '';
                    set_values.static_attribute_group_limiters =
                        customizationsToString(cache, cache.groupdb[i].limiters) || '';
                    set_values.static_attribute_group_cost = attribute_costs[cache.groupdb[i].group_type];
                }
            }
        }
    }

    function setSkillUiVisibility(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'setSkillUiVisibility()');
        temp.visible_id = int(cache.static_skills_visible_id);
        for (let i = 0; i < cache.attrdb.skills.length; i++) {
            const skills = cache.attrdb.skills[i].individual;
            for (let j = 0; j < skills.length; j++) {
                set_values[`repeating_skill_${skills[j].row_id.toLowerCase()}_visibility`] = 
                    i === temp.visible_id ? 1 : 0;
            }
            if (i === temp.visible_id) {
                set_values.static_skills_attribute_name = cache.attrdb.skills[i].name;
                set_values.static_skills_points_total = cache.attrdb.skills[i].elevel * 10;
                set_values.static_skills_points_remaining = 
                    set_values.static_skills_points_total
                    - cache.attrdb.skills[i].individual.reduce((a, b) => a + b.points, 0) || 0;
            }
        }
    }

    function setPowerFluxPoolPoints(cache, set_values) {
        if (cache.is_sheetopened) { return; }
        const temp = {};
        clog(cache, temp,'setPowerFluxPoolPoints()');
        temp.flux_points_used = 0;
        temp.group_ids = cache.groupdb[cache.static_group_visible_id].attribute_ids;
        temp.debug = '';
        for (let i = 0; i < all_attributes.length; i++) {
            temp.debug += all_attributes[i];
            const attributes = cache.attrdb[all_attributes[i]];
            for (let j = 0; j < attributes.length; j++) {
                if (temp.group_ids.includes(attributes[j].row_id) && attributes[j].active) {
                    temp.flux_points_used += attributes[j].points;
                    break;
                }
            }
        }
        temp.flux_points_available = cache.groupdb[cache.static_group_visible_id].elevel * 5;
        set_values.static_attribute_group_poolpoints = 
            `${temp.flux_points_used} / ${temp.flux_points_available}`;
        set_values.static_attribute_group_totalpoints = 
            cache.groupdb[cache.static_group_visible_id].level * attribute_costs['power flux'];
    }

    function setDynamicPowersPoolLevels(cache, set_values) {
        if (cache.is_sheetopened) { return; }
        const temp = {};
        clog(cache, temp,'setDynamicPowersPoolLevels()');
        temp.dynamic_levels_used = 0;
        temp.group_ids = cache.groupdb[cache.static_group_visible_id].attribute_ids;
        for (let i = 0; i < all_attributes.length; i++) {
            const attributes = cache.attrdb[all_attributes[i]];
            for (let j = 0; j < attributes.length; j++) {
                if (temp.group_ids.includes(attributes[j].row_id) && attributes[j].active) {
                    temp.dynamic_levels_used += attributes[j].level;
                    break;
                }
            }
        }
        temp.dynamic_levels_available = cache.groupdb[cache.static_group_visible_id].pool_points;
        set_values.static_attribute_group_poolpoints = 
            `${temp.dynamic_levels_used} / ${temp.dynamic_levels_available}`;
    }

    function setGearPoolLevels(cache, set_values) {
        if (cache.is_sheetopened) { return; }
        const gear_by_level = {
            0:0,
            1:2,
            2:5
        };
        const temp = {};
        clog(cache, temp,'setGearPoolLevels()');
        temp.db = cache.groupdb[cache.static_group_visible_id];
        temp.gear_levels_used = temp.db.attribute_ids.length;
        temp.gear_max = temp.db.elevel < 3 ? 
            gear_by_level[temp.db.elevel] : 
            get1or2andHalfor5(temp.db.elevel) * (10 ** (Math.floor(temp.db.elevel / 3)));
        set_values.static_attribute_group_poolpoints = `${temp.gear_levels_used} / ${temp.gear_max}`;
        cache.groupdb[cache.static_group_visible_id].pool_points = temp.gear_max;
    }

    function setNonStandardGroupPoints(cache, set_values) {
        if (cache.is_sheetopened) { return; }
        const temp = {};
        clog(cache, temp,'setNonStandardGroupPoints()');
        temp.totalpoints = 
            cache.groupdb[cache.static_group_visible_id].elevel * attribute_costs[cache.groupdb[cache.static_group_visible_id].group_type];
        for (let i = 0; i < all_attributes.length; i++) {
            const attributes = cache.attrdb[all_attributes[i]];
            temp.totalpoints += attributes.map(a => a.points).reduce((a, b) => a + b, 0);
        }
        cache.groupdb[cache.static_group_visible_id].totalpoints = temp.totalpoints;
        set_values.static_attribute_group_totalpoints = temp.totalpoints;
    }

    function setPowerVariationPoolPoints(cache, set_values) {
        if (cache.is_sheetopened) { return; }
        const temp = {};
        clog(cache, temp,'setPowerVariationPoolPoints()');
        temp.variation_points_used = 0;
        temp.variation_points_max = 0;
        for (let i = 0; i < all_attributes.length; i++) {
            const attributes = cache.attrdb[all_attributes[i]];
            for (let j = 0; j < attributes.length; j++) {
                if (attributes[j].group_id === cache.static_group_visible_id) {
                    const point_index = attributes[j].config.findIndex(c => c.name === 'base points');
                    temp.variation_points_max += point_index !== -1 ? attributes[j].config[point_index].rank : 0;
                    temp.variation_points_used += attributes[j].active ? attributes[j].points : 0;
                }
            }
        }
        set_values.static_attribute_group_poolpoints = 
            `${temp.variation_points_used} / ${temp.variation_points_max}`;
    }

    function setPowerVariationGroupPoints(cache, set_values) {
        if (
            cache.is_sheetopened || 
            cache.groupdb[cache.static_group_visible_id].locked
        ) { return; }
        const temp = {};
        clog(cache, temp,'setPowerVariationGroupPoints()');
        temp.totalpoints = 
            cache.groupdb[cache.static_group_visible_id].elevel * attribute_costs['power variation'];
        for (let i = 0; i < all_attributes.length; i++) {
            const attributes = cache.attrdb[all_attributes[i]];
            for (let j = 0; j < attributes.length; j++) {
                if (attributes[j].group_id === cache.static_group_visible_id) {
                    const point_index = attributes[j].config.findIndex(c => c.name === 'base points');
                    temp.totalpoints += point_index !== -1 ? attributes[j].config[point_index].rank : 0;
                }
            }
        }
        cache.groupdb[cache.static_group_visible_id].totalpoints = temp.totalpoints;
        set_values.static_attribute_group_totalpoints = temp.totalpoints;
    }

    /* Theme Functions */
    function initializeTheme(values) {
        const theme = {};
        clog(values, theme, 'initializeTheme()', 'event');
        theme.current = values.static_sheet_settings_theme.toLowerCase().removeWhiteSpace() || 'tristatcore';
        theme.components = [
            'background','border','button','minor','input','input-major','major','slider','title'
        ];
        theme.scheme = {
            0: 'tristatcore',
            1: 'belalugosi',
            2: 'darkforest',
            3: 'galaxyexpress',
            4: 'highcontrast',
            5: 'imperial',
            6: 'lavender',
            7: 'oceans',
            8: 'pomegranate',
            9: 'sandstone',
            10: 'stormtrooper',
            11: 'valleyofthewind',
            12: 'besm',
            13: 'absolutepower'
        };
        _.each(theme.components, component => {
            theme.selector = `theme-${component}`;
            $20(`.${theme.selector}`)
            .addClass(`${theme.selector}-${theme.current}`);
        });
    }

    function setTheme(cache) {
        const theme = {};
        clog(cache, theme, 'setTheme()', 'event');
        theme.new = cache.newValue.toLowerCase().removeWhiteSpace();
        theme.previous = cache.previousValue === undefined ? 'tristatcore' :
            cache.previousValue.toLowerCase().removeWhiteSpace();
        theme.components = [
            'background','border','button','minor','input','input-major','major','slider','title'
        ];
        _.each(theme.components, component => {
            theme.selector = `theme-${component}`;
            $20(`.${theme.selector}`)
            .removeClass(`${theme.selector}-${theme.previous}`);
            $20(`.${theme.selector}`)
            .addClass(`${theme.selector}-${theme.new}`);
        });
    }

    async function setSheetLogo(cache) {
        const temp = {};
        clog(cache, temp, 'setSheetLogo()');
        temp.logos = ['tristatcore','besm','absolutepower'];
        temp.logo = cache.static_sheet_settings_type.toLowerCase() === 'gm' ? 
            cache.static_rules_base_default : 
            cache.static_sheet_settings_gm === '' ?
            'besm' : await crpGet(cache, 'static_rules_base_default');
        temp.logo = temp.logo === 'besmx' ? 'besm' : temp.logo;
        temp.logo = temp.logo.indexOf('undefined') !== -1 ?
            'besm' : temp.logo;
            temp.logos.splice(temp.logos.indexOf(temp.logo.removeWhiteSpace()),1);
        for (let i = 0, n = temp.logos.length; i < n; i++) {
            $20(`.grid-minor-screen-logo`)
            .removeClass(`${temp.logos[i]}-logo`);
        }
        $20(`.grid-minor-screen-logo`)
        .addClass(`${temp.logo}-logo`);
    }

    async function changeSheetLogo(cache) {
        const temp = {};
        clog(cache, temp, 'changeSheetLogo()');
        temp.logos = ['tristatcore','besm','absolutepower'];
        temp.logo = cache.newValue || 'besm';
        temp.logo = temp.logo === 'besmx' ? 'besm' : temp.logo;
        for (let i = 0, n = temp.logos.length; i < n; i++) {
            $20(`.grid-minor-screen-logo`)
            .removeClass(`${temp.logos[i]}-logo`);
        }
        $20(`.grid-minor-screen-logo`)
        .addClass(`${temp.logo}-logo`);
        cache.rulebook = cache.newValue || 'tristatcore';
    }

    async function setBaseRules(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'setBaseRules()');
        cache.rulebook = cache.rulebook === undefined ? 'besm' : cache.rulebook;
        temp.rules = all_optional_rules.concat(all_normalizations, all_homebrew_rules);
        for (let i = 0; i < temp.rules.length; i++) {
            temp.ap_knockback = cache.rulebook === 'absolutepower' && 
                temp.rules[i] === 'optional_knockback';
            temp.not_besm_or_besmx = cache.rulebook.indexOf('besm') === -1 && (
                temp.rules[i] === 'enhancement_cognition' ||
                temp.rules[i] === 'attribute_deathdodge' ||
                temp.rules[i] === 'attribute_debilitate' ||
                temp.rules[i] === 'enhancement_powerflux' ||
                temp.rules[i] === 'attribute_expertise' ||
                temp.rules[i] === 'attribute_flankdefense' ||
                temp.rules[i] === 'limiter_transmute' ||
                temp.rules[i] === 'attribute_miniobject' ||
                temp.rules[i] === 'enhancement_sizechange' ||
                temp.rules[i] === 'limiter_powerflux' ||
                temp.rules[i] === 'enhancement_sixthsense' ||
                temp.rules[i] === 'attribute_speedburst' ||
                temp.rules[i] === 'attribute_summoncreature' ||
                temp.rules[i] === 'attribute_taunt' || 
                temp.rules[i] === 'limiter_timed' || 
                temp.rules[i] === 'enhancement_transfer' || 
                temp.rules[i] === 'enhancement_weapon'
            );
            temp.not_besm = cache.rulebook !== 'besm' && (
                temp.rules[i] === 'enhancement_absorption' ||
                temp.rules[i] === 'limiter_absorption' ||
                temp.rules[i] === 'enhancement_conversion' ||
                temp.rules[i] === 'enhancement_forcefield' ||
                temp.rules[i] === 'defect_nohealing' ||
                temp.rules[i] === 'attribute_plantcontrol' ||
                temp.rules[i] === 'optional_shield' ||
                temp.rules[i] === 'limiter_powerflux' ||
                temp.rules[i] === 'enhancement_absorption' ||
                temp.rules[i] === 'enhancement_teleport'
            );
            temp.besmx_extradefenses = cache.rulebook === 'besmx' && (
                temp.rules[i] === 'attribute_extradefenses'
            );
            temp.besmx_or_ap_merge = (
                cache.rulebook === 'besmx' ||
                cache.rulebook === 'absolutepower'
                ) && temp.rules[i] === 'limiter_merge';
            temp.besm_and_besmx_tournament = 
                cache.rulebook.indexOf('besm') !== -1 && (
                temp.rules[i] === 'attribute_tournament'
            );
            const status = 
                temp.ap_knockback ||
                temp.not_besm_or_besmx ||
                temp.not_besm ||
                temp.besmx_extradefenses ||
                temp.besmx_or_ap_merge ||
                temp.besm_and_besmx_tournament ? 1 : 0;
            set_values[`rules_${temp.rules[i]}_status`] = status;
            cache.rulesdb[`rules_${temp.rules[i]}_status`] = status;
            set_values[`rules_${temp.rules[i]}_icon`] = 
                temp.ap_knockback ||
                temp.not_besm_or_besmx ||
                temp.not_besm ||
                temp.besmx_extradefenses ||
                temp.besmx_or_ap_merge ||
                temp.besm_and_besmx_tournament ? '3' : '_';
        }
        set_values.rulesdb = JSON.stringify(cache.rulesdb);
    }

    /* Status Bar Related Functions */
    function initializeStatusBars(cache, status_sections) {
        const temp = {};
        clog(cache, temp, 'initializeStatusBars()');
        for (let i = 0; i < status_sections.length; i++) {
            temp.selector = `status-bar-${status_sections[i]}`;
            temp.remaining = 
                int(cache[`static_character_${status_sections[i]}_remaining`]);
            temp.base = 
                int(cache[`static_character_${status_sections[i]}_base`]);
            temp.damage = temp.base - temp.remaining;
            temp.status_math = Math.floor((temp.damage*10)/temp.base);
            temp.status = temp.status_math > 10 ? 10 : temp.status_math;
            $20(`.${temp.selector}`)
            .addClass(`status-bar-${temp.status}`);
        }
    }

    function updateStatusBar(cache, section, status) {
        const temp = {};
        clog(cache, temp, 'updateStatusBar()');
        temp.selector = `status-bar-${section}`;
        for (let i = 1; i < 11; i++) {
            $20(`.${temp.selector}`)
            .removeClass(`status-bar-${i}`);
        }
        $20(`.${temp.selector}`)
        .addClass(`status-bar-${status}`);
    }

    function getStatusDescription(cache, section, status) {
        const description = {
            'energy': {
                10: 'Exhausted',
                9: 'Winded',
                8: 'Winded',
                7: 'Winded',
                6: 'Weary',
                5: 'Weary',
                4: 'Weary',
                3: 'Active',
                2: 'Active',
                1: 'Active',
                0: 'Rested'
            },
            'health': {
                10: 'Mortally Wounded',
                9: 'Critically Wounded',
                8: 'Critically Wounded',
                7: 'Critically Wounded',
                6: 'Seriously Wounded',
                5: 'Seriously Wounded',
                4: 'Seriously Wounded',
                3: 'Lightly Wounded',
                2: 'Lightly Wounded',
                1: 'Lightly Wounded',
                0: 'Healthy'
            },
            'sanity': {
                10: 'Insane',
                9: 'Pathological',
                8: 'Pathological',
                7: 'Pathological',
                6: 'Unstable',
                5: 'Unstable',
                4: 'Unstable',
                3: 'Unwell',
                2: 'Unwell',
                1: 'Unwell',
                0: 'Well'
            },
            'society': {
                10: 'Spiraling',
                9: 'Insecure',
                8: 'Insecure',
                7: 'Insecure',
                6: 'Unsure',
                5: 'Unsure',
                4: 'Unsure',
                3: 'Shaken',
                2: 'Shaken',
                1: 'Shaken',
                0: 'Confident'
            },
        };
        clog(cache, description[section][status], 'getStatusDescription()');
        return description[section][status];
    }

    /* Start-up and Sheet Setup Functions */
    // >>> Update cache with truthly values instead. 
    // >>> Account for fasley values in the code evaluating.
    function updateCache(cache) {
        clog(cache, cache, 'updateCache()', 'event');
        if (cache.newValue !== undefined) {
            cache[cache.sourceAttribute] = cache.newValue
        }
    }

    function doEventTasks(cache, event_info) {
        clog(cache, event_info, 'Event Listener', 'start');
        // If attr removed then flag removed attribute, else update cache
        cache.removed = event_info.triggerName.indexOf('remove') !== -1;
        if (cache.removed) {
            event_info.sourceAttribute = `${event_info.sourceAttribute}_removed`;
        } else if (event_info.newValue !== undefined) {
            cache[event_info.sourceAttribute] = event_info.newValue;
        }
        // Assign sourceAttribute value if is button
        if (event_info.sourceAttribute === undefined) {
            event_info.sourceAttribute = 
            event_info.triggerName.substring(8, event_info.triggerName.length);
        }
        // >>>investigate if this is needed or can retool
        // Assign sourceAttribute value if is button in a repeating section
        event_info.previousValue = 
            event_info.previousValue === event_info.newValue ? 
            Number.isInteger(int(event_info.newValue)) ? 0 :
            typeof event_info.newValue === 'string' || 
            event_info.newValue instanceof String ? '' :
            undefined : event_info.previousValue;

        event_info.newValue = isNaN(event_info.newValue) ?
            event_info.newValue : int(event_info.newValue);
        event_info.previousValue = isNaN(event_info.previousValue) ?
            event_info.previousValue : int(event_info.previousValue);
    }

    function createDatabase(cache, array) {
        const temp = {};
        clog(cache, temp, 'createDatabase()');
        _.chain(array)
            .each(element => { temp[`${element}`] = []; })
            .value();
        return temp;
    }

    function getSourceAttributes(cache, sourceAttribute) {
        const source_attributes = sourceAttribute.split('_');
        cache.originalCaseRowID = source_attributes[2];
        cache.source = sourceAttribute.toLowerCase();
        cache.source_path = `${source_attributes[0]}_${source_attributes[1]}_${source_attributes[2].toLowerCase()}`;
        cache.source_type = source_attributes[0];
        cache.source_section = source_attributes[1];
        cache.source_id = source_attributes[2].toLowerCase();
        cache.source_attribute = source_attributes[3];
    }

    function getAttrKeys(cache, event_info) {
        const temp = ['static_sheet_settings_debug','static_sheet_settings_gm'];
        clog(cache, temp, 'getAttrKeys()');
        switch (cache.source_type) {
            case 'repeating':
                switch (cache.source_section) {
                    case 'attribute':
                    case 'defect':
                        switch (cache.source_attribute) {
                            case 'accordion':
                                temp.push(`${cache.source_path}_state`);
                            break;
                            case 'active':
                                temp.push(
                                    'attrdb',
                                    'defectdb',
                                    `${cache.source_path}_${cache.source_section}`,
                                    'groupdb',
                                    'static_group_visible_id',
                                    'statsdb'
                                );
                            break;
                            case 'attribute':
                            case 'configuration':
                            case 'defect':
                            case 'enhancements':
                            case 'level':
                            case 'limiters':
                            case 'stat':
                            case 'rank':
                                temp.push(
                                    'attrdb',
                                    'defectdb',
                                    'groupdb',
                                    'rulesdb',
                                    'static_group_visible_id',
                                    'static_skills_visible_id',
                                    'statsdb'
                                );
                            break;
                        }
                    break;
                    case 'roll':
                        switch (cache.source_attribute) {
                            case 'accordion':
                                temp.push(`${cache.source_path}_state`);
                            break;
                            case 'attribute':
                            case 'enemy':
                            case 'maneuver':
                            case 'modifier':
                            case 'stat':
                                temp.push('attrdb','rolldb','rulesdb');
                            break;
                            case 'name':
                            case 'target':
                            case 'type':
                                temp.push('rolldb','rulesdb');
                            break;
                            case 'rollmacro':
                                temp.push(
                                    'attrdb',
                                    'character_name',
                                    'conditiondb',
                                    'defectdb',
                                    'rolldb',
                                    'rulesdb',
                                    'static_character_details_pronoun',
                                    'statsdb',
                                );
                            break;
                        }
                    break;
                    case 'skill':
                        switch (cache.source_attribute) {
                            case 'accordion':
                                temp.push(`${cache.source_path}_state`);
                            break;
                            case 'active':
                                temp.push(
                                    'attrdb',
                                    `${cache.source_path}_${cache.source_section}`,
                                    'static_skills_visible_id'
                                );
                            break;
                            case 'rank':
                            case 'specializations':
                            case 'stat':
                                temp.push(
                                    'attrdb',
                                    'rulesdb',
                                    'static_skills_visible_id'
                                );
                            break;
                        }
                    break;
                    case 'condition':
                        temp.push(
                            'conditiondb',
                            `repeating_condition_${cache.source_id}_name`
                        );
                    break;
                }
            break;
            case 'react':
                temp.push(
                    'attrdb',
                    'character_name',
                    'defectdb',
                    'groupdb',
                    'rulesdb',
                    'statsdb',
                    'static_character_details_pronoun'
                );
            break;
            case 'static':
                switch (cache.source_id) {
                    case 'accordion':
                    case 'accordions':
                        temp.push(`${cache.source_path}_state`);
                    break;
                    case 'body':
                    case 'mind':
                    case 'soul':
                        temp.push(
                            'attrdb',
                            'defectdb',
                            'groupdb',
                            'rulesdb',
                            'statsdb'
                            );
                    break;
                    case 'add':
                    case 'delete':
                    case 'details':
                    case 'edit':
                    case 'page':
                    case 'title':
                        switch (cache.source_section) {
                            case 'character':
                            case 'screen':
                                temp.push(
                                    'character_name',
                                    'defectdb',
                                    'groupdb',
                                    'static_character_details_size',
                                    'statsdb',
                                    `${event_info.sourceAttribute}`
                                );
                            break;
                            case 'roll':
                                temp.push('rolldb','rulesdb');
                            break;
                            case 'skills':
                                temp.push(
                                    'attrdb',
                                    'defectdb',
                                    'rulesdb',
                                    'statsdb',
                                    'static_skills_visible_id'
                                );
                            break;
                            case 'stats':
                                temp.push(
                                    'attrdb',
                                    'defectdb',
                                    'groupdb',
                                    'rulesdb',
                                    'statsdb'
                                );
                            break;
                            case 'status':
                                temp.push(
                                    'attrdb',
                                    'conditiondb',
                                    'defectdb',
                                    'rulesdb',
                                    'statsdb'
                                );
                            break;
                            case 'attributes':
                                temp.push(
                                    'attrdb',
                                    'defectdb',
                                    'groupdb',
                                    'rulesdb',
                                    'static_group_visible_id',
                                    'statsdb'
                                );
                            break;
                            case 'journal':
                                temp.push(
                                    'journaldb',
                                    'static_journal_page_entry',
                                    'static_journal_page_number',
                                    'static_journal_visible_id'
                                );
                            break;
                        }
                    break;
                    case 'energy':
                    case 'health':
                    case 'sanity':
                    case 'society':
                        temp.push(
                            'statsdb',
                        );
                    break;
                    case 'group':
                        temp.push(
                            'attrdb',
                            'defectdb',
                            'groupdb',
                            'rulesdb',
                            'static_group_visible_id',
                            'statsdb'
                        );
                    break;
                    case 'lock':
                        temp.push(
                            'attrdb',
                            'groupdb',
                            'static_group_visible_id',
                        );
                    break;
                    case 'save':
                    case 'select':
                        switch (cache.source_section) {
                            case 'journal':
                                temp.push(
                                    'journaldb',
                                    'static_journal_page_entry',
                                    'static_journal_page_number',
                                    'static_journal_visible_id'
                                );
                            break;
                        }
                    break;
                    case 'settings':
                        temp.push('character_name');
                        switch (cache.source_attribute) {
                            case 'theme':
                                temp.push('static_sheet_settings_theme');
                            break;
                        }
                    break;
                    case 'groupselect':
                    case 'grouptoggle':
                        temp.push(
                            'attrdb',
                            'defectdb',
                            'groupdb',
                            'static_group_visible_id',
                            'static_attribute_group_configuration'
                        );
                    break;
                    case 'points':
                        temp.push(
                            'groupdb',
                            'statsdb'
                        );
                    break;
                    case '2d6':
                    case 'attack':
                    case 'attribute':
                    case 'initiative':
                    case 'skill':
                    case 'stat':
                    case 'rolls':
                        temp.push(
                            'attrdb',
                            'character_name',
                            'defectdb',
                            'groupdb',
                            'rulesdb',
                            'static_character_details_pronoun',
                            'statsdb'
                        );
                    break;
                    case 'uiselect':
                    case 'uitoggle':
                        temp.push(
                            'attrdb',
                            'static_skills_visible_id'
                        )
                    break;
                    case 'update':
                        temp.push(
                            'attrdb',
                            'conditiondb',
                            'rulesdb'
                        );
                    break;
                }
                switch (cache.source_section) {
                    case 'rules':
                        temp.push(
                            'rulesdb',
                            `${cache.source_path}_status`,
                            'static_rules_base_default'
                        );
                        if (cache.source_id === 'debilitate') {
                            temp.push('rules_optional_criticalhits_status');
                        }
                    break;
                }
            break;
            case 'rules':
                temp.push(
                    'rulesdb',
                    `${cache.source_path}_status`,
                    'static_rules_base_default'
                );
                if (cache.source_id === 'debilitate') {
                    temp.push('rules_optional_criticalhits_status');
                }
            break;
        }
        return temp;
    }

    async function cacheSectionIDs(cache, section) {
        cache[`${section}_ids`] = [];
        cache[`${section}_ids`] = await getSectionIDsAsync(section);
        clog(cache, cache[`${section}_ids`], `getSectionIDs(${section})`);
    }

    function updateSheetRulesSummary(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'updateSheetRulesSummary()');
        if (cache.rulesdb === undefined) { return; }
        const descriptions = {
            attribute:[
                {
                    name:'deathdodge',
                    display:['death dodge']
                },
                {
                    name:'eknockback',
                    display:['enhanced knockback']
                },
                {
                    name:'extradefenses',
                    display:['extra defenses']
                },
                {
                    name:'flankdefense',
                    display:['flank defense']
                },
                {
                    name:'hardboiled',
                    display:['hard boiled']
                },
                {
                    name:'miniobject',
                    display:['mini object']
                },
                {
                    name:'speedburst',
                    display:['speed burst']
                },
            ],
            defect:[
                {
                    name:'nohealing',
                    display:['no healing']
                },
            ],
            enhancement:[
                {
                    name:'absorption',
                    display:['absorption','synergistic']
                },
                {
                    name:'cognition',
                    display:['cognition','area']
                },
                {
                    name:'conversion',
                    display:['conversion','escalate']
                },
                {
                    name:'forcefield',
                    display:['forcefield','air-tight']
                },
                {
                    name:'powerflux',
                    display:['power flux','debuff']
                },
                {
                    name:'sixthsense',
                    display:['sixth sense','range']
                },
                {
                    name:'sizechange',
                    display:['size change','modified shrinking']
                },
                {
                    name:'summoncreatures',
                    display:['summon creatures','area']
                },
                {
                    name:'teleport',
                    display:['teleport','blind']
                },
                {
                    name:'transfer',
                    display:['transfer','area, targets']
                },
                {
                    name:'weapon',
                    display:['weapon','anemic, demoralize, lethargy']
                },
            ],
            homebrew:[
                {
                    name:'ammotracking',
                    display:['ammo tracking']
                },
                {
                    name:'depletereserve',
                    display:['easy deplete']
                },
                {
                    name:'disperse',
                    display:['armor','disperse']
                },
                {
                    name:'specificlimiter',
                    display:['forcefield','specific']
                },
            ],
            limiter:[
                {
                    name:'absorption',
                    display:['absorption','capped']
                },
                {
                    name:'merge',
                    display:['proportional','damage']
                },
                {
                    name:'plantcontrol',
                    display:['plant control','group, species']
                },
                {
                    name:'powerflux',
                    display:['power flux','skill flux']
                },
                {
                    name:'merge',
                    display:['merge','proportional damage']
                },
                {
                    name:'transmute',
                    display:['transmute','material category']
                },
            ],
            optional:[
                {
                    name:'criticalfailures',
                    display:['critical failures']
                },
                {
                    name:'criticalhits',
                    display:['critical hits']
                },
                {
                    name:'enhancedrecovery',
                    display:['enhanced recovery']
                },
                {
                    name:'extradamage',
                    display:['extra damage']
                },
                {
                    name:'individual',
                    display:['individual skills']
                },
                {
                    name:'knockback',
                    display:['knock back']
                },
                {
                    name:'knockout',
                    display:['knock out']
                },
                {
                    name:'mos',
                    display:['margin of success']
                },
                {
                    name:'movementpenalties',
                    display:['movement penalties']
                },
                {
                    name:'rangepenalties',
                    display:['range penalties']
                },
                {
                    name:'seriousinjury',
                    display:['serious injury']
                },
                {
                    name:'shield',
                    display:['striking a sheild']
                },
                { 
                    name:'shockvalue',
                    display:['shock value']
                },
                {
                    name:'spreadinitiative',
                    display:['spread initiative']
                },
                {
                    name:'variable',
                    display:['variable damage']
                },
            ],
            rule_values:[
                {
                    name:'mos-dm',
                    display:['damage modifier adjusted by margin of success']
                },
                {
                    name:'attackroll-dm',
                    display:['damage modifier adjusted by attack roll']
                },
                {
                    name:'damageroll-dm',
                    display:['damage modifier adjusted by additional damage roll']
                },
                {
                    name:'mos-td',
                    display:['total damage adjusted by margin of success']
                },
                {
                    name:'attackroll-td',
                    display:['total damage adjusted by attack roll']
                },
                {
                    name:'damageroll-td',
                    display:['total damage adjusted by additional damage roll']
                },
                {
                    name:'mos',
                    display:['margin of success']
                },
                {
                    name:'natural12',
                    display:['natural 12']
                },
                {
                    name:'natural2',
                    display:['natural 2']
                },
                {
                    name:'exceed',
                    display:['exceed two dice']
                },
            ],
            genre:{
                0:"multi-genre",
                1:"action adventure",
                2:"animal adventures",
                3:"classic horror",
                4:"detective",
                5:"loony cartoons",
                6:"romantic comedy",
                7:"slice of life",
                8:"spy thriller",
                9:"supernatural occult",
                10:"eco fantasy",
                11:"high fantasy",
                12:"low fantasy",
                13:"urban fantasy",
                14:"cyberpunk/realitypunk",
                15:"hard sf",
                16:"mecha drama",
                17:"post-apocalyptic",
                18:"soft sf",
                19:"space opera",
                20:"20th century war",
                21:"age of discovery",
                22:"age of pirates",
                23:"age of samurai",
                24:"ancient mediterranean",
                25:"industrial age",
                26:"middle ages",
                27:"steampunk",
                28:"stone age",
                29:"wild west",
            }
        };
        temp.normalize = ['attribute','defect','enhancement','homebrew','limiter','optional'];
        temp.attribute = '';
        temp.defect = '';
        temp.enhancement = '';
        temp.homebrew = '';
        temp.limiter = '';
        temp.optional = '';
        temp.display = 'Rulebook: ';
        temp.display +=
            cache.rulebook === 'tristatcore' ? 'Tri-Stat Core' :
            cache.rulebook === 'besmx' ? 'BESM Extras' :
            cache.rulebook === 'absolutepower' ? 'Absolute Power' :
            'BESM';
        temp.display += '\n\n';
        temp.rule_keys = Object.keys(cache.rulesdb);
        temp.rule_values = Object.values(cache.rulesdb);
        for (let i = 0; i < temp.rule_values.length; i++) {
            if (
                (isNaN(temp.rule_values[i]) || temp.rule_values[i]) &&
                temp.rule_keys[i] !== 'rules_optional_genre_status'
            ) {
                const key = temp.rule_keys[i].split("_");
                const rule_index = descriptions[key[1]].findIndex(r => {
                    return r.name === key[2];
                });
                const rule_value_index = isNaN(temp.rule_values[i]) ?
                    descriptions.rule_values.findIndex(r => {
                        return r.name === temp.rule_values[i];
                    }) : -1;
                temp.enabled_rule = rule_index !== -1 ?
                    descriptions[key[1]][rule_index].display.length === 1 &&
                    descriptions[key[1]][rule_index].name !== "individual" ?
                        descriptions[key[1]][rule_index].display[0].capitalize() :
                        `${descriptions[key[1]][rule_index].display[0].capitalize()} ` +
                        `(${
                            descriptions[key[1]][rule_index].name === "individual" ?
                                descriptions.genre[cache.rulesdb.rules_optional_genre_status].capitalize() :
                                descriptions[key[1]][rule_index].display[1].capitalize()
                        })`
                    : key[2].capitalize();
                temp.enabled_rule_value = rule_value_index !== -1 ?
                    descriptions.rule_values[rule_value_index].display[0].capitalize() :
                    temp.rule_values[i];
                temp[key[1]] += `  ${temp.enabled_rule}`;
                temp[key[1]] += isNaN(temp.rule_values[i]) ?
                    `: ${temp.enabled_rule_value}` : '';
                temp[key[1]] += '\n';
            }
        }
        for (let i = 0; i < temp.normalize.length; i++) {
            if (temp[temp.normalize[i]].length !== 0) {
                temp.display += 
                    temp.normalize[i] === 'attribute' ||
                    temp.normalize[i] === 'defect' ||
                    temp.normalize[i] === 'enhancement' ||
                    temp.normalize[i] === 'limiter' ? 
                        `Normalized ${temp.normalize[i].capitalize()}s\n` :
                    temp.normalize[i] === 'homebrew' || 
                    temp.normalize[i] === 'optional' ? 
                        `${temp.normalize[i].capitalize()} Rules\n` : '';
                temp.display += `${temp[temp.normalize[i]]}\n`;
            }
        }
        set_values.static_sheet_settings_rules = temp.display;
    }

    /* Character Point Related Functions */
    function setCharacterPointsRemaining(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'setCharacterPointsRemaining()');
        temp.group_points = cache.groupdb.map(g => g.removed ? 0 : g.group_points || 0).reduce((a, b) => a + b, 0);
        const stats = ['body','mind','soul'];
        temp.stat_points = (stats.map(s => cache.statsdb[s].base).reduce((a, b) => a + b, 0)) * 2;
        temp.character_points_spent = temp.stat_points + temp.group_points;
        cache.statsdb.cp.spent = temp.character_points_spent;
        set_values.static_character_points_spent = cache.statsdb.cp.spent;
        set_values.static_character_points_remaining = 
            cache.statsdb.cp.base
            + cache.statsdb.cp.gained
            + cache.statsdb.cp.temp
            - cache.statsdb.cp.spent;
    }
    

    function getSpentCharacterPoints(cache) {
        const temp = {};
        clog(cache, temp, 'getSpentCharacterPoints()');
        temp.group_points = cache.groupdb.map(g => g.removed ? 0 : g.group_points).reduce((a, b) => a + b, 0);
        const stats = ['body','mind','soul'];
        temp.stat_points = stats.map(s => cache.statsdb[s].base).reduce((a, b) => a + b, 0);
        return (temp.stat_points * 2) + temp.group_points;
    }

    /* Attribute Related Fuctions */
    async function setActiveAttribute(cache, set_values) {
        const temp = {};
        temp.active_attributes = [
            'attack mastery',
            'combat technique',
            'defense mastery',
            'demure',
            'energized',
            'extra actions',
            'extra defenses',
            'fragile',
            'hardboiled',
            'inept attack',
            'inept defense',
            'massive damage',
            'reduced damage',
            'social mastery',
            'tough',
            'unassailable',
            'unsettled',
        ];
        clog(cache, temp, `setActiveAttribute()`);
        // Calculate Base Value
        for (let i = 0; i < temp.active_attributes.length; i++) {
            // Apply values
            switch(temp.active_attributes[i]) {
                case 'attack mastery':
                    cache.attrdb[temp.active_attributes[i]].forEach(a => {
                        if (a.active) {
                            cache.acv += a.elevel;
                        }
                    });
                break;
                case 'combat technique':
                    cache.attrdb[temp.active_attributes[i]].forEach(a => {
                        for (let i = 0; i < a.config.length; i++) {
                            switch (a.config[i].name) {
                                case 'hardboiled':
                                    temp.active_attributes.unshift('hardboiled');
                                    if (a.active) {
                                        cache.hardboiled += (a.config[i].rank * 10);
                                    }
                                break;
                            }
                        }
                    });
                    cache.hardboiled = Math.min(cache.hardboiled, cache.shockvalue / 2);
                    cache.shockvalue += cache.hardboiled;
                break;
                case 'defense mastery':
                    cache.attrdb[temp.active_attributes[i]].forEach(a => {
                        if (a.active) {
                            cache.dcv += a.elevel;
                        }
                    });
                break;
                case 'demure':
                    cache.defectdb[temp.active_attributes[i]].forEach(a => {
                        if (a.active) {
                            cache.scv = Math.max(0, cache.scv -= (a.level * 2));
                        }
                    });
                break;
                case 'energized':
                    cache.attrdb[temp.active_attributes[i]].forEach(a => {
                        if (a.active) {
                            cache.energy += (a.elevel * 10);
                        }
                    });
                break;
                case 'extra actions':
                    cache.attrdb[temp.active_attributes[i]].forEach(a => {
                        if (a.active) {
                            cache.actions += a.elevel;
                        }
                    });
                break;
                case 'extra defenses':
                    cache.attrdb[temp.active_attributes[i]].forEach(a => {
                        if (a.active) {
                            cache.defenses += a.elevel;
                        }
                    });
                break;
                case 'fragile':
                    cache.defectdb[temp.active_attributes[i]].forEach(a => {
                        if (a.active) {
                            cache.health = Math.max(0, cache.health -= (a.level * 10));
                        }
                    });
                break;
                case 'inept attack':
                case 'inept defense':
                    cache.defectdb[temp.active_attributes[i]].forEach(a => {
                        const attack_type_index = a.config.findIndex(c => c.name === 'attack_type');
                        if (a.active && a.config[attack_type_index].rank === 'any') {
                            const cv = `${temp.active_attributes[i] === 'inept attack' ? "acv" : "dcv"}`;
                            cache[cv] = Math.max(0, cache[cv] -= a.level);
                        }
                    });
                break;
                case 'massive damage':
                    cache.attrdb[temp.active_attributes[i]].forEach(a => {
                        if (a.active) {
                            const limited = a.limiters.find(l => {
                                return l.name === 'focussed damage' || l.name === 'targeted damage';
                            });
                            if (limited === undefined) { cache.dm += a.elevel; }
                        }
                    });
                break;
                case 'reduced damage':
                    cache.defectdb[temp.active_attributes[i]].forEach(a => {
                        if (a.active) {
                            cache.dm = Math.max(0, cache.dm -= a.level);
                        }
                    });
                break;
                case 'social mastery':
                    cache.attrdb[temp.active_attributes[i]].forEach(a => {
                        if (a.active) {
                            cache.scv += (a.elevel * 2);
                        }
                    });
                break;
                case 'tough':
                    cache.attrdb[temp.active_attributes[i]].forEach(a => {
                        if (a.active) {
                            cache.health += (a.elevel * 10);
                        }
                    });
                break;
                case 'unassailable':
                    cache.attrdb[temp.active_attributes[i]].forEach(a => {
                        if (a.active) {
                            cache.sanity += (a.elevel * 2);
                        }
                    });
                break;
                case 'unsettled':
                    cache.defectdb[temp.active_attributes[i]].forEach(a => {
                        if (a.active) {
                            cache.sanity -= Math.max(0 ,(a.level * 2));
                        }
                    });
                break;
            }
            if (
                temp.active_attributes[i] === 'massive damage' ||
                temp.active_attributes[i] === 'reduced damage'
            ) {
                cache.statsdb.dm.base = cache.dm;
                set_values.static_character_dm_base = cache.statsdb.dm.base;
            }
        }
    }

    function getSizeTemplate(cache) {
        const size = {};
        clog(cache, size, 'getSizeTemplate()');
        size.name = cache.static_character_details_size.toLowerCase();
        const templates = [
            {name:'point',rank:-10,height:{min:['100','4'],max:['400','16'],unit:['micrometers','thousands of an inch'],unit_abv:['m','thou']},mass:{min:['1','0.007'],max:['40','0.3'],unit:['micrograms','doite'],unit_abv:['g','doite']},lift:0.0000002,dm:-100,ar:100,ranged:20,speed:0.001},
            {name:'mote',rank:-9,height:{min:['500','20'],max:['900','35'],unit:['micrometers','thousands of an inch'],unit_abv:['m','thou']},mass:{min:['50','0.4'],max:['500','3.7'],unit:['micrograms','doite'],unit_abv:['g','doite']},lift:0.000001,dm:-90,ar:90,ranged:18,speed:0.002},
            {name:'speck',rank:-8,height:{min:['1','40'],max:['4','160'],unit:['millimeters','thousands of an inch'],unit_abv:['mm','thou']},mass:{min:['1','0.3'],max:['5','1.5'],unit:['milligrams','mite'],unit_abv:['mg','mite']},lift:0.000004,dm:-80,ar:80,ranged:16,speed:0.004},
            {name:'minute',rank:-7,height:{min:['5','200'],max:['9','350'],unit:['millimeters','thousands of an inch'],unit_abv:['mm','thou']},mass:{min:['6','2'],max:['40','12.3'],unit:['milligrams','mite'],unit_abv:['mg','mite']},lift:0.00002,dm:-70,ar:70,ranged:14,speed:0.008},
            {name:'wee',rank:-6,height:{min:['1','0.5'],max:['2','1'],unit:['centimeters','inches'],unit_abv:['cm','in']},mass:{min:['50','15.5'],max:['500','155'],unit:['milligrams','mite'],unit_abv:['mg','mite']},lift:0.0001,dm:-60,ar:60,ranged:12,speed:0.01667},
            {name:'teeny',rank:-5,height:{min:['3','1.1'],max:['4','1.5'],unit:['centimeters','inches'],unit_abv:['cm','in']},mass:{min:['1','0.5'],max:['5','3'],unit:['grams','dram'],unit_abv:['g','dr']},lift:0.0004,dm:-50,ar:50,ranged:10,speed:0.0333},
            {name:'fine',rank:-4,height:{min:['5','2'],max:['9','3.5'],unit:['centimeters','inches'],unit_abv:['cm','in']},mass:{min:['6','3.5'],max:['30','17'],unit:['grams','dram'],unit_abv:['g','dr']},lift:0.002,dm:-40,ar:40,ranged:8,speed:0.06667},
            {name:'diminutive',rank:-3,height:{min:['10','4'],max:['24','9'],unit:['centimeters','inches'],unit_abv:['cm','in']},mass:{min:['50','28'],max:['300','170'],unit:['grams','dram'],unit_abv:['g','dr']},lift:0.01,dm:-30,ar:30,ranged:6,speed:0.125},
            {name:'tiny',rank:-2,height:{min:['25','10'],max:['49','19'],unit:['centimeters','inches'],unit_abv:['cm','in']},mass:{min:['0.5','1'],max:['2','4'],unit:['kilograms','pounds'],unit_abv:['kg','lb']},lift:0.04,dm:-20,ar:20,ranged:4,speed:0.25},
            {name:'small',rank:-1,height:{min:['50','20'],max:['99','38'],unit:['centimeters','inches'],unit_abv:['cm','in']},mass:{min:['6','13'],max:['20','44'],unit:['kilograms','pounds'],unit_abv:['kg','lb']},lift:0.2,dm:-10,ar:10,ranged:2,speed:0.5},
            {name:'medium',rank:0,height:{min:['1','39'],max:['2','79'],unit:['meters','inches'],unit_abv:['m','in']},mass:{min:['50','110'],max:['150','330'],unit:['kilograms','pounds'],unit_abv:['kg','lb']},lift:0,dm:0,ar:0,ranged:0,speed:0},
            {name:'large',rank:1,height:{min:['3','118'],max:['4','157'],unit:['meters','inches'],unit_abv:['m','in']},mass:{min:['200','440'],max:['1200','2650'],unit:['kilograms','pounds'],unit_abv:['kg','lb']},lift:5,dm:10,ar:10,ranged:-2,speed:2},
            {name:'huge',rank:2,height:{min:['5','197'],max:['8','315'],unit:['meters','inches'],unit_abv:['m','in']},mass:{min:['1.5','1.5'],max:['8','8'],unit:['tonnes','tons'],unit_abv:['t','lt']},lift:25,dm:20,ar:20,ranged:-4,speed:4},
            {name:'mammoth',rank:3,height:{min:['9','345'],max:['15','591'],unit:['meters','inches'],unit_abv:['m','in']},mass:{min:['10','10'],max:['60','60'],unit:['tonnes','tons'],unit_abv:['t','lt']},lift:100,dm:30,ar:30,ranged:-6,speed:8},
            {name:'gigantic',rank:4,height:{min:['16','17'],max:['30','34'],unit:['meters','yards'],unit_abv:['m','yd']},mass:{min:['75','75'],max:['500','500'],unit:['tonnes','tons'],unit_abv:['t','lt']},lift:500,dm:40,ar:40,ranged:-8,speed:15},
            {name:'gargantuan',rank:5,height:{min:['31','35'],max:['60','69'],unit:['meters','yards'],unit_abv:['m','yd']},mass:{min:['550','550'],max:['4000','4000'],unit:['tonnes','tons'],unit_abv:['t','lt']},lift:2500,dm:50,ar:50,ranged:-10,speed:30},
            {name:'colossal',rank:6,height:{min:['61','70'],max:['125','139'],unit:['meters','yards'],unit_abv:['m','yd']},mass:{min:['4','4'],max:['30','30'],unit:['kilotonnes','thousand of tons'],unit_abv:['kt',',000 lt']},lift:10000,dm:60,ar:60,ranged:-12,speed:60},
            {name:'enormous',rank:7,height:{min:['126','140'],max:['250','274'],unit:['meters','yards'],unit_abv:['m','yd']},mass:{min:['40','40'],max:['250','250'],unit:['kilotonnes','thousand of tons'],unit_abv:['kt',',000 lt']},lift:50000,dm:70,ar:70,ranged:-14,speed:125},
            {name:'monstrous',rank:8,height:{min:['251','275'],max:['500','549'],unit:['meters','yards'],unit_abv:['m','yd']},mass:{min:['0.3','0.3'],max:['2','2'],unit:['millions of tonnes','millions of tons'],unit_abv:['MT',',000,000 lt']},lift:25000,dm:80,ar:80,ranged:-16,speed:250},
            {name:'titanic',rank:9,height:{min:['501','550'],max:['1000','1100'],unit:['meters','yards'],unit_abv:['m','yd']},mass:{min:['2','2'],max:['15','15'],unit:['millions of tonnes','millions of tons'],unit_abv:['MT',',000,000 lt']},lift:1000000,dm:90,ar:90,ranged:-18,speed:500},
            {name:'monumental',rank:10,height:{min:['1','0.6'],max:['2','1.2'],unit:['kilometers','miles'],unit_abv:['km','mi']},mass:{min:['15','15'],max:['125','125'],unit:['millions of tonnes','millions of tons'],unit_abv:['MT',',000,000 lt']},lift:5000000,dm:100,ar:100,ranged:-20,speed:1000},
        ];
        size.template = templates.find(t => {
            return t.name === size.name;
        });
        return size.template;
    }

    function customizationsToString(cache, customizations = []) {
        const temp = {};
        clog(cache, temp, 'customizationsToString()');
        temp.customization_string = '';
        for (let i = 0, n = customizations.length; i < n; i++) {
            temp.customization_string += `${customizations[i].name}: ` +
            `${customizations[i].rank}\n`;
        }
        return temp.customization_string;
    }

    /* Condition Related Functions */
    async function buildConditionsMenu(cache) {
        const temp = {
            menu: '',
            condition: '',
            conditions: [
                'anemic',
                'blinded',
                'contagious',
                'continuing',
                'dead',
                'demoralized',
                'drained',
                'incapacitated',
                'incurable',
                'irritant',
                'lethargic',
                'prone',
                'serious injury',
                'stunned',
                'tangled',
                'unconscious'
            ],
        };
        clog(cache, temp, 'buildConditionsMenu()');
        for (let i = 0, n = temp.conditions.length; i < n; i++) {
            temp.condition = getTranslationByKey(`${temp.conditions[i]}`);
            temp.condition_name = temp.condition.capitalize();
            temp.menu += `|${temp.condition.capitalize()},${temp.conditions[i]}`;
        }
        temp.menu += `|${getTranslationByKey("go-back")},conditions`;
        return temp.menu;
    }

    async function buildActiveConditionsMenu(cache) {
        const temp = {
            active_conditions: {},
            attrs_to_get: [],
            conditions: [],
            condition_ids: [],
            menu: ''
        };
        clog(cache, temp, 'buildActiveConditionsMenu()');
        temp.condition_ids = await getSectionIDsAsync('condition');
        for (let i =0; i < temp.condition_ids.length; i++) {
            temp.attrs_to_get.push(`repeating_condition_${temp.condition_ids[i]}_name`);
        }
        temp.active_conditions = await getAttrsAsync(temp.attrs_to_get);
        temp.conditions = Object.values(temp.active_conditions);
        for (let i = 0; i < temp.conditions.length; i++) {
            const condition = temp.conditions[i].toLowerCase();
            const condition_name = getTranslationByKey(`${condition}`).capitalize();
            temp.menu += `|${condition_name},${temp.conditions[i]}~${temp.condition_ids[i]}`;
        }
        temp.menu += `|${getTranslationByKey("exit")},exit`;
        return temp.menu;
    }

    async function getConditionDamage(cache) {
        const temp = {};
        clog(cache, temp, 'getConditionDamage()');
        temp.title = 'Enter damage amount';
        temp.options = '';
        await crpQuery(cache, temp);
        return temp.selection;
    }

    async function getConditionUserInput(cache, condition, input) {
        const temp = {};
        clog(cache, temp, 'getConditionUserInput()');
        temp.titles = [
            {},
            {// input 1
                'blinded':'enter-amount-roll-failed-by',
                'contagious':'select-contagion',
                'continuing':'enter-number-of-rounds',
                'demoralized':'enter-combat-value-loss',
                'drained':'select-stat-affected',
                'incapacitated':'select-time-scale',
                'incurable':'enter-damage-amount',
                'lethargic':'choose-movement-environment',
                'tangled':'enter-tangle-health-points',
                'unconscious':'enter-number-of-rounds',
                'default':''
            },
            {// input 2
                'continuing':'select-time-scale',
                'drained':'enter-amount-stat-drains-by',
                'incurable':'select-limited-healing',
                'default':''
            },
            {// input 3
                'continuing':'enter-damage-amount',
                'default':''
            }
        ];
        temp.title = 
            getTranslationByKey(`${temp.titles[input][condition]}`) || 
            temp.titles[input]['default'];
        temp.options_available = [
            {},
            {// input 1
                'contagious':`|${getTranslationByKey("damage")},damage` +
                    `|${getTranslationByKey("anemic").capitalize()},anemic` +
                    `|${getTranslationByKey("blinded").capitalize()},blinded` +
                    `|${getTranslationByKey("continuing").capitalize()},continuing` +
                    `|${getTranslationByKey("demoralized").capitalize()},demoralized` +
                    `|${getTranslationByKey("drain").capitalize()},drain` +
                    `|${getTranslationByKey("enervation").capitalize()},enervation` +
                    `|${getTranslationByKey("flare").capitalize()},flare` +
                    `|${getTranslationByKey("incapacitating").capitalize()},incapacitating` +
                    `|${getTranslationByKey("incurable").capitalize()},incurable` +
                    `|${getTranslationByKey("irritant").capitalize()},irritant` +
                    `|${getTranslationByKey("lethargic").capitalize()},lethargic` +
                    `|${getTranslationByKey("tangled").capitalize()},tangled`,
                'drained':`|${getTranslationByKey("body")},body|${getTranslationByKey("mind")},mind|${getTranslationByKey("soul")},soul`,
                'incapacitated':`|${getTranslationByKey("round")},round|${getTranslationByKey("minute-time")},minute-time`,
                'lethargic':`|${getTranslationByKey("air")},air|${getTranslationByKey("ground")},ground` +
                    `|${getTranslationByKey("space")},space|${getTranslationByKey("water")},water`,
                'default':''
            },
            {// input 2
                'continuing':
                    `|${getTranslationByKey("per-round")},${getTranslationByKey("rounds")}` +
                    `|${getTranslationByKey("per-hour")},${getTranslationByKey("every-hour-target-number-15")}` +
                    `|${getTranslationByKey("per-day")},${getTranslationByKey("every-day-target-number-15")}`,
                'incurable':
                    `|${getTranslationByKey("natural-healing").capitalize()},${getTranslationByKey("natural-healing")}` +
                    `|${getTranslationByKey("slowed-natural-healing").capitalize()},${getTranslationByKey("slowed-natural-healing")}` +
                    `|${getTranslationByKey("special-event").capitalize()},${getTranslationByKey("special-event")}`,
                'default':''
            },
            {// input 3
                'default':''
            }
        ];
        temp.options = 
            temp.options_available[input][condition] || 
            temp.options_available[input]['default'];
        await crpQuery(cache, temp);
        if (condition === 'demoralized' || condition === 'drained' && 
            !isNaN(temp.selection) && temp.selection > 0) {
                temp.selection = temp.selection * -1;
        }
        if (condition === 'drained' && isNaN(temp.selection)) {
            temp.selection = temp.selection.capitalize();
        }
        return temp.selection;
    }

    function getIsUserInputRequired(condition) {
        const user_input_required = /(blinded|contagious|continuing|demoralized|drained|incapacitated|incurable|lethargic|tangled|unconscious)/;
        return user_input_required.test(condition);
    }

    async function setContagion(cache, set_values, contagion) {
        const temp = {};
        clog(cache, temp, 'setContagion()');
        temp.id = generateRowID();
        if (getIsUserInputRequired(contagion.input1)) {
            temp.input1 = await getConditionUserInput(cache, contagion.input1, 1) || '';
            temp.input2 = await getConditionUserInput(cache, contagion.input1, 2) || '';
            temp.input3 = await getConditionUserInput(cache, contagion.input1, 3) || '';
        } else if (contagion.input1 === 'anemic') {
            temp.input1 = -1;
        } else if (contagion.input1 === 'serious injury') {
            temp.input1 = getTranslationByKey("round-or-minute-out-of-combat");
        }
        if (contagion.input1 === 'blinded') {
            temp.input2 = await getSenses(cache);
        } else if (contagion.input1 === 'lethargic') {
            temp.input2 = getLethargicReduction(cache, temp, contagion.input1);
        }
        set_values[`repeating_condition_${temp.id}_name`] = 
        set_values[`repeating_condition_${temp.id}_description`] = 
            await getConditionDescription(cache, contagion.input1, temp);
        temp.id = temp.id.toLowerCase();
        temp.type = contagion.input1.capitalize();
        cache.conditiondb.contagious.push(temp);
        return {
            input1: temp.input1 || '',
            input2: temp.input2 || '',
            input3: temp.input3 || '',
        };
    }

    async function setConditiondb(cache, set_values, condition) {
        const temp = {};
        clog(cache, temp, 'setConditiondb()');
        // Determin if condition is new, and if not then find existing condition to update.
        temp.is_new = true;
        if (cache.condition_ids.indexOf(cache.condition_id.toLowerCase()) !== -1) {
            temp.is_new = false;
            temp.i = cache.conditiondb[condition].findIndex(c => {
                return c.id.toLowerCase() === cache.condition_id.toLowerCase();
            });
        }
        // Get any required input from player.
        if (getIsUserInputRequired(condition)) {
            temp.input1 = cache.input1 === undefined ?
                await getConditionUserInput(cache, condition, 1) : cache.input1;
            temp.input2 = cache.input2 === undefined ?
                await getConditionUserInput(cache, condition, 2) : cache.input2;
            temp.input3 = cache.input3 === undefined ?
                await getConditionUserInput(cache, condition, 3) : cache.input3;
        } else if (condition === 'anemic') {
            temp.input1 = temp.is_new ? -1 : cache.conditiondb[condition][0].input1 -= 1;
        } else if (condition === 'serious injury') {
            temp.input1 = getTranslationByKey("round-or-minute-out-of-combat");
        }
        if (condition === 'blinded') {
            const senses = await getSenses(cache);
            temp.input2 = senses.capitalize().join(', ');
        } else if (condition === 'lethargic') {
            temp.input2 = getLethargicReduction(cache, temp, condition);
        } else if (condition === 'contagious' && temp.input1 === 'damage' || 
        temp.input1 === 'enervation') {
            temp.input2 = await getConditionDamage(cache);
        }
        if (condition === 'lethargic' && !temp.is_new) {
            cache.conditiondb[condition][temp.i].input2 = temp.input2;
        } else {
            temp[`${condition}`] = {
                input1: temp.input1 || '',
                input2: temp.input2 || '',
                input3: temp.input3 || '',
                id: cache.condition_id.toLowerCase(),
                duration: Infinity,
            };
            if (condition === 'contagious' && temp.input1 !== 'damage' && 
            temp.input1 !== 'enervation') {
                temp[`${condition}`].contagion = 
                await setContagion(cache, set_values, temp);
            }
            if (temp.is_new) {
                temp[`${condition}`].duration = 
                condition === 'anemic' || condition === 'demoralized' ||
                condition === 'irritant' || condition === 'lethargic' ? 20 :
                condition === 'blinded' || condition === 'unconscious' ||
                condition === 'continuing' && temp.input2 === "rounds" ? temp.input1 :
                condition === 'incapacitated' && temp.input1 === 'round' ? 1 :
                condition === 'incapacitated' && temp.input1 === 'minute-time' ? 20 :
                condition === 'drained' ? (temp.input2 * -1) * 1200 : Infinity;
                cache.conditiondb[condition].push(temp[condition]);
                if (condition === 'drained') {
                    const drained = {};
                    drained.answer = temp.input2 * -1;
                    drained.stat = temp.input1.toLowerCase();
                    drained.point_type = 'damage';
                    drained.point_method = 'set';
                    await setStat(cache, drained, set_values);
                    await setDerivedValues(cache, set_values);
                }
            } else {
                cache.conditiondb[condition][temp.i] = temp[condition];
            }
        }
    }

    async function getSenses(cache) {
        const temp = {};
        clog(cache, temp, 'getSenses()');
        temp.senses = ['hearing','sight','smell','taste','touch'];
        temp.result = [];
        temp.exit = false;
        temp.title_static = 'Select Affected Senses';
        temp.options = '';
        while (temp.exit === false) {
            temp.title = `${temp.title_static}. Selected [${
                temp.result.length === 0 ? 'None' : temp.result.join(', ').capitalize()
            }]`;
            temp.options = temp.result.length === 0 ?
                '' : `|${getTranslationByKey("done-finished").capitalize()},done`;
            for (let i = 0; i < temp.senses.length; i++) {
                temp.bracket = temp.result.indexOf(temp.senses[i]) !== -1 ? 
                    true : false;
                temp.options += 
                    `|${temp.bracket ? '[' : ''}` +
                    `${getTranslationByKey(temp.senses[i]).capitalize()}` +
                    `${temp.bracket ? ']' : ''}` +
                    `,${temp.senses[i]}`;
            }
            await crpQuery(cache, temp);
            if (temp.selection === 'done') {
                temp.exit = temp.result.length !== 0 ? true : false;
            } else {
                temp.index = temp.result.indexOf(temp.selection);
                if (temp.index !== -1) {
                    temp.result.splice(temp.index, 1);
                } else {
                    temp.result.push(temp.selection);
                }
            }
        }
        return temp.result;
    }

    async function getStats(cache, query) {
        const temp = {};
        clog(cache, temp, 'getStats()');
        temp.result = query.result !== undefined ? [...query.result] : [];
        temp.exit = false;
        temp.title_static = getTranslationByKey("choose-stats");
        temp.options = '';
        while (temp.exit === false) {
            temp.title = `${temp.title_static}. Selected [${
                temp.result.length === 0 ? 'None' : temp.result.join(', ').capitalize()
            }]`;
            temp.options = temp.result.length === 0 ?
                '' : `|${getTranslationByKey("done-finished").capitalize()},done`;
            for (let i = 0; i < all_stats.length; i++) {
                temp.bracket = temp.result.indexOf(all_stats[i]) !== -1 ? 
                    true : false;
                temp.options += 
                    `|${temp.bracket ? '[' : ''}` +
                    `${getTranslationByKey(all_stats[i]).capitalize()}` +
                    `${temp.bracket ? ']' : ''}` +
                    `,${all_stats[i]}`;
            }
            await crpQuery(cache, temp);
            if (temp.selection === 'done') {
                temp.exit = temp.result.length !== 0 ? true : false;
            } else {
                temp.index = temp.result.indexOf(temp.selection);
                if (temp.index !== -1) {
                    temp.result.splice(temp.index, 1);
                } else {
                    temp.result.push(temp.selection);
                }
            }
        }
        return temp.result;
    }

    function getMarginOfSuccess(cache, result, target = 0) {
        const temp = {};
        clog(cache, temp, 'getMarginOfSuccess()');
        temp.result = result < 0 ? 'failure' : 'success';
        if (cache.rulesdb.rules_optional_mos_status) {
            temp.margin = temp.result === 'failure' ? result * -1 : result;
            switch (temp.margin) {
                case 23:
                case 22:
                case 21:
                case 20:
                case 19:
                case 18:
                    temp.mos = 'extreme';
                break;
                case 17:
                case 16:
                case 15:
                case 14:
                case 13:
                case 12:
                    temp.mos = 'major';
                break;
                case 11:
                case 10:
                case 9:
                case 8:
                case 7:
                case 6:
                    temp.mos = 'significant';
                break;
                case 5:
                case 4:
                case 3:
                    temp.mos = 'moderate';
                break;
                case 2:
                case 1:
                    temp.mos = 'slight';
                break;
                case 0:
                    temp.mos = 'tie-or-slim';
                break;
                default:
                    temp.mos = 'monstrous';
            }
            return `${getTranslationByKey(temp.mos)} ${getTranslationByKey(temp.result)}`;
        } else {
            return getTranslationByKey(temp.result);
        }
        
    }

    function setSkillsPointTotal(cache, set_values, query = {}) {
        const temp = {};
        clog(cache, temp, 'setSkillsPointTotal()');
        temp.index = cache.skill_index === undefined ? query.index : cache.skill_index;
        temp.skills = cache.attrdb.skills[temp.index].individual;
        temp.spent = temp.skills === [] ? 0 :
            temp.skills.map(s => s.points).reduce((a, b) => a + b, 0);
        temp.total = cache.attrdb.skills[temp.index].elevel * 10;
        set_values.static_skills_points_total = temp.spent;
        set_values.static_skills_points_remaining = temp.total - temp.spent;
    }

    function setGroupCharacterPoints(cache, set_values, group_id = 0) {
        const temp = {};
        clog(cache, temp, 'setGroupCharacterPoints()');
        temp.group_id = cache.static_group_visible_id === undefined ? 
            int(group_id) : cache.static_group_visible_id;
        temp.spent = cache.groupdb[temp.group_id].group_type !== 'standard' ?
            cache.groupdb[temp.group_id].elevel * 
            attribute_costs[cache.groupdb[temp.group_id].group_type] : 0;
        for (let i = 0; i < all_attributes.length; i++) {
            const attributes = cache.attrdb[all_attributes[i]];
            temp.spent += attributes.map(a => 
                a.group_id === temp.group_id ? a.points : 0
            ).reduce((a, b) => a + b, 0);
        }
        for (let i = 0; i < all_defects.length; i++) {
            const defects = cache.defectdb[all_defects[i]];
            temp.spent += defects.map(d => 
                d.group_id === temp.group_id ? d.points : 0
            ).reduce((a, b) => a + b, 0);
        }
        temp.group_points = 
            cache.groupdb[temp.group_id].item === 'yes' ||
            cache.groupdb[temp.group_id].item === 'shield' ? 
                Math.max(Math.floor(temp.spent/2), 0) :
            cache.groupdb[temp.group_id].item === 'gear' ? 
                cache.groupdb[temp.group_id].level : temp.spent;
        cache.groupdb[temp.group_id].group_points = temp.group_points;
        if (cache.static_group_visible_id === temp.group_id) {
            set_values.static_attribute_group_totalpoints = temp.group_points;
        }
    }

    function getLethargicReduction(cache, user_data, condition) {
        const temp = {};
        clog(cache, temp, 'getLethargicReduction()');
        temp.condition_data = cache.conditiondb[condition].find(c => {
            return c.input1 === user_data.input1;
        });
        if (temp.condition_data === undefined) {
            temp.input2 = 0.5;
        } else {
            temp.input2 = temp.condition_data.input2 / 2;
            cache.condition_id = temp.condition_data.id;
            user_data.is_new = false;
            user_data.i = cache.conditiondb[condition].findIndex(c => {
                return c.id.toLowerCase() === cache.condition_id.toLowerCase();
            });
        }
        return temp.input2;
    }

    function removeConditiondbEntry(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'removeConditiondbEntry()');
        temp.name = cache.condition.name.toLowerCase();
        temp.i = cache.conditiondb[temp.name].findIndex(c => c.id === cache.condition.id);
        cache.conditiondb[temp.name].splice([temp.i], 1);
    }

    async function setConditionAnemic(cache, temp) {
        clog(cache, temp, 'setConditionAnemic()');
        temp.input1 = -1;
    }
    
    async function getConditionDescription(cache, condition, contagion = false) {
        const temp = {};
        clog(cache, temp, 'getConditionDescription()');
        if (!contagion) {
            cache.conditiondb[condition].find( c => {
                if (c.id === cache.condition_id.toLowerCase()) {
                    temp.input1 = c.input1;
                    temp.input2 = c.input2;
                    temp.input3 = c.input3;
                    temp.id = c.id;
                };
            });
            if (condition === 'contagious') {
                temp.contagion = 
                temp.input1 === 'damage' || temp.input1 === 'enervation' ?
                    `${temp.input2} ${temp.input1}` : temp.input1;
            }
        } else {
            Object.assign(temp, contagion);           
        }
        const duration_descriptions = {
            'anemic':'one-minute-or-dramatic-scene',
            'blinded':'rounds',
            'contagious':'until-negated',
            'continuing':`${temp.input1} ${temp.input2}`,
            'dead':'permanent',
            'demoralized':'one-minute-or-dramatic-scene',
            'drained':'recovered-per-hour',
            'incapacitated':`${temp.input1}`,
            'incurable':'until-damage-is-healed',
            'irritant':'one-minute-or-dramatic-scene',
            'lethargic':'one-minute-or-dramatic-scene',
            'prone':'requires-a-general-action-to-stand-up',
            'serious injury':'until-successful-surgery',
            'stunned':'requires-a-general-action-to-recover',
            'tangled':'health-points-of-tangle-must-be-destroyed',
            'unconscious':'rounds',
        };
        const effect_descriptions = {
            'anemic':'damage-multiplier-u',
            'blinded':'blinded',
            'contagious':'to-others-who-touch-or-otherwise-contact-the-character',
            'continuing':'damage',
            'dead':'cannot-take-any-actions',
            'demoralized':'attack-combat-value-and-defensive-combat-value',
            'drained':`${temp.input2} ${temp.input1}`,
            'incapacitated':'completely-immobilized',
            'incurable':`${temp.input2}`,
            'irritant':'minor-obstacle-on-all-stat-and-skill-rolls',
            'lethargic':'movement-reduced',
            'prone':'minor-obstacle-to-attack-or-defend',
            'serious injury':'negative-one-health-point-every',
            'stunned':'cannot-do-anything-but-defend',
            'tangled':'major-obstacle-to-any-movement-related-roll',
            'unconscious':'cannot-take-any-actions',
        };
        const prefixed_conditions = ['blinded','continuing','incurable','tangled','unconscious'];
        temp.description = `${getTranslationByKey("duration").capitalize()}: `;
        temp.description += 
            condition === 'continuing' ?`${temp.input1} ${temp.input2}; ` :
            condition === 'drained' ? `+1 ${temp.input1} ` +
            `${getTranslationByKey(duration_descriptions[condition])}; ` :
            condition === 'incapacitated' ? `1 ` +
            `${getTranslationByKey(duration_descriptions[condition])}; ` :
            condition === 'incurable' ? `` +
            `${getTranslationByKey(duration_descriptions[condition])} ` +
            `[${temp.input1}]; ` :
            prefixed_conditions.indexOf(condition) !== -1 ? `${temp.input1} ` +
            `${getTranslationByKey(duration_descriptions[condition])}; ` :
            `${getTranslationByKey(duration_descriptions[condition])}; `;
        temp.description += `${getTranslationByKey("effect").capitalize()}: `;
        temp.description += 
            condition === 'anemic' || 
            condition === 'demoralized' ? `${temp.input1} ` +
            `${getTranslationByKey(effect_descriptions[condition])}` :
            condition === 'blinded' ? `${temp.input2} ` +
            `${getTranslationByKey(effect_descriptions[condition])}` :
            condition === 'contagious' ? `${temp.contagion} ` +
            `${getTranslationByKey(effect_descriptions[condition])}` :
            condition === 'continuing' ? `${temp.input3} ` +
            `${getTranslationByKey(effect_descriptions[condition])}` :
            condition === 'drained' ? `${temp.input2} ${temp.input1}` :
            condition === 'incurable' ? `${temp.input2}` :
            condition === 'lethargic' ? `${temp.input1} ` +
            `${getTranslationByKey(effect_descriptions[condition])} ` +
            `${(1 - temp.input2) * 100}%` :
            condition === 'serious injury' ? 
            `${getTranslationByKey(effect_descriptions[condition])} ` +
            `${temp.input1}` :
            `${getTranslationByKey(effect_descriptions[condition])}`;
        return temp.description;
    }

    function getConditionType(cache, condition) {
        const temp = {};
        clog(cache, temp, 'getConditionType()');
        temp.cumulative = ['anemic','demoralized','drained'];
        temp.stackable = ['blinded','contagious','continuing','incurable','lethargic','serious injury','tangled'];
        temp.type = 
            temp.cumulative.indexOf(condition) !== -1 ? 'cumulative' :
            temp.stackable.indexOf(condition) !== -1 ? 'stackable' :
            'unique';
        return temp.type;
    }

    function getConditionID(cache, condition) {
        const temp = {};
        clog(cache, temp, 'getConditionID()');
        switch(getConditionType(cache, condition)) {
            case 'cumulative':
                temp.id = cache.conditiondb[condition].length === 0 ?
                    generateRowID() : cache.conditiondb[condition][0].id;
            break;
            case 'stackable':
                temp.id = generateRowID();
            break;
            default:
                temp.id = cache.conditiondb[condition][0] === undefined ?
                generateRowID() : false;
        }
        return temp.id;
    }

    /* Attribute Functions */
    async function getAllAttributes(cache) {
        const temp = {};
        clog(cache, temp, 'getAllAttributes()');
        temp.rules = {
            rules_base: 'static_rules_base_default',
            rules_xdef: 'static_rules_extradefenses_status',
            rules_kb: 'static_rules_knockback_status',
            rules_sanity: 'static_rules_sanity_status',
            rules_society: 'static_rules_society_status',
        }
        await crpGet(cache, temp.rules);
        temp.attributes = [];
        temp.attributes = temp.attributes.concat(base_attributes);
        if (cache.rules_xdef) { temp.attributes = temp.attributes.concat(besmx_attributes); }
        if (cache.rules_kb) { temp.attributes = temp.attributes.concat(kb_attributes); }
        if (cache.rules_sanity) { temp.attributes = temp.attributes.concat(sanity_attributes); }
        if (cache.rules_society) { temp.attributes = temp.attributes.concat(society_attributes); }
        temp.attributes.sort();
        return temp.attributes;
    }

    function setLevelDependantConfigurations(cache, set_values, query) {
        clog(cache, query, 'setLevelDependantConfigurations()');
        if (
            query.attribute === 'absorption' ||
            query.attribute === 'armor' ||
            query.attribute === 'conversion' ||
            query.attribute === 'force field' ||
            query.attribute === 'skills'
        ) {
            const name = 
                query.attribute === 'skills' ? 'skill points':
                query.attribute === 'absorption' ? 'absorb' :
                query.attribute === 'conversion' ? 'convert' : 
                'armor rating';
            const index = cache.attrdb[query.attribute][query.index].config.findIndex(c => c.name === name);
            cache.attrdb[query.attribute][query.index].config[index].rank =
                int(`${query.elevel * (
                    query.attribute === 'absorption' ||
                    query.attribute === 'armor' ? 
                        5 :
                    query.attribute === 'conversion' ||
                    query.attribute === 'force field' ||
                    query.attribute === 'skills' ? 
                        10 : 0
                )}`);
            set_values[`repeating_attribute_${cache.attrdb[query.attribute][query.index].row_id}_configuration`] = '';
            for (let i = 0; i < cache.attrdb[query.attribute][query.index].config.length; i++) {
                set_values[`repeating_attribute_${cache.attrdb[query.attribute][query.index].row_id}_configuration`] += 
                    `${cache.attrdb[query.attribute][query.index].config[i].name.capitalize()} ` +
                    `(${cache.attrdb[query.attribute][query.index].config[i].rank})`;
                if (i !== cache.attrdb[query.attribute][query.index].config.length - 1) {
                    set_values[`repeating_attribute_${cache.attrdb[query.attribute][query.index].row_id}_configuration`] += '\n';
                }
            }
        }
    }

    async function setDefectCharacteristic(cache, set_values, query) {
        const defectCharacteristics = {
            "awkward size":{
                0: "Medium",
                1: "Large",
                2: "Huge",
                3: "Mammoth",
                4: "Gigantic",
                5: "Gargantuan",
                6: "Colossal",
                7: "Enormous",
                8: "Monstrous",
                9: "Titanic",
                10: "Monumental"
            },
            "bane":{
                1: "10 damage/round exposed",
                2: "20 damage/round exposed",
                3: "30 damage/round exposed",
                "default": ""
            },
            "blind fury":{
                1: "difficult initiate; easy revert",
                2: "moderately difficult initiate/revert",
                3: "easy initiate; difficult revert",
                "default": ""
            },
            "conditional ownership":{
                1: "mild conditions",
                2: "strict conditions",
                3: "severe conditions",
                "default": ""
            },
            "confined":{
                1: "large area (100 km radius)",
                2: "moderate area (1 km radius)",
                3: "small area (100 m radius)",
                "default": ""
            },
            "cursed":{
                1: "slight disadvantage",
                2: "moderate disadvantage",
                3: "severe disadvantage",
                "default": ""
            },
            "demure":{
                1: "Social Combat Value -2",
                2: "Social Combat Value -4",
                3: "Social Combat Value -6",
                "default": ""
            },
            "easily distracted":{
                1: "triggered infrequently",
                2: "triggered frequently",
                3: "triggered constantly",
                "default": ""
            },
            "fragile":{
                1: "Health Points -10",
                2: "Health Points -20",
                3: "Health Points -30",
                "default": ""
            },
            "hounded":{
                1: "slightly inconvenient",
                2: "moderately inconvenient",
                3: "severely inconvenient",
                "default": ""
            },
            "impaired manipulation":{
                1: "only one usable arm",
                2: "rudimentary manipulative ability",
                3: "no usable arms",
                "default": ""
            },
            "impaired speech":{
                1: "severe speech impediment",
                2: "sounds that carry emotional content",
                3: "completely mute",
                "default": ""
            },
            "involuntary change":{
                1: "Difficult to trigger",
                2: "Moderately easy to trigger",
                3: "Easy to trigger",
                "default": ""
            },
            "ism":{
                1: "slight discrimination",
                2: "moderate discrimination",
                3: "severe discrimination",
                "default": ""
            },
            "magnet":{
                1: "few adoring fans",
                2: "handful of adoring fans",
                3: "swarms of adoring fans",
                "default": ""
            },
            "marked":{
                1: "easily concealable",
                2: "concealed with moderate difficulty",
                3: "cannot be concealed in most circumstances",
                "default": ""
            },
            "nemesis":{
                1: "interferes infrequently",
                2: "interferes frequently",
                3: "interferes constantly",
                "default": ""
            },
            "nightmares":{
                1: "occur infrequently",
                2: "occur frequently",
                3: "occur constantly",
                "default": ""
            },
            "no healing":{
                1: "healing/recovery at slight disadvantage",
                2: "healing/recovery at moderate disadvantage",
                3: "healing/recovery at severe disadvantage",
                "default": ""
            },
            "obligated":{
                1: "small obligation",
                2: "moderate obligation",
                3: "large obligation",
                "default": ""
            },
            "phobia":{
                1: "slight- encountered infrequently",
                2: "moderate- encountered frequently",
                3: "severe- encountered constantly",
                "default": ""
            },
            "physical impairment":{
                1: "slight inconvenience",
                2: "moderate inconvenience",
                3: "severe inconvenience",
                "default": ""
            },
            "red tape":{
                1: "generally easy to manage",
                2: "moderately difficult to manage",
                3: "difficult to manage",
                "default": ""
            },
            "reduced damage":{
                1: "Damage Multiplier -1",
                2: "Damage Multiplier -2",
                3: "Damage Multiplier -3",
                "default": ""
            },
            "sensory impairment":{
                1: "minor obstacle",
                2: "major obstacle",
                3: "loss of sense",
                "default": ""
            },
            "significant other":{
                1: "appears infrequently",
                2: "appears frequently",
                3: "appears constantly",
                "default": ""
            },
            "shortcoming":{
                "default": ""
            },
            "skeleton in the closet":{
                1: "difficult to discover",
                2: "moderately easy to discover",
                3: "easy to discover",
                "default": ""
            },
            "social fault":{
                1: "slight disadvantage",
                2: "moderate disadvantage",
                3: "severe disadvantage",
                "default": ""
            },
            "special requirement":{
                1: "easy/infrequent",
                2: "moderately difficult/frequent",
                3: "difficult/constant",
                "default": ""
            },
            "unappealing":{
                1: "slightly",
                2: "moderately",
                3: "severely",
                "default": ""
            },
            "unique":{
                1: "infrequent/slight effect",
                2: "frequent/moderate effect",
                3: "constant/severe effect",
                "default": ""
            },
            "unsettled":{
                1: "Sanity Points -2",
                2: "Sanity Points -4",
                3: "Sanity Points -6",
                "default": ""
            },
            "vulnerability":{
                1: "drop by one quarter",
                2: "drop by one half",
                3: "cannot be used",
                "default": ""
            },
            "wanted":{
                1: "incentive offered is slight",
                2: "incentive offered is moderate",
                3: "incentive offered is extreme",
                "default": ""
            },
            "weak point":{
                1: "difficult to hit",
                2: "moderately easy to hit",
                3: "easy to hit",
                "default": ""
            }
        };
        let characteristic = '';
        switch (query.defect) {
            case 'achilles heel':
                query.config_index = cache.defectdb['achilles heel'][query.index].config.findIndex(c => c.name === 'achilles heel');
                characteristic = 
                    cache.defectdb['achilles heel'][query.index].config[query.config_index].rank ||
                    'not configued';
            break;
            case 'inept attack':
            case 'inept defense':
                const cv_mod = query.next === 'write_newdefect' ?
                    0 : cache.defectdb[`${query.defect}`][query.index].level;
                query.config_index = query.next === 'write_newdefect' ?
                    -1 : cache.defectdb[`${query.defect}`][query.index].config.findIndex(c => c.name === 'attack_type');
                const inept_attack_type = query.next === 'write_newdefect' ?
                    'any' : cache.defectdb[`${query.defect}`][query.index].config[query.config_index].rank;
                characteristic = 
                    `-${cv_mod * (inept_attack_type === 'any' ? 1 : 2)} ` +
                    `${query.defect === 'inept attack' ? "ACV" : "DCV"}`;
            break;
            case 'shortcoming':
                const db = query.next === 'write_level' ? query.db.config : query.config;
                for (let i = 0; i < db.length; i++) {
                    if (
                        db[i].name === 'aspect_name' ||
                        db[i].name === 'aspect_stat' ||
                        db[i].name === 'aspect_type'
                    ) { query[`${db[i].name}`] = db[i].rank; }
                }
                characteristic =
                    `${getTranslationByKey(query.aspect_stat)} - ` +
                    `${getTranslationByKey(query.aspect_type)} ${getTranslationByKey("aspect")}` +
                    `${
                        query.aspect_name === query.aspect_stat ? "" :
                        " (" + getTranslationByKey(query.aspect_name.toKebobCase()) + ")"
                    }`;
            break;
            default:
                characteristic = 
                    defectCharacteristics[`${query.defect}`][query.level] || 
                    defectCharacteristics[`${query.defect}`]["default"];
        }
        return characteristic;
    }

    async function setDefectConfiguration(cache, set_values, query) {
        const configurations = {};
        const db = query.next === 'write_newdefect' ? query.config : cache.defectdb[query.defect][query.index].config;
        const characteristic = await setDefectCharacteristic(cache, set_values, query);
        const configuration =
            query.defect === 'shortcoming' ? characteristic :
            db.map(c =>
                `${c.name.fromSnakeCase().capitalize()} ` +
                `(${
                    c.name === query.defect || c.name === configurations[query.defect] ?
                    characteristic : isNaN(c.rank) ? c.rank.capitalize() : c.rank
                })`
        ).sort().join("\n");
        return configuration;
    }

    async function setConfiguration(cache, set_values, query) {
        const configurations = {
            "absorption":'absorb',
            "armor":'armor rating',
            "augmented":'augmented_stat',
            "capacity":'capacity_type',
            "control environment":'environments',
            "conversion":'convert',
            "enemy attack":'enemy',
            "enemy defense":'enemy',
            "force field":'armor rating',
            "heightened senses":'senses',
            "sensory block":'senses_or_techniques',
            "skills":'skill points',
            "unaffected":'senses_or_techniques',
            "weapon":'damage',
        };
        const db = query.next === 'write_newattr' ? query.config : cache.attrdb[query.attribute][query.index].config;
        const characteristic = await setAttrCharacteristic(cache, set_values, query);
        const configuration =
            db.map(c =>
                `${c.name.capitalize()} ` +
                `(${
                    c.name === 'notes' ? c.rank :
                    c.name === 'techniques' || c.name === 'movements' ?
                        c.rank.map(t => t.name.capitalize() + ' (' + t.rank + ')').sort().join(", ") :
                    c.name === 'complete_resilience' ?
                        c.rank.map(r => r.capitalize()).sort().join(", ") :
                    c.name === 'source' && query.attribute === 'unaffected' ?
                        c.rank !== '' ? c.rank.capitalize() : '' :
                    c.name === 'senses_or_techniques' ? characteristic :
                    c.name === query.attribute || c.name === configurations[query.attribute] ?
                    characteristic : isNaN(c.rank) ? c.rank.capitalize() : c.rank
                })`
        ).sort().join("\n");
        if (query.attribute === 'defense mastery') {

        } else if (query.attribute === 'energized') {
            cache.statsdb.energy.energized = 0;
            for (let i = 0; i < cache.attrdb.energized.length; i++) {
                cache.statsdb.energy.energized += cache.attrdb.energized[i].active ? 
                    cache.attrdb.energized[i].elevel * 10 : 0;
            }
            setDerivedValues(cache, set_values);
        } else if (query.attribute === 'extra actions') {
            cache.statsdb.actions.base = 1;
            for (let i = 0; i < cache.attrdb['extra actions'].length; i++) {
                cache.statsdb.actions.base += cache.attrdb['extra actions'][i].active ? 
                    cache.attrdb['extra actions'][i].elevel : 0;
            }
            set_values.static_character_actions_base = cache.statsdb.actions.base;
        } else if (query.attribute === 'extra defenses') {
            cache.statsdb.defenses.base = 0;
            for (let i = 0; i < cache.attrdb['extra defenses'].length; i++) {
                cache.statsdb.defenses.base += cache.attrdb['extra defenses'][i].active ? 
                    cache.attrdb['extra defenses'][i].elevel : 0;
            }
            set_values.static_character_defenses_base = cache.statsdb.defenses.base;
        } else if (query.attribute === 'massive damage') {
            cache.statsdb.dm.base = 5;
            for (let i = 0; i < cache.attrdb['massive damage'].length; i++) {
                const is_focused = cache.attrdb['massive damage'][i].limiters.findIndex(l => l.name === 'focussed damage') !== -1;
                const is_targeted = cache.attrdb['massive damage'][i].limiters.findIndex(l => l.name === 'targeted damage') !== -1;
                cache.statsdb.dm.base += 
                    cache.attrdb['massive damage'][i].active && 
                    !is_focused && 
                    !is_targeted ?
                    cache.attrdb['massive damage'][i].elevel : 0;
            }
            set_values.static_character_dm_base = cache.statsdb.dm.base;
        }
        return configuration;
    }
    
    async function setAttrCharacteristic(cache, set_values, query = {}) {
        clog(cache, query, 'setAttrCharacteristic()');
        query.attribute = query.attribute === undefined ? cache.attribute[0] : query.attribute;
        query.elevel = query.elevel === undefined ? 0 : query.elevel;
        query.config = query.config === undefined ? query.db.config : query.config;
        let description = "";
        switch (query.attribute) {
            case "absorption": description = `${query.elevel * 5} Damage Absorbed`; break;
            case "alternate form": description = `${query.elevel * 5} Character Points`; break;
            case "alternate identity": description = `${query.elevel} Alternate Identities`; break;
            case "armor": description = query.elevel * 5; break;
            case "attack mastery": description = `+${query.elevel} ACV`; await setDerivedValues(cache, set_values); break;
            case "augmented":
                query.stat = query.config[query.config.findIndex(c => c.name === 'augmented_stat')].rank;
                description = `+${query.elevel} ${getTranslationByKey(query.stat).capitalize()}`;
                cache.statsdb[query.stat].augmented = query.elevel;
                set_values[`static_character_${query.stat}_remaining`] = 
                    cache.statsdb[query.stat].base +
                    cache.statsdb[query.stat].augmented +
                    cache.statsdb[query.stat].temp -
                    cache.statsdb[query.stat].damage -
                    (cache.statsdb[query.stat].shortcoming || 0);
                await setDerivedValues(cache, set_values);
            break;
            case "capacity": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "change state": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "cognition": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "companion": description = `${query.elevel * 10} Character Points`; break;
            case "connected": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "control environment": 
                description = `${query.elevel} environments maximum`;
                query.c_index = query.config.findIndex(c => c.name === 'environments');
                description += query.config[query.c_index].rank.length !== 0 ? ': ' + query.config[query.c_index].rank.sort().join(", ") : '';
            break;
            case "conversion": description = `${query.elevel} Character Points/10 Damage`; break;
            case "data access": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "defense mastery": description = `+${query.elevel} DCV`; await setDerivedValues(cache, set_values); break;
            case "dimension walk": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "elasticity": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "enemy attack":
            case "enemy defense":
                query.enemy = query.config[query.config.findIndex(c => c.name === 'enemy')].rank;
                description = 
                    `+${query.elevel * 2} ${query.attribute === 'enemy attack' ? 'ACV' : 'DCV'} vs. ${query.enemy}`;
            break;
            case "energized": description = `+${query.elevel * 10} Energy Points`; break;
            case "exorcism": description = `+${query.elevel * 2} Soul`; break;
            case "extra actions": description = `+${query.elevel} additional actions each round`; break;
            case "extra arms": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "extra defenses": description = `+${query.elevel} defensive actions each round`; break;
            case "features": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "flight": description = `Flight speed up to ${(get1or3(query.elevel, 1) * (10 ** (Math.ceil((query.elevel) / 2)))).toLocaleString()} kph`; break;
            case "force field": description = query.elevel * 10; break;
            case "ground speed": description = `${(get1or2andHalfor5(query.elevel + 2) * (10 ** (Math.ceil((query.elevel) / 3)))).toLocaleString()} kph`; break;
            case "healing": description = `Restore ${query.elevel * 5} Health Points`; break;
            case "heightened awareness": description = `${query.elevel} Awareness Bonus`; break;
            case "heightened senses":
                description = `${query.elevel} senses`; 
                query.c_index = query.config.findIndex(c => c.name === 'senses');
                description += query.config[query.c_index].rank.length !== 0 ? ': ' + 
                    query.config[query.c_index].rank.map(s => `${s.name} (${s.rank})`).sort().capitalize().join(", ") : '';
            break;
            case "illusion": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "immovable": description = `Knockback reduced by ${query.elevel * 10} m`; break;
            case "immunity":
                query.c_index = query.config.findIndex(c => c.name === 'immunity');
                description = query.elevel === 0 ? 'not configured' :
                `immune to ${query.config[query.c_index].rank}`;
            break;
            case "immutable": description = `+${query.elevel * 2} to resist effects`; break;
            case "inspire": description = `Stat/Skill Rolls +${query.elevel}`; break;
            case "jumping": description = `${get1or3(query.elevel, 3) * (10 ** (Math.ceil((query.elevel - 1) / 2)))} x normal distance`; break;
            case "massive damage": description = `+${query.elevel} DM`; break;
            case "melee attack": description = `+${query.elevel * 2} ACV with weapons of a specific type`; break;
            case "melee defense": description = `+${query.elevel * 2} DCV with weapons of a specific type`; break;
            case "merge": description = `Contribute ${query.elevel * 10} Character Points`; break;
            case "metamorphosis": description = `Race Template +/- ${query.elevel * 5} Character Points`; break;
            case "mimic": description = `Mimic Attribute Level ${query.elevel}`; break;
            case "mind control": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "mind shield": description = `${query.elevel} + Mind`; break;
            case "minions": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "mulligan": description = `${query.elevel * 2} re-rolls each game session`; break;
            case "nullify": description = `${query.elevel} Levels of an attribute`; break;
            case "plant control": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "pocket dimension": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "portal": description = `${query.elevel} one-way portals`; break;
            case "projection": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "ranged attack": description = `+${query.elevel * 2} ACV with weapons of a specific type`; break;
            case "ranged defense": description = `+${query.elevel * 2} DCV against ranged attacks`; break;
            case "regeneration": description = `Regenerate ${query.elevel * 5} Heath Points/Round`; break;
            case "reincarnation": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "resilient":
                description = `${query.elevel} environments/conditions maximum`;
                query.c_index = query.config.findIndex(c => c.name === 'resilient');
                description += query.config[query.c_index].rank.length !== 0 ? ': ' + query.config[query.c_index].rank.capitalize().sort().join(", ") : '';
            break;
            case "sensory block":
                description = `${query.elevel} are partially blocked`;
                query.c_index = query.config.findIndex(c => c.name === 'senses_or_techniques');
                description += query.config[query.c_index].rank.length !== 0 ? ': ' + query.config[query.c_index].rank.capitalize().sort().join(", ") : '';
            break;
            case "sixth sense":
                description = `${query.elevel} sixth senses maximum`;
                query.c_index = query.config.findIndex(c => c.name === 'sixth sense');
                description += query.config[query.c_index].rank.length !== 0 ? ': ' + query.config[query.c_index].rank.capitalize().sort().join(", ") : '';
            break;
            case "size change": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "skill group":
                query.c_index = query.config.findIndex(c => c.name === 'skill group');
                description = query.config[query.c_index].rank.capitalize();
            break;
            case "skills":
                if (
                    cache.static_skills_visible_id === query.index && 
                    query.next !== 'write_newattr'
                ) {
                    set_values.static_skills_attribute_name = query.db.name === '' ? query.attribute.capitalize() : query.db.name;
                    setSkillsPointTotal(cache, set_values, query);
                }
                description = `${query.elevel * 10} Skill Points`;
            break;
            case "social mastery": description = `+${query.elevel * 2} SCV`; await setDerivedValues(cache, set_values); break;
            case "spaceflight": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "summon creatures": description = `up to ${query.elevel === 0 ? 0 : (get1or3(query.elevel, 1) * (10 ** (Math.ceil((query.elevel) / 2)))).toLocaleString()}`; break;
            case "supersense": description = getCharacteristicByAttr(cache, set_values, query);
            break;
            case "superspeed": description = `up to ${query.elevel === 0 ? 0 : (get1or3(query.elevel, 1) * (10 ** (Math.ceil((query.elevel + 2) / 2)))).toLocaleString()} kph`; break;
            case "superstrength": description = `lift up to ${getCharacteristicByAttr(cache, set_values, query)}`;
            
            break;
            case "swarm": description = `Health Points * ${query.elevel} Creatures`; break;
            case "taunt": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "telekinesis": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "telepathy": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "teleport": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "tough": description = `+${query.elevel * 10} Health Points`; await setDerivedValues(cache, set_values); break;
            case "transfer": description = `Transer Attributes as Level ${query.elevel}`; break;
            case "transmute": description = `Transmute objects of ${query.elevel * 5} Character Points`; break;
            case "tunneling": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "unaffected":
                if (query.next !== 'write_newattr') {
                    const unaffected_config = query.db === undefined ? query.config : query.db.config;
                    query.unaffected_index = query.unaffected_index === undefined ? 
                        unaffected_config.findIndex(c => c.name === 'unaffected') : query.unaffected_index;
                    query.attributes = query.attributes === undefined ?
                        unaffected_config[query.unaffected_index].rank.map(a => a.name) : query.attributes;
                    query.weapon_index = query.weapon_index === undefined ?
                        unaffected_config[query.unaffected_index].rank.findIndex(a => a.name === 'weapon') : query.weapon_index;
                    query.weapons = query.weapons === undefined ?
                        query.weapon_index !== -1 ? 
                        [...unaffected_config[query.unaffected_index].rank[query.weapon_index].rank] : [] :
                        query.weapons;
                    
                    description = `${query.elevel * -2} Attacker's roll on offensive use of${
                        query.attributes.length !== 0 ? 
                            ': ' + query.attributes.map(a => a !== 'weapon' ? a : '').filter(a => a).sort().capitalize().join(', ') : ''
                    }${
                        query.weapons.length !== 0 ?
                            (query.attributes.length !== 1 ? ', ' : '') +
                            query.weapons.map(w => 'weapon with ' + w).sort().capitalize().join(', ') : ''
                    }`;
                }
                
            break;
            case "unassailable": description = `+${query.elevel * 2} Sanity Points`; await setDerivedValues(cache, set_values); break;
            case "undetectable":
                query.c_index = query.config.findIndex(c => c.name === 'senses_or_techniques');
                description = `${query.elevel - query.config[query.c_index].rank.length} remaining`;
                description += query.config[query.c_index].rank.length !== 0 ? '; hidden from ' + query.config[query.c_index].rank.capitalize().sort().join(", ") : '';
            break;
            case "unique attribute": description = ""; break;
            case "unknown power":
                query.config_index = query.config_index === undefined ?
                    query.config.findIndex(c => c.name === 'unknown power') : query.config_index;
                description = `${query.config[query.config_index].rank} Character Points`;
            break;
            case "water speed": description = `Water speed up to ${(get1or3(query.elevel, 1) * (10 ** (Math.ceil(query.elevel / 2)))).toLocaleString()} kph`; break;
            case "wealth": description = getCharacteristicByAttr(cache, set_values, query); break;
            case "weapon": description = `${query.elevel}`; break;
            default: description = "";
        }
        return description;
    }
        
    function getCharacteristicByAttr(cache, set_values, query = {}) {
        clog(cache, query, 'getCharacteristicByAttr()');
        const chardb = {
                "capacity": {
                    "cargo": {
                        0: "0 kg",
                        1: "200 kg",
                        2: "500 kg",
                        3: "1 tonne",
                        4: "2 tonnes",
                        5: "5 tonnes",
                        6: "10 tonnes",
                        7: "25 tonnes",
                        8: "50 tonnes",
                        9: "100 tonnes",
                        10: "200 tonnes",
                        "default": ""
                    },
                    "carry": {
                        0: "+0 people",
                        1: "+1 person",
                        2: "+2 people",
                        3: "+5 people",
                        4: "+10 people",
                        5: "+25 people",
                        6: "+50 people",
                        7: "+100 people",
                        8: "+250 people",
                        9: "+500 people",
                        10: "+1,000 people",
                        "default": ""
                    }
                },
                "change state": {
                    1: "Liquid state, short duration",
                    2: "Liquid state, long duration",
                    3: "Gaseous state, short duration",
                    4: "Gaseous state, long duration",
                    5: "Incorpreal state, short duration",
                    6: "Incorpreal state, long duration",
                    7: "Energy state, short duration",
                    8: "Energy state, long duration",
                    "default": "Does not improve beyond level 8"
                },
                "cognition": {
                    1: "Future: a few seconds; Past: 1 minute",
                    2: "Future: 1 minute; Past: 1 hour",
                    3: "Future: 10 minutes; Past: 1 day",
                    4: "Future: 1 hour; Past: 1 week",
                    5: "Future: 1 day; Past: 1 month",
                    6: "Future: 1 week; Past: 1 year",
                    7: "Future: 1 month; Past: 2 years",
                    8: "Future: 1 year; Past: 4 years",
                    "default": ""
                },
                "connected": {
                    1: "Associated",
                    2: "Respected",
                    3: "Modest Authority",
                    4: "Local Authority",
                    5: "Regional Authority.",
                    6: "Provincial Authority",
                    7: "National Authority",
                    8: "International Authority",
                    9: "Planetary Authority",
                    10: "Extraplanetary Authority",
                    "default": "Does not improve beyond level 10"
                },
                "data access": {
                    1: "Tiny-sized (10 cm radius)",
                    2: "Small-sized (1 m radius)",
                    3: "Moderately-sized (10 m radius)",
                    4: "Building-sized (100 m radius)",
                    5: "Neighbourhood-sized (1 km radius)",
                    6: "City-sized (10 km radius)",
                    "default": ""
                },
                "dimension walk": {
                    1: "Reflect insignificant changes",
                    2: "Reflect specific changes",
                    3: "Reflect minor changes",
                    4: "Reflect moderate changes",
                    5: "Reflect significant changes",
                    6: "Reflect major changes",
                    "default": "Does not improve beyond level 6"
                },
                "dynamic powers": {
                    1: "Minimal control",
                    2: "Minor control",
                    3: "Moderate control",
                    4: "Good control",
                    5: "Significant control",
                    6: "Major control",
                    "default": "Does not improve beyond level 6"
                },
                "elasticity": {
                    1: "Stretch up to 10 cm",
                    2: "Stretch up to 30 cm",
                    3: "Stretch up to 1 m",
                    4: "Stretch up to 3 m",
                    5: "Stretch up to 10 m",
                    6: "Stretch up to 30 m",
                    "default": ""
                },
                "extra arms": {
                    1: "1 additional arm",
                    2: "2 additional arms",
                    3: "Up to 5 additional arms",
                    4: "Up to 10 additional arms",
                    5: "Up to 25 additional arms",
                    6: "Up to 50 additional arms",
                    "default": "Does not improve beyond level 6"
                },
                "features": {
                    1: "2",
                    2: "5",
                    3: "Up to 10 features",
                    4: "Up to 25 features",
                    5: "Up to 50 features",
                    6: "Up to 100 features",
                    "default": "Does not improve beyond level 6"
                },
                "gear": {
                    1: "Up to 2 pieces of gear",
                    2: "Up to 5 pieces of gear",
                    3: "Up to 10 pieces of gear",
                    4: "Up to 25 pieces of gear",
                    5: "Up to 50 pieces of gear",
                    6: "Up to 100 pieces of gear",
                    "default": "Does not improve beyond level 6"
                },
                "ground speed": {
                    1: "Ground speed up to 10 kph",
                    2: "Ground speed up to 25 kph",
                    3: "Ground speed up to 50 kph",
                    4: "Ground speed up to 100 kph",
                    5: "Ground speed up to 250 kph",
                    6: "Ground speed up to 500 kph",
                    "default": "Does not improve beyond level 6"
                },
                "illusion": {
                    1: "Tiny-sized (10 cm radius)",
                    2: "Small-sized (1 m radius)",
                    3: "Moderately-sized (10 m radius)",
                    4: "Building-sized (100 m radius)",
                    5: "Neighbourhood-sized (1 km radius)",
                    6: "City-sized (10 km radius)",
                    "default": "Does not improve beyond level 6"
                },
                "mind control": {
                    1: "Extremely basic, non-aggressive suggestions",
                    2: "Simple, non-aggressive suggestions",
                    3: "Copmlex, non-aggressive suggestions",
                    4: "Complex, aggressive suggestions",
                    5: "Complex/aggressive suggestions, erase brief events",
                    6: "Complex/aggressive suggestions, alter events",
                    "default": ""
                },
                "minions": {
                    1: "Up to 5 Minions",
                    2: "Up to 10 Minions",
                    3: "Up to 25 Minions",
                    4: "Up to 50 Minions",
                    5: "Up to 100 Minions",
                    6: "Up to 200 Minions",
                    "default": ""
                },
                "plant control": {
                    1: "Control radius 10 cm, Growth 3x",
                    2: "Control radius 1 m, Growth 10x",
                    3: "Control radius 10 m, Growth 30x",
                    4: "Control radius 100 m, Growth 100x",
                    5: "Control radius 1 km, Growth 300x",
                    6: "Control radius 10 km, Growth 1000x",
                    "default": ""
                },
                "pocket dimension": {
                    1: "Tiny-sized (10 cm radius)",
                    2: "Small-sized (1 m radius)",
                    3: "Moderately-sized (10 m radius)",
                    4: "Building-sized (100 m radius)",
                    5: "Neighbourhood-sized (1 km radius)",
                    6: "City-sized (10 km radius)",
                    "default": ""
                },
                "projection": {
                    1: "Tiny-sized (10 cm radius)",
                    2: "Small-sized (1 m radius)",
                    3: "Moderately-sized (10 m radius)",
                    4: "Building-sized (100 m radius)",
                    5: "Neighbourhood-sized (1 km radius)",
                    6: "City-sized (10 km radius)",
                    "default": ""
                },
                "reincarnation": {
                    1: "Up to 1 month to reincarnate",
                    2: "Up to 1 week to reincarnate",
                    3: "Up to 1 day to reincarnate",
                    4: "Up to 12 hours to reincarnate",
                    5: "Up to 1 hour to reincarnate",
                    6: "Up to 1 minute to reincarnate",
                    "default": "Does not improve beyond level 6"
                },
                "spaceflight": {
                    1: "Primitive near-planetary Spaceflight (up to 10,000 kph). Travel from a planet to its moon takes a few days, while a flight between nearby planets can take up to a year or more. This represents the approximate state of current human achievement for passenger spaceflight.",
                    2: "Slow interplanetary Spaceflight (up to 100,000 kph). Travel from a planet to its moon takes a few hours, while a flight between nearby planets can take up to a month. This represents the approximate state of current human achievement for robotic spaceflight.",
                    3: "Average interplanetary Spaceflight. Travel between nearby planets in the same solar system takes a few days.",
                    4: "Fast interplanetary Spaceflight. Travel between nearby planets in the same solar system takes a few hours.",
                    5: "Extrasolar Spaceflight  approaching the speed of light. Travel between planets in the same solar system takes a few minutes, while travel between nearby solar systems takes a few years.",
                    6: "Slow faster-than-light Spaceflight  up to 10 times the speed of light. Travel between solar systems takes several weeks.",
                    7: "Average faster-than-light Spaceflight  up to 100 times the speed of light. Travel between solar systems takes a couple of weeks.",
                    8: "Rapid faster-than-light Spaceflight  up to 1,000 times the speed of light. Travel between solar systems takes a few days.",
                    9: "Exceptionally rapid faster-than-light Spaceflight  up to 10,000 times the speed of light. Travel between solar systems takes a few hours.",
                    10: "Extremely rapid faster-than-light Spaceflight  up to 100,000 times the speed of light. Travel between solar systems takes a few minutes.",
                    "default": "Does not improve beyond level 10"
                },
                "supersense": {
                    1: "10 m",
                    2: "100 m",
                },
                "superstrength": {
                    1: "250 kg",
                    2: "500 kg",
                    3: "1 tonne",
                    4: "2 tonnes",
                    5: "5 tonnes",
                },
                "taunt": {
                    1: 'Base Taunt',
                    2: 'Precise Taunt',
                    3: 'Moderate Taunt',
                    4: 'Upgraded Taunt',
                    5: 'Significant Taunt',
                    6: 'Dramatic Taunt',
                    7: 'Exceptional Taunt',
                    8: 'Extreme Taunt',
                    9: 'Excessive Taunt',
                    10: 'Legendary Taunt',
                    "default": "Does not improve beyond level 10"
                },
                "telekinesis": {
                    1: "can move 1 kg; 10 gram objects may be hurled 1 m (inflicts no damage)",
                    2: "can move 10 kg; 100 gram objects may be hurled 3 m (Weapon Level 0 Stun)",
                    3: "can move 100 kg; 1 kg objects may be hurled 10 m (Weapon Level 1)",
                    4: "can move 1 tonne; 10 kg objects may be hurled 30 m (Weapon Level 2)",
                    5: "can move 10 tonnes; 100 kg objects may be hurled 100 m (Weapon Level 3)",
                    6: "can move 100 tonnes; 1 tonne objects may be hurled 300 m (Weapon Level 4)",
                    "default": ""
                },
                "telepathy": {
                    1: {
                        1: "can pick up loud surface thoughts of one touched target",
                        2: "can pick up ordinary surface thoughts of one touched target",
                        3: "can read loud surface thoughts from a group of people, up to 10",
                    },
                    2: {
                        1: "can transmit a single feeling to the target",
                        2: "can transmit a word, simple image, or simple concept to a non-telepath target",
                        3: "can transmit speech to a single non-telepath target at normal conversational speeds, or a single powerful image or simple thought to up to 10 people",
                        4: "can transmit thoughts at conversational speeds to nearby people simultaneously, up to",
                    },
                    3: "two telepaths can mentally communicate at conversational speeds",
                    4: "can pick up a single touched targets sensory impressions",
                    5: "can choose to edit out some senses if desired",
                    6: "can invade a targets mind (counts as an attack)",
                    7: {
                        1: "can read loud surface thoughts from anyone touched without concentrating",
                        2: "can read loud surface thoughts of anyone in the general vicinity without concentrating",
                        3: "can automatically read the surface thoughts of everyone in the vicinity and automatically shares the sensory experiences of anyone touched without concentrating",
                    },
                    8: "can probe memories that the target no longer consciously remembers on a successful mental invasion",
                    9: "can alter memories by deleting existing memories and giving the target false ones on a successful mental invasion",
                    10: {
                        1: "can automatically read and organize past emotions of everyone in the vicinity within the previous few hours",
                        2: "can automatically read and organize past emotions of everyone in the vicinity within the previous day",
                        3: "can automatically read and organize past emotions of everyone in the vicinity within the previous week",
                        4: "can automatically read and organize past emotions of everyone in the vicinity within the previous month",
                        5: "can automatically read and organize past emotions of everyone in the vicinity within the previous year",
                        6: "can automatically read and organize past emotions of everyone in the vicinity within the previous years, up to",
                    },
                    "default": "See rulebook for capabilities"
                },
                "teleport": {
                    1: "10 m",
                    2: "100 m",
                    3: "1 km",
                    4: "10 km",
                    5: "100 km",
                    6: "1,000 km",
                    "default": ""
                },
                "tunneling": {
                    1: "10 meters per hour",
                    2: "30 meters per hour",
                    3: "100 meters per hour",
                    4: "300 meters per hour",
                    "default": ""
                },
                "wealth": {
                    1: "cash equivalence of $300,000",
                    2: "Well off ($1M)",
                    3: "Moderately rich ($3M)",
                    4: "Very rich ($10M)",
                    5: "Extremely rich ($30M)",
                    6: "Moderately wealthy ($100M)",
                    "default": ""
                }
            };
        let characteristic = '';
        if (query.elevel === 0) {
            return characteristic = getTranslationByKey("not-configured");
        } else {
            switch(query.attribute) {
                case 'capacity':
                    const capacity_index = query.db.config.findIndex(c => c.name === 'capacity_type');
                    query.capacity_type = query.db.config[capacity_index].rank;
                    characteristic = (query.elevel < 11) ? 
                        chardb[`${query.attribute}`][query.capacity_type][query.elevel] || '' : 
                        query.selection === "cargo" ? 
                            `${((2 ** (query.elevel - 9)) * 100).toLocaleString()} tonnes` : 
                        query.selection === "carry" ? 
                            `+${((2 ** (query.elevel - 10)) * 1000).toLocaleString()} people` : '';
                break;
                case 'cognition':
                    characteristic = (query.elevel < 9) ? 
                        (chardb[`${query.attribute}`][query.elevel] || chardb[`${query.attribute}`]["default"]) : 
                        `Future: ${2 ** (query.elevel - 8)} years; Past: ${2 ** (query.elevel - 6)} years`;
                break;
                case 'data access':
                    characteristic = (query.elevel < 7) ? 
                        (chardb[`${query.attribute}`][query.elevel] || chardb[`${query.attribute}`]["default"]) : 
                        `${(10 ** (query.elevel - 5)).toLocaleString()} km radius`;
                break;
                case 'elasticity':
                    characteristic = (query.elevel < 7) ? 
                        (chardb[`${query.attribute}`][query.elevel] || chardb[`${query.attribute}`]["default"]) : 
                        `Stretch body up to ${(get1or3(query.elevel, 1) * (10 ** (Math.ceil((query.elevel - 4) / 2)))).toLocaleString()} km`;
                break;
                case 'features':
                    characteristic = (query.elevel < 3) ?
                        (chardb[`${query.attribute}`][query.elevel] || chardb[`${query.attribute}`]["default"]) : 
                        get1or2andHalfor5(query.elevel) * (10 ** (Math.ceil((query.elevel - 2) / 3)));
                    characteristic += ' features maximum';
                    query.c_index = query.config.findIndex(c => c.name === 'features');
                    characteristic += query.config.length !== 0 ? ': ' + query.config[query.c_index].rank.sort().join(", ") : '';
                break;
                case 'mind control':
                    characteristic = (query.elevel < 7) ? 
                        (chardb[`${query.attribute}`][query.elevel] || chardb[`${query.attribute}`]["default"]) : 
                        chardb[`${query.attribute}`][6];
                break;
                case 'minions':
                    characteristic = (query.elevel < 7) ? 
                    (chardb[`${query.attribute}`][query.elevel] || chardb[`${query.attribute}`]["default"]) : 
                    `Up to ${(400 * (query.elevel - 6)).toLocaleString()} Minions`;
                break;
                case 'plant control':
                    characteristic = (query.elevel < 7) ? 
                        (chardb[`${query.attribute}`][query.elevel] || chardb[`${query.attribute}`]["default"]) : 
                        `Control radius ${((10 ** (query.elevel - 5))).toLocaleString()} km, Growth ${(get1or3(query.elevel, 3) * (10 ** (Math.ceil((query.elevel - 4) / 2)))).toLocaleString()}x`;
                break;
                case 'pocket dimension':
                    characteristic = (query.elevel < 7) ? 
                        (chardb[`${query.attribute}`][query.elevel] || chardb[`${query.attribute}`]["default"]) : 
                        `Massive dimension (${((10 ** (query.elevel - 5))).toLocaleString()} km radius)`;
                break;
                case 'projection':
                    characteristic = (query.elevel < 7) ? 
                        (chardb[`${query.attribute}`][query.elevel] || chardb[`${query.attribute}`]["default"]) : 
                        `Massive-sized projection (${((10 ** (query.elevel - 5))).toLocaleString()} km radius)`;
                break;
                case 'size change':
                    query.config_index = query.config.findIndex(c => c.name === 'size change');
                    characteristic = (query.elevel < 11) ? query.config[query.config_index].rank === 'grow' ?
                        `Grow Size Ranks up by ${query.elevel}` : `Shrink Size Ranks down by ${query.elevel}` :
                        `Does not improve beyond level 10`;
                break;
                case 'supersense':
                    query.config_index = query.db.config.findIndex(c => c.name === 'supersense');
                    query.supersense = query.db.config[query.config_index].rank;
                    characteristic = `${
                        query.supersense === '' ? 'not configured' : query.supersense.capitalize()} ` +
                        `detection range ${query.elevel < 3 ? chardb[`${query.attribute}`][query.elevel] : ((10 ** (query.elevel - 3))).toLocaleString() + ' km'
                    }`;
                break;
                case 'superstrength':
                    characteristic = cache.rulebook === 'absolutepower' ? (
                        query.elevel === 1 ? '500 kg' : 
                        query.elevel === 2 ? '2 tonnes' :
                        ((get1or5or25(query.elevel) * (10 ** (Math.ceil((query.elevel - 2) / 3)))) * (query.elevel < 6 ? 1 : 10 ** Math.ceil((query.elevel - 5) / 3))).toLocaleString() + ' tonnes'
                    ) : (
                        query.elevel < 6 ? 
                        chardb[`${query.attribute}`][query.elevel] :
                        ((get1or2andHalfor5(query.elevel) * (10 ** (Math.ceil((query.elevel - 5) / 3))))).toLocaleString() + ' tonnes'
                    );
                    characteristic += `, +${(query.elevel * 5) * (cache.rulebook === 'absolutepower' ? 2 : 1)} unarmed damage`;
                    characteristic += `, +${(query.elevel * 1) * (cache.rulebook === 'absolutepower' ? 2 : 1)} DM with muscle weapons`;
                break;
                case 'taunt':
                    query.config_index = 
                        query.next === 'write_newattr' ? -1 :
                        query.config_index === undefined ? query.db.config.findIndex(c => c.name === 'taunt') : 
                        query.config_index;
                    query.roll_type = query.next === 'write_newattr' ?
                        'not configured' : query.db.config[query.config_index].rank
                    characteristic = chardb[query.attribute][query.elevel];
                    characteristic += query.elevel < 11 ?
                        ` - ${isEven(query.elevel) ?
                        'Opponent suffers a major obstacle with:' :
                        'Opponent suffers a minor obstacle with:'
                        } ${query.roll_type}` : '';
                break;
                case 'telekinesis':
                    characteristic = (query.elevel < 7) ? 
                        (chardb[`${query.attribute}`][query.elevel] || chardb[`${query.attribute}`]["default"]) : 
                        `${getTranslationByKey("can-move")} ${(10 ** (query.elevel - 4)).toLocaleString()} tonnes; ` +
                        `${(10 ** (query.elevel - 6)).toLocaleString()} tonne ${getTranslationByKey("objects-may-be-hurled-a-distance-of")} ${(get1or3(query.elevel, 1) * (10 ** (Math.ceil((query.elevel - 8) / 2)))).toLocaleString()} km ` +
                        `(${getTranslationByKey("weapon-level")} ${query.elevel - 2})`;
                break;
                case 'telepathy':
                    switch (query.elevel) {
                        case 0: characteristic = ''; break;
                        case 1:
                            characteristic = 
                                `${chardb[`${query.attribute}`][1][1]}; ` +
                                `${chardb[`${query.attribute}`][2][1]}`;
                        break;
                        case 2:
                            characteristic = 
                                `${chardb[`${query.attribute}`][1][2]}; ` +
                                `${chardb[`${query.attribute}`][2][2]}; ` +
                                `${chardb[`${query.attribute}`][3]}`;
                        break;
                        case 3:
                            characteristic = 
                                `${chardb[`${query.attribute}`][1][3]}; ` +
                                `${chardb[`${query.attribute}`][2][3]}; ` +
                                `${chardb[`${query.attribute}`][3]}; ` +
                                `${chardb[`${query.attribute}`][4]}; ` +
                                `${chardb[`${query.attribute}`][5]}`;
                        break;
                        case 4:
                            characteristic = 
                                `${chardb[`${query.attribute}`][1][3]}; ` +
                                `${chardb[`${query.attribute}`][2][4]} ${(get1or3(query.elevel, 3) * (10 ** (Math.ceil((query.elevel - 3) / 2)))).toLocaleString()}; ` +
                                `${chardb[`${query.attribute}`][3]}; ` +
                                `${chardb[`${query.attribute}`][4]}; ` +
                                `${chardb[`${query.attribute}`][5]}; ` +
                                `${chardb[`${query.attribute}`][6]}; ` +
                                `${chardb[`${query.attribute}`][7][1]}`;
                        break;
                        case 5:
                            characteristic = 
                                `${chardb[`${query.attribute}`][2][4]} ${(get1or3(query.elevel, 3) * (10 ** (Math.ceil((query.elevel - 3) / 2)))).toLocaleString()}; ` +
                                `${chardb[`${query.attribute}`][3]}; ` +
                                `${chardb[`${query.attribute}`][4]}; ` +
                                `${chardb[`${query.attribute}`][5]}; ` +
                                `${chardb[`${query.attribute}`][6]}; ` +
                                `${chardb[`${query.attribute}`][7][2]}; ` +
                                `${chardb[`${query.attribute}`][8]}`;
                        break;
                        case 6:
                            characteristic = 
                                `${chardb[`${query.attribute}`][2][4]} ${(get1or3(query.elevel, 3) * (10 ** (Math.ceil((query.elevel - 3) / 2)))).toLocaleString()}; ` +
                                `${chardb[`${query.attribute}`][3]}; ` +
                                `${chardb[`${query.attribute}`][4]}; ` +
                                `${chardb[`${query.attribute}`][5]}; ` +
                                `${chardb[`${query.attribute}`][6]}; ` +
                                `${chardb[`${query.attribute}`][7][3]}; ` +
                                `${chardb[`${query.attribute}`][8]}; ` +
                                `${chardb[`${query.attribute}`][9]}`;
                        break;
                        case 7:
                            characteristic = 
                                `${chardb[`${query.attribute}`][2][4]} ${(get1or3(query.elevel, 3) * (10 ** (Math.ceil((query.elevel - 3) / 2)))).toLocaleString()}; ` +
                                `${chardb[`${query.attribute}`][3]}; ` +
                                `${chardb[`${query.attribute}`][4]}; ` +
                                `${chardb[`${query.attribute}`][5]}; ` +
                                `${chardb[`${query.attribute}`][6]}; ` +
                                `${chardb[`${query.attribute}`][7][3]}; ` +
                                `${chardb[`${query.attribute}`][8]}; ` +
                                `${chardb[`${query.attribute}`][9]}; ` +
                                `${chardb[`${query.attribute}`][10][1]}`;
                        break;
                        case 8:
                            characteristic = 
                                `${chardb[`${query.attribute}`][2][4]} ${(get1or3(query.elevel, 3) * (10 ** (Math.ceil((query.elevel - 3) / 2)))).toLocaleString()}; ` +
                                `${chardb[`${query.attribute}`][3]}; ` +
                                `${chardb[`${query.attribute}`][4]}; ` +
                                `${chardb[`${query.attribute}`][5]}; ` +
                                `${chardb[`${query.attribute}`][6]}; ` +
                                `${chardb[`${query.attribute}`][7][3]}; ` +
                                `${chardb[`${query.attribute}`][8]}; ` +
                                `${chardb[`${query.attribute}`][9]}; ` +
                                `${chardb[`${query.attribute}`][10][2]}`;
                        break;
                        case 9:
                            characteristic = 
                                `${chardb[`${query.attribute}`][2][4]} ${(get1or3(query.elevel, 3) * (10 ** (Math.ceil((query.elevel - 3) / 2)))).toLocaleString()}; ` +
                                `${chardb[`${query.attribute}`][3]}; ` +
                                `${chardb[`${query.attribute}`][4]}; ` +
                                `${chardb[`${query.attribute}`][5]}; ` +
                                `${chardb[`${query.attribute}`][6]}; ` +
                                `${chardb[`${query.attribute}`][7][3]}; ` +
                                `${chardb[`${query.attribute}`][8]}; ` +
                                `${chardb[`${query.attribute}`][9]}; ` +
                                `${chardb[`${query.attribute}`][10][3]}`;
                        break;
                        case 10:
                            characteristic = 
                                `${chardb[`${query.attribute}`][2][4]} ${(get1or3(query.elevel, 3) * (10 ** (Math.ceil((query.elevel - 3) / 2)))).toLocaleString()}; ` +
                                `${chardb[`${query.attribute}`][3]}; ` +
                                `${chardb[`${query.attribute}`][4]}; ` +
                                `${chardb[`${query.attribute}`][5]}; ` +
                                `${chardb[`${query.attribute}`][6]}; ` +
                                `${chardb[`${query.attribute}`][7][3]}; ` +
                                `${chardb[`${query.attribute}`][8]}; ` +
                                `${chardb[`${query.attribute}`][9]}; ` +
                                `${chardb[`${query.attribute}`][10][4]}`;
                        break;
                        case 11:
                            characteristic = 
                                `${chardb[`${query.attribute}`][2][4]} ${(get1or3(query.elevel, 3) * (10 ** (Math.ceil((query.elevel - 3) / 2)))).toLocaleString()}; ` +
                                `${chardb[`${query.attribute}`][3]}; ` +
                                `${chardb[`${query.attribute}`][4]}; ` +
                                `${chardb[`${query.attribute}`][5]}; ` +
                                `${chardb[`${query.attribute}`][6]}; ` +
                                `${chardb[`${query.attribute}`][7][3]}; ` +
                                `${chardb[`${query.attribute}`][8]}; ` +
                                `${chardb[`${query.attribute}`][9]}; ` +
                                `${chardb[`${query.attribute}`][10][5]}`;
                        break;
                        default:
                            characteristic = 
                                `${chardb[`${query.attribute}`][2][4]} ${(get1or3(query.elevel, 3) * (10 ** (Math.ceil((query.elevel - 3) / 2)))).toLocaleString()}; ` +
                                `${chardb[`${query.attribute}`][3]}; ` +
                                `${chardb[`${query.attribute}`][4]}; ` +
                                `${chardb[`${query.attribute}`][5]}; ` +
                                `${chardb[`${query.attribute}`][6]}; ` +
                                `${chardb[`${query.attribute}`][7][3]}; ` +
                                `${chardb[`${query.attribute}`][8]}; ` +
                                `${chardb[`${query.attribute}`][9]}; ` +
                                `${chardb[`${query.attribute}`][10][6]} ${(get1or3(query.elevel, 1) * (10 ** (Math.ceil((query.elevel - 12) / 2)))).toLocaleString()}`;
                    }
                break;
                case 'teleport':
                    characteristic = (query.elevel < 3) ? 
                        (chardb[`${query.attribute}`][query.elevel] || chardb[`${query.attribute}`]["default"]) : 
                        `${(10 ** (query.elevel - 3)).toLocaleString()} km`;
                break;
                case 'tunneling':
                    const highlevel = `${(get1or3(query.elevel, 1) * (10 ** (Math.ceil((query.elevel - 6) / 2)))).toLocaleString()} kph`;
                    characteristic = (query.elevel < 5) ? 
                        (chardb[`${query.attribute}`][query.elevel] || chardb[`${query.attribute}`]["default"]) : highlevel;
                break;
                case 'wealth':
                    characteristic = `cash equivalence of $${(get1or3(query.elevel, 3) * (10 ** (Math.ceil((query.elevel + 9) / 2)))).toLocaleString()}`;
                break;
                default:
                    characteristic = 
                        (chardb[`${query.attribute}`][query.elevel] || chardb[`${query.attribute}`]["default"]) || '';
            }
        }
        return characteristic;
    }
    
    function getConfigurationByCustomization(cache, query) {
        const customizations = {
            "complete":'complete_resilience',
            "emphasized":'damage_type',
            "group":'group',
            "optimized":'damage_type',
            "focussed damage":'weapon_class',
            "targeted":'enemy',
            "targeted damage":'enemy',
            "species":'species',
        };
        return customizations[query.customization[0]] || false;
    }

    function customizationHasRank(query) {
        const customizations = [
            'acceleration',
            'accurate',
            'activation',
            'ammo',
            'area',
            'assisted',
            'backblast',
            'backlash',
            'blight',
            'charges',
            'complete',
            'contact',
            'concentration',
            'consumable',
            'contagious',
            'continuing',
            'delay',
            'dependent',
            'deplete',
            'detectable',
            'drain',
            'duration',
            'emotional',
            'enervation',
            'environmental',
            'equipment',
            'exclusive',
            'extra sense',
            'flare',
            'flexible',
            'haywire',
            'homing',
            'ignore',
            'imbue',
            'innacurate',
            'incapacitating',
            'incurable',
            'irreversible',
            'irritant',
            'knockback',
            'lethargy',
            'localized',
            'maximum',
            'multiple illusions',
            'non-penetrating',
            'object',
            'penetrating',
            'permanent',
            'piercing',
            'potent',
            'quake',
            'range',
            'recovery',
            'semi-permanent',
            'spreading',
            'stoppable',
            'tangle',
            'targets',
            'targeted',
            'timed',
            'toxic',
            'unique',
            'unpredictable',
            'unreliable',
            'vampiric'
        ];
        return customizations.indexOf(query.customization[0]) !== -1;
    }

    /* Defect Functions */
    function applyShortcomingObstacle(cache, query) {
        let result = false;
        for (let i = 0; i < cache.defectdb.shortcoming.length; i++) {
            for (let j = 0; j < query.shortcoming.stats.length; j++) {
                if (
                    cache.defectdb.shortcoming[i].config[1].rank !== 'all' &&
                    query.shortcoming.stats[j] === cache.defectdb.shortcoming[i].config[0].rank
                ) {
                    result = true;
                    break;
                }
            }
            if (result) { break; }
        }
        return result;
    }

    async function setShortcomingAspectTypeAll(cache, set_values, query = {}) {
        const temp = Object.assign({}, query);
        clog(cache, temp, 'setShortcomingAspectTypeAll()');
        if (isObjectEmpty(query)) {
            temp.index = cache.defectdb.shortcoming.findIndex(i => i.row_id.toLowerCase() === cache.source_id);
            temp.rank = cache.defectdb.shortcoming[temp.index].rank;
        } else {
            temp.rank = temp.level;
        }
        temp.aspect_index = cache.defectdb.shortcoming[temp.index].config.findIndex(i => i.name === 'aspect_stat');
        temp.aspect_stat = cache.defectdb.shortcoming[temp.index].config[temp.aspect_index].rank;
        cache.statsdb[temp.aspect_stat].shortcoming = temp.rank;
        set_values[`static_character_${temp.aspect_stat}_remaining`] =
            cache.statsdb[temp.aspect_stat].base +
            (cache.statsdb[temp.aspect_stat].augmented || 0) +
            cache.statsdb[temp.aspect_stat].temp -
            cache.statsdb[temp.aspect_stat].damage -
            int(`${
                cache.defectdb.shortcoming[temp.index].active ? 
                cache.statsdb[temp.aspect_stat].shortcoming || 0 : 0
            }`);
        await setDerivedValues(cache, set_values);
    }

    /* Button Functions */
    function setAccordion(cache, set_values) {
        // Note: 0 == closed, 1 == opened
        const temp = {};
        clog(cache, temp, 'setAccordion()');
        temp[`${cache.source_path}_state`] = 
            int(cache[`${cache.source_path}_state`]) === 1 ? 0 : 1;
        Object.assign(set_values, temp);
    }

    function setAttributeAccordions(cache, set_values) {
        // Note: 0 == closed, 1 == opened
        const temp = {};
        clog(cache, temp, 'setAttributeAccordions()');
        const global_state = int(cache.static_attributes_accordions_state);
        temp.static_attributes_accordions_state = global_state === 0 ? 1 : 0;
        for (let i = 0; i < cache.attribute_ids.length; i++) {
            temp[`repeating_attribute_${cache.attribute_ids[i]}_state`] = temp.static_attributes_accordions_state;
        }
        for (let i = 0; i < cache.defect_ids.length; i++) {
            temp[`repeating_defect_${cache.defect_ids[i]}_state`] = temp.static_attributes_accordions_state;
        }
        Object.assign(set_values, temp);
    }

    function setRollAccordions(cache, set_values) {
        // Note: 0 == closed, 1 == opened
        const temp = {};
        clog(cache, temp, 'setRollAccordions()');
        const global_state = int(cache.static_roll_accordions_state);
        temp.static_roll_accordions_state = global_state === 0 ? 1 : 0;
        /*
        for (let i = 0; i < cache.roll_ids.length; i++) {
            temp[`repeating_roll_${cache.roll_ids[i]}_state`] = temp.static_roll_accordions_state;
        }
        */
        Object.assign(set_values, temp);
    }

    function setSkillAccordions(cache, set_values) {
        // Note: 0 == closed, 1 == opened
        const temp = {};
        clog(cache, temp, 'setSkillAccordions()');
        const global_state = int(cache.static_skills_accordions_state);
        temp.static_skills_accordions_state = global_state === 0 ? 1 : 0;
        for (let i = 0; i < cache.skill_ids.length; i++) {
            temp[`repeating_skill_${cache.skill_ids[i]}_state`] = temp.static_skills_accordions_state;
        }
        Object.assign(set_values, temp);
    }

    async function getDice(cache, query, roll) {
        const temp = {};
        clog(cache, temp, 'getDice()');
        if (cache.source_attribute === 'rollmacro') {
            query.selection = cache.rolldb[query.macro_index].modifier;
        } else {
            query.title = 'Roll is';
            query.options = 
                `|Normal,0` +
                `|Minor Edge,1` +
                `|Minor Obstacle,-1` +
                `|Major Edge,2` +
                `|Major Obstacle,-2`;
            await crpQuery(cache, query);
        }
        const exceed2dice =
            cache.rulesdb.rules_optional_dice_status === 'exceed' ? true : false;
        temp.string = '{{total=[[';
        temp.d6 = ' [[1d6]]+[[1d6]]';
        temp.d6_value = ' {{dice0=$[[0]]}} {{dice1=$[[1]]}}';
        temp.extra_dice = int((roll.mod.edge || 0) + (roll.mod.obstacle || 0 * -1) + int(query.selection));
        temp.dice_type = temp.extra_dice === 0 ? 'normal' : 
            temp.extra_dice > 0 ? 'edge' : 'obstacle';
        temp.extra_dice = temp.extra_dice < 0 ? temp.extra_dice * -1 : temp.extra_dice;
        temp.ndice = temp.extra_dice > 1 ?
                exceed2dice ? temp.extra_dice + 2 : 4 : 
            temp.extra_dice === 1 ? 3 : 2;
        for (let i = 2; i < temp.ndice; i++) {
            temp.d6 += '+[[1d6]]';
            temp.d6_value += ` {{dice${i}=$[[${i}]]}}`;
        }
        temp.string += `${temp.d6} ]]}} ${temp.d6_value}`;
        roll.dice = {
            number: temp.ndice,
            type: temp.dice_type,
        }
        return temp.string;
    }

    async function toggleRuleSetting(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'toggleRuleSetting()');
        temp.setting = cache.newValue !== undefined ?
            cache.newValue :
            int(cache.rulesdb[`${cache.source_path}_status`]) === 1 ? 0 : 1;
        if (cache.source_id === 'shockvalue') {
            if (!temp.setting) {
                set_values.rules_optional_knockout_status = temp.setting;
                set_values.rules_optional_seriousinjury_status = temp.setting;
                set_values.rules_attribute_hardboiled_status = temp.setting;
                set_values.rules_optional_knockout_icon = '_';
                set_values.rules_optional_seriousinjury_icon = '_';
                set_values.rules_attribute_hardboiled_icon = '_';
                cache.rulesdb.rules_optional_knockout_status = temp.setting;
                cache.rulesdb.rules_optional_seriousinjury_status = temp.setting;
                cache.rulesdb.rules_attribute_hardboiled_status = temp.setting;
            } else if (temp.setting && 
                    (
                        cache.static_rules_base_default === 'besmx' ||
                        cache.static_rules_base_default === 'absolutepower'
                    )
                ) {
                    set_values.rules_attribute_hardboiled_status = temp.setting;
                    set_values.rules_attribute_hardboiled_icon = '3';
                    cache.rulesdb.rules_attribute_hardboiled_status = temp.setting;
                }
        }
        if (
            cache.source_id === 'knockout' ||
            cache.source_id === 'seriousinjury' ||
            cache.source_id === 'hardboiled'
        ) {
            if (temp.setting) {
                set_values.rules_optional_shockvalue_status = temp.setting;
                set_values.rules_optional_shockvalue_icon = '3';
                cache.rulesdb.rules_optional_shockvalue_status = temp.setting;
            }
        }
        cache.rulesdb[`${cache.source_path}_status`] = temp.setting;
        if (cache.newValue === undefined) {
            set_values[`${cache.source_path}_status`] = temp.setting;
            set_values[`${cache.source_path}_icon`] = temp.setting === 1 ?
                '3' : '_';
        }
        set_values.rulesdb = JSON.stringify(cache.rulesdb);
    }

    async function selectTarget(cache, roll) {
        const rxGrab = /^0\[(.*)\]\s*$/;
        const temp = {};
        clog(cache, temp, 'selectTarget()');
        temp.template = `! ` +
            `{{charname=[[0[@{target|character_name}] ]]}} ` +
            `{{charid=[[0[@{target|character_id}] ]]}} ` +
            `{{attrdb=[[0[@{target|attrdb}] ]]}} ` +
            `{{defectdb=[[0[@{target|defectdb}] ]]}}`;
        temp.roll = await startRoll(temp.template);
        roll.target.name = 
            temp.roll.results.charname.expression.match(rxGrab)[1];
        roll.target.id = 
            temp.roll.results.charid.expression.match(rxGrab)[1];
        roll.target.attrdb = 
            temp.roll.results.attrdb.expression.match(rxGrab)[1];
        roll.target.defectdb = 
            temp.roll.results.defectdb.expression.match(rxGrab)[1];
        finishRoll(temp.roll.rollId);
    }

    function getStatsRemaining(cache, stats) {
        const temp = [];
        clog(cache, temp, `getStatsRemaining(${stats})`);
        for (let i = 0, n = stats.length; i < n; i++) {
            temp[i] = 
                cache.statsdb[stats[i]].base +
                (cache.statsdb[stats[i]].augmented || 0) +
                cache.statsdb[stats[i]].temp -
                cache.statsdb[stats[i]].damage - (
                    stats[i] === 'health' ? 
                    cache.statsdb.health.stun : 0
                ) -
                (cache.statsdb[stats[i]].shortcoming || 0);
        }
        return temp;
    }

    function getCV(cache, cv) {
        const temp = {};
        clog(cache, temp, `getCV(${cv})`);
        temp.cv = 0;
        for (let i = 0; i < 3; i++) {
            temp.cv += 
                cache.statsdb[all_stats[i]].base +
                cache.statsdb[all_stats[i]].temp -
                cache.statsdb[all_stats[i]].damage -
                (cache.statsdb[all_stats[i]].shortcoming || 0);
        }
        temp.cv += cache.attrdb.augmented.length !== 0 ?
            cache.attrdb.augmented.map(m => m.active ? m.elevel : 0).reduce((m, n) => m + n, 0) : 0;
        temp.cv = Math.round(temp.cv/3);
        return temp.cv;
    }

    async function actionRoll(cache, set_values) {
        const roll = { // contains all data relevant to the roll
            base: 0,
            enemies: [],
            mod: {
                edge: 0,
                obstacle: 0
            },
            stat: [],
            template: '&{template:rolls}' +
                ' {{pronoun=@{static_character_details_pronoun}}}' +
                ' {{character_name=@{static_character_details_name}}}',
            weapon: {
                range: 0,
            },
        };
        const query = { // contains data for the roll itself
            answer: false,
            do_roll: false,
            get: {},
            get_attrs: [],
            values: []
        };
        clog(cache, roll, 'actionRoll(roll)');
        clog(cache, query, 'actionRoll(query)');
        if (cache.source_type === 'react') {
            roll.attacker = rollEscape.unescape(cache.originalRollId);
        }
        if (cache.source_attribute === 'rollmacro') {
            query.macro_index = cache.rolldb.findIndex(r => r.id === cache.originalCaseRowID);
        }
        roll.type = cache.source_attribute === 'rollmacro' ?
            cache.rolldb[query.macro_index].type === 'skill' ?
                cache.rulesdb.rules_optional_individual_status !== 0 ? 'skill' : 'skill_group' :
            cache.rolldb[query.macro_index].type :
            cache.source_type === 'react' ? 
            cache.source_attribute === 'skill' ?
                cache.rulesdb.rules_optional_individual_status !== 0 ? 'skill' : 'skill_group' :
            cache.source_attribute :
            cache.source_id === 'skill' ?
                cache.rulesdb.rules_optional_individual_status !== 0 ? 'skill' : 'skill_group' :
            cache.source_id;
        if (cache.source_type === 'react' && roll.type === 'skill' && cache.attrdb.skills.length === 0) {
            roll.type = 'stat';
            query.next = 'stat';
        }
        const color = cache.rulebook === 'besmx' ? 'besm' : cache.rulebook;
        if (roll.type === 'attribute' || roll.type === 'attack' || roll.type === 'defense') {
            query.attributes = [];
            const filtered_attributes = all_attributes.map(a => {
                return (a === 'skills' || a === 'skill group'|| a === 'weapon') ? '' : a;
            }).filter(n => n);
            for (let i = 0; i < filtered_attributes.length; i++) {
                for (let j = 0; j < cache.attrdb[filtered_attributes[i]].length; j++) {
                    const attribute = cache.attrdb[filtered_attributes[i]][j];
                    if (attribute.active && attribute.stat !== 'none') {
                        query.attributes.length = query.attributes.push(
                            `|${attribute.name === '' ? filtered_attributes[i].capitalize() : attribute.name.capitalize()},` +
                            `${filtered_attributes[i]}~${j}`
                        );
                        roll.is_swarm = filtered_attributes[i] === 'swarm';
                        if (roll.is_swarm) {
                            query.elevel = cache.attrdb.swarm[j].elevel;
                        }
                    }
                }
            }
        }
        roll.template += cache.source_type === 'react' ?
            ` {{color=color-react-${color}}} {{color-react=color-${color}}}` :
            ` {{color=color-${color}}} {{color-react=color-react-${color}}}`;
        query.next = roll.type;
        while (!query.do_roll) {
            switch(query.next) {
                // 1st tier roll options
                case '2d6':
                    query.title = '';
                    query.do_roll = true;
                    roll.template += ' {{twodsix=1}}' +
                        ` {{title=${getTranslationByKey("roll")} 2d6}}`;
                    roll.cv = 0;
                break;
                case 'attack':
                    query.title = '';
                    roll.template += ' {{attack=1}}' +
                        ` {{title=${getTranslationByKey("attack")}}}`;
                    query.last = query.next;
                break;
                case 'attribute':
                    if (cache.source_attribute === 'rollmacro') {
                        query.title = '';
                        const attr_name = cache.rolldb[query.macro_index].attribute.name;
                        const attr_id = cache.rolldb[query.macro_index].attribute.id;
                        const attr_index = cache.attrdb[attr_name].findIndex(a => a.row_id === attr_id);
                        query.selection = `${attr_name}~${attr_index}`;
                    } else {
                        query.title = `${getTranslationByKey("select-attribute")}`;
                        query.options = query.attributes.sort().join('');
                        query.options +=
                            `|${getTranslationByKey("exit")},exit`;
                    }
                    query.last = query.next;
                break;
                case 'defense':
                    query.title = '';
                    roll.template += ` {{attack=1}} ` +
                        `{{title=${getTranslationByKey("defense")}}}`;
                    query.last = query.next;
                break;
                case 'select_weapon':
                    if (cache.source_attribute === 'rollmacro') {
                        query.title = '';
                    } else {
                        query.has_weapons = cache.attrdb.weapon.length;
                        if (
                            (
                                roll.type === 'defense' &&
                                query.has_weapons === 0 &&
                                roll.attacker.weapon.range === 0
                            ) || roll.is_swarm
                        ) {
                            query.title = '';
                            query.selection = 'unarmed';
                            break;
                        }
                        query.has_deflection = false;
                        if (roll.type === 'defense') {
                            cache.attrdb['combat technique'].forEach(a => {
                                for (let i = 0; i < a.config.length; i++) {
                                    if (
                                        a.config[i].name === 'deflection' &&
                                        a.active
                                    ) {
                                        query.has_deflection = true;
                                    }
                                }
                            });
                        }
                        query.title = roll.type === 'attack' ?
                            `${getTranslationByKey("choose-attack")}` :
                            `${getTranslationByKey("choose-defense")}`;
                        query.options = '';
                        if (query.has_weapons) {
                            if (
                                roll.type === 'attack' || (
                                    roll.type === 'defense' &&
                                    roll.attacker.weapon.range === 0
                                ) || (
                                    roll.type === 'defense' &&
                                    roll.attacker.weapon.range !== 0 &&
                                    query.has_deflection
                                )
                            ) {
                                const weapons = [];
                                for (let i = 0; i < cache.attrdb.weapon.length; i++) {
                                    const ranged_weapon =
                                        cache.attrdb.weapon[i].enhancements.findIndex(e => e.name === 'range');
                                    const weapon_name = cache.attrdb.weapon[i].name === '' ?
                                        getTranslationByKey("weapon") : cache.attrdb.weapon[i].name;
                                    if (cache.attrdb.weapon[i].active && roll.type === 'attack') {
                                        weapons.push(`${weapon_name},${i}`);
                                    } else if (
                                        cache.attrdb.weapon[i].active && 
                                        roll.type === 'defense' &&
                                        roll.attacker.weapon.range === 0 &&
                                        ranged_weapon === -1
                                    ) {
                                        weapons.push(`${weapon_name},${i}`);
                                    } else if (
                                        cache.attrdb.weapon[i].active && 
                                        roll.type === 'defense' &&
                                        roll.attacker.weapon.range !== 0 &&
                                        query.has_deflection
                                    ) {
                                        if (query.options === '') {
                                            query.options += `|${getTranslationByKey("deflection")},` +
                                            `?{${getTranslationByKey("choose-weapon")}`;
                                        }
                                        query.options += `&#124;${weapon_name}&#44;${i}`;
                                        if (i === n-1) {
                                            query.options += `&#124;${getTranslationByKey("go-back")}&#44;select_weapon&#125;`;
                                        }
                                    }
                                }
                                query.options = `|${weapons.sort().join("|")}`;
                            }
                        }
                        if (
                            roll.type === 'defense' &&
                            roll.attacker.weapon.range !== 0
                        ) {
                            query.options += 
                                `|${getTranslationByKey("personal")},personal` +
                                `|${getTranslationByKey("movement")},movement`;
                        }
                        query.options += (
                            roll.type === 'attack' || (
                                roll.type === 'defense' &&
                                roll.attacker.weapon.range === 0
                            ) || (
                                roll.type === 'defense' &&
                                roll.attacker.weapon.range !== 0 &&
                                query.has_deflection
                            )
                        ) ? `|${getTranslationByKey("unarmed")},unarmed` : '';
                        query.options += query.attributes.length !== 0 && roll.type === 'defense' ?
                            `|${getTranslationByKey("attribute")},attribute` : '';
                        query.options += roll.type === 'attack' ? 
                            `|${getTranslationByKey("touch")},touch` +
                            `|${getTranslationByKey("go-back")},rollsroot` : '';
                    }
                    query.last = query.next;
                break;
                case 'is_enemy':
                    if (cache.source_attribute === 'rollmacro') {
                        query.title = '';
                        if (cache.rolldb[query.macro_index].enemy !== '') {
                            roll.enemies.push(cache.rolldb[query.macro_index].enemy);
                        }
                        query.selection = 'done';
                    } else {
                        if (roll.enemies.length === 0) {
                            const enemy_attributes = [];
                            const enemy_defects = [];
                            query.enemies = [];
                            roll.enemies = [];
                            if (roll.type === 'attack') {
                                enemy_attributes.push('enemy attack','massive damage','weapon');
                                enemy_defects.push('inept attack');
                            } else {
                                enemy_attributes.push('enemy defense','weapon');
                                enemy_defects.push('inept defense');
                            }
                            for (let i = 0; i < enemy_attributes.length; i++) {
                                for (let j = 0; j < cache.attrdb[enemy_attributes[i]].length; j++) {
                                    const enemy_index = cache.attrdb[enemy_attributes[i]][j].active ?
                                        cache.attrdb[enemy_attributes[i]][j].config.findIndex(c => c.name === 'enemy') : -1;
                                    if (enemy_index !== -1) {
                                        const enemy_name = cache.attrdb[enemy_attributes[i]][j].config[enemy_index].rank;
                                        if (query.enemies.findIndex(e => e.toLowerCase() === enemy_name.toLowerCase()) === -1) {
                                            query.enemies.push(enemy_name);
                                        }
                                    }
                                }
                            }
                            for (let i = 0; i < enemy_defects.length; i++) {
                                for (let j = 0; j < cache.defectdb[enemy_defects[i]].length; j++) {
                                    const enemy_index = cache.defectdb[enemy_defects[i]][j].active ?
                                        cache.defectdb[enemy_defects[i]][j].config.findIndex(c => c.name === 'enemy') : -1;
                                    if (enemy_index !== -1) {
                                        const enemy_name = cache.defectdb[enemy_defects[i]][j].config[enemy_index].rank;
                                        if (query.enemies.findIndex(e => e.toLowerCase() === enemy_name.toLowerCase()) === -1) {
                                            query.enemies.push(enemy_name);
                                        }
                                    }
                                }
                            }
                        }
                        if (query.enemies.length !== 0) {
                            const enemies = [...query.enemies].map(e => e.toLowerCase()).sort();
                            if (enemies.length === 1) {
                                query.title = 
                                    `${getTranslationByKey("does-this-roll-apply-to-enemy")} ` +
                                    `${enemies[0].capitalize()}?`;
                                query.options = 
                                    `|${getTranslationByKey("no")},no` +
                                    `|${getTranslationByKey("yes")},${enemies[0]}`;
                            } else {
                                query.title =
                                    `${getTranslationByKey("select-enemies-this-roll-applies-to")}`;
                                query.options = roll.enemies.length === 0 ?
                                    `|${getTranslationByKey("none")},no` : `|${getTranslationByKey("done")},done`;
                                query.options += '|' + enemies.map(e => {
                                    const bracket = roll.enemies.findIndex(r => r.name === e) !== -1;
                                    return `${bracket ? '[' : ''}${e.capitalize()}${bracket ? ']' : ''},${e}`;
                                }).join('|');
                            }
                        } else {
                            query.title = '';
                            query.options = '';
                            query.selection = 'done';
                        }
                    }
                    query.last = query.next;
                break;
                case 'combat_maneuver':
                    roll.target.has_gap = false;
                    roll.target.has_weak_point = 0;
                    if (cache.source_attribute === 'rollmacro') {
                        query.title = '';
                        query.selection = cache.rolldb[query.macro_index].maneuver;
                    } else {
                        if (cache.rulesdb.rules_optional_maneuvers_status) {
                            if (query.target === 'opposed_roll') {
                                if (roll.target.attrdb.armor.length !== 0) {
                                    for (let i = 0; i < roll.target.attrdb.armor.length; i++) {
                                        if (roll.target.attrdb.armor[i].active) {
                                            const gap_index = roll.target.attrdb.armor[i].limiters.findIndex(c => c.name === 'gap');
                                            if (gap_index !== -1) {
                                                roll.target.has_gap = true;
                                                i = roll.target.attrdb.armor.length;//=> only support first active armor.
                                            }
                                        }
                                    }
                                }
                                if (roll.target.defectdb['weak point'].length !== 0) {
                                    for (let i = 0; i < roll.target.defectdb['weak point'].length; i++) {
                                        if (roll.target.defectdb['weak point'][i].active) {
                                            roll.target.has_weak_point = roll.target.defectdb['weak point'][i].level;
                                            i = roll.target.defectdb['weak point'].length;//=> only support first weak point.
                                        }
                                    }
                                }
                            }
                            query.title = `${getTranslationByKey("select-maneuver")}`;
                            query.options = `|${getTranslationByKey("attack")},attack`;
                            if (cache.rulesdb.rules_optional_maneuvers_status) {
                                query.options +=
                                    `|${getTranslationByKey("called-shot")},?{${getTranslationByKey("select-called-shot")}`;
                                    query.options += roll.target.has_gap ?
                                        `&#124;${getTranslationByKey("bypass-armor")}&#44;bypass armor` : '';
                                    query.options += 
                                        `&#124;${getTranslationByKey("disarm")}&#44;disarm`;
                                    query.options += cache.rulesdb.rules_optional_knockout_status ?
                                        `&#124;${getTranslationByKey("knockout")}&#44;knockout` : '';
                                    query.options += roll.target.has_gap ?
                                        `&#124;${getTranslationByKey("reduce-armor")}&#44;reduce armor` : '';
                                    query.options +=
                                        `&#124;${getTranslationByKey("specific-location")}&#44;specific location` +
                                        `&#124;${getTranslationByKey("vital-spot")}&#44;vital spot`;
                                    query.options += roll.target.has_weak_point ?
                                        `&#124;${getTranslationByKey("weak-point")}&#44;weak point` : '';
                                    query.options += '&#125;';
                            }
                            if (!roll.weapon.range && cache.rulesdb.rules_optional_maneuvers_status) {
                                query.options +=
                                    `|${getTranslationByKey("grapple")},?{${getTranslationByKey("select-grapping-maneuver")}` +
                                        `&#124;${getTranslationByKey("bite")}&#44;bite` +
                                        `&#124;${getTranslationByKey("grab")}&#44;grab` +
                                        `&#124;${getTranslationByKey("lock")}&#44;lock` +
                                        `&#124;${getTranslationByKey("pin")}&#44;pin` +
                                        `&#124;${getTranslationByKey("throw")}&#44;throw&#125;`;
                            }
                            query.options += `|${getTranslationByKey("go-back")},select_weapon`;
                        } else {
                            query.title = '';
                            query.selection = 'attack';
                        }
                    }
                    query.last = query.next;
                break;
                case 'specific location':
                    query.title = `${getTranslationByKey("specify-location")}`;
                    query.options =
                        `|${getTranslationByKey("large-spot")},large spot` +
                        `|${getTranslationByKey("small-spot")},small spot` +
                        `|${getTranslationByKey("tiny-spot")},tiny spot`;
                    query.last = query.next;
                break;
                case 'target_type':
                    if (cache.source_attribute === 'rollmacro') {
                        query.title = '';
                        query.selection = cache.rolldb[query.macro_index].target;
                    } else {
                        query.title = `${getTranslationByKey("select-target-type")}`;
                        query.options = 
                            `|${getTranslationByKey("opposed-roll")},target_select` +
                            `|${getTranslationByKey("target-number")},target_number` +
                            `|${getTranslationByKey("go-back")},${(
                                cache.rulesdb.rules_optional_maneuvers_status &&
                                roll.type === 'attack'
                            ) ? 'combat_maneuver' : 'select_weapon'
                            }`;
                    }
                    query.last = query.next;
                break;
                case 'target_select':
                    query.title = '';
                    await selectTarget(cache, roll);
                    roll.target.attrdb = JSON.parse(roll.target.attrdb);
                    roll.target.defectdb = JSON.parse(roll.target.defectdb);
                    query.last = query.next;
                break;
                case 'ranged_combat_maneuver':
                    query.title = `${getTranslationByKey("select-maneuver")}`;
                    query.options = 
                        `|${getTranslationByKey("attack")},attack` +
                        `|${getTranslationByKey("specific-location")},?{${getTranslationByKey("specify-location")}` +
                        `&#124;${getTranslationByKey("large-spot")}&#44;15` +
                        `&#124;${getTranslationByKey("small-spot")}&#44;18` +
                        `&#124;${getTranslationByKey("tiny-spot")}&#44;21&#125;`;
                    query.last = query.next;
                break;
                case 'target_number':
                    query.title = 'Enter Target Number';
                    query.options = `|${int(query.tn)}`;
                    query.last = query.next;
                break;
                case 'initiative':
                    query.title = '';
                    query.do_roll = true;
                    roll.template += ' {{initiative=1}} {{title=Initiative}}';
                break;
                case 'skill_group':
                    if (cache.source_attribute === 'rollmacro') {
                        query.title = '';
                        const skill_id = cache.rolldb[query.macro_index].attribute.id;
                        const skill_index = cache.attrdb['skill group'].findIndex(s => s.row_id === skill_id);
                        query.skilldb = cache.attrdb['skill group'][skill_index];
                        query.skill_groups = [{
                            name: query.skilldb.name,
                            elevel: query.skilldb.elevel,
                        }];
                        query.index = skill_index;
                        query.name = getTranslationByKey(`${query.skilldb.name.toKebobCase()}`);
                        query.level = query.skilldb.elevel;
                    } else {
                        query.title = `Select Skill Group`;
                        query.skill_groups = [];
                        for (let i = 0; i < all_skill_groups.length; i++) {
                            const skill_group = { name: '', elevel: 0 };
                            for (let j = 0; j < cache.attrdb['skill group'].length; j++) {
                                if (cache.attrdb['skill group'][j].name.toLowerCase() === all_skill_groups[i]) {
                                    skill_group.name = all_skill_groups[i];
                                    skill_group.elevel += cache.attrdb['skill group'][j].elevel;
                                }
                            }
                            if (skill_group.name !== '') { query.skill_groups.push(skill_group); }
                        }
                        query.options = query.skill_groups.map((s, i) => `|${
                            getTranslationByKey(s.name.toKebobCase())
                        },${i}`).join('');
                        query.options += `|${getTranslationByKey("go-back")},rollsroot`;
                    }
                    query.last = query.next;
                break;
                case 'skill':
                    if (cache.source_attribute === 'rollmacro') {
                        query.title = '';
                        const id = cache.rolldb[query.macro_index].attribute.id;
                        const skill_index = cache.attrdb.skills.findIndex(s => s.row_id === id);
                        const skill_id = cache.rolldb[query.macro_index].attribute.skill_id;
                        const individual_index = cache.attrdb.skills[skill_index].individual.findIndex(s => s.row_id === skill_id);
                        query.skilldb = cache.attrdb.skills[skill_index].individual[individual_index];
                        query.skills = [{spec: []}];
                        query.selection = 0;
                    } else {
                        query.title = `Select Skill`;
                        query.skills = [];
                        for (let i = 0; i < all_skills.length; i++) {
                            const skill = { name: '', rank: 0, spec: [], stat: [] };
                            for (let j = 0; j < cache.attrdb.skills.length; j++) {
                                const individual = cache.attrdb.skills[j].individual;
                                for (let k = 0; k < individual.length; k++) {
                                    if (individual[k].skill === all_skills[i]) {
                                        skill.name = individual[k].skill;
                                        skill.rank += individual[k].rank;
                                        skill.spec = [...new Set([...skill.spec, ...individual[k].specializations])].sort();
                                        skill.stat = skill.stat.length === 0 ? individual[k].stat :
                                            arraysAreEqual(skill.stat, individual[k].stat) ? skill.stat : [];
                                    }
                                }
                            }
                            if (skill.name !== '') { query.skills.push(skill); }
                        }
                        query.options = query.skills.map((s, i) => `|${
                            getTranslationByKey(s.name.toKebobCase())
                        },${i}`).join('');
                        query.options += `|${getTranslationByKey("exit")},exit`;
                    }
                    if (query.skills.length === 0) {
                        query.title = '';
                        clog(cache, 'No skills found', 'ERROR');
                        query.selection = 'exit';
                        query.skills.push({spec:[]});
                    } else {
                        query.title = `Select Skill`;
                        query.options = query.skills.map((s, i) => `|${
                            getTranslationByKey(s.name.toKebobCase())
                        },${i}`).join('');
                        query.options += `|${getTranslationByKey("exit")},exit`;
                    }
                    query.last = query.next;
                break;
                case 'specialization':
                    if (cache.source_attribute === 'rollmacro') {
                        query.title = '';
                        const no_specilization = query.skills[0].spec.findIndex(s => s === 'not-configured') !== -1;
                        query.selection = no_specilization ? 'none' : 0;
                    } else {
                        query.title = 'Select Specialization';
                        const specializations = [];
                        for (let i = 0; i < query.skills[query.index].spec.length; i++) {
                            const specialization = getTranslationByKey(query.skills[query.index].spec[i].toKebobCase());
                            specializations.push(`${specialization === false ? 
                                query.skills[query.index].spec[i] : specialization},${i}`);
                        }
                        query.options = '|None,none';
                        query.options += specializations.length !== 0 ? '|' + specializations.sort().join("|") : '';
                        query.options += `|${getTranslationByKey("exit")},exit`;
                    }
                    query.last = query.next;
                break;
                case 'stat':
                    query.title = '';
                    roll.stat = cache.source_attribute === 'rollmacro' ?
                        cache.rolldb[query.macro_index].stat :
                        await getStats(cache, query);
                    roll.denominator = roll.stat.length;
                    roll.title_stats = roll.denominator !== 1 ? 
                        `${roll.stat.capitalize().join('+')} ` : 
                        `${roll.stat[0].capitalize()} `;
                    roll.template += roll.type === 'skill' || roll.type === 'skill_group' ?
                        ` {{stat=1}} {{title=${roll.type === 'skill_group' ? 'Skill Group' : query.name} Roll}}` :
                        ` {{stat=1}} {{title=${roll.title_stats}Stat Roll}}`;
                    query.get = getStatsRemaining(cache, roll.stat);
                    roll.cv = Math.round(query.get.reduce(
                        (m, n) => { return m + n; }, 0) / roll.denominator
                    );
                break;
                case 'shortcoming':
                    query.title = `${getTranslationByKey("apply-shortcoming")}${
                        cache.defectdb.shortcoming.length !== 1 ? '' : 
                        ": " + cache.defectdb.shortcoming[2].name
                    }?`;
                    query.options = '';
                    if (cache.defectdb.shortcoming.length !== 1) {
                        query.options += `|${getTranslationByKey("none")},no`;
                        for (let i = 0; i < cache.defectdb.shortcoming.length; i++) {
                            for (let j = 0; j < query.shortcoming.stats.length; j++) {
                                if (
                                    cache.defectdb.shortcoming[i].config[1].rank !== 'all' &&
                                    query.shortcoming.stats[j] === cache.defectdb.shortcoming[i].config[0].rank
                                ) {
                                    query.options += `|${cache.defectdb.shortcoming[i].name},${i}`;
                                }
                            }
                        }
                    } else {
                        query.options += `|${getTranslationByKey("no")},no|${getTranslationByKey("yes")},2`;
                    }
                    query.last = query.next;
                break;
                default:
                    query.title = '';
                    query.do_roll = true;
            }
            // Present player with a menu choice
            if (query.title) {
                await crpQuery(cache, query);
                query.title = '';
            }
            // Take action on the selected menu item
            switch (query.next) {
                /*
                case 'rollsroot':
                    roll.type = query.selection;
                    query.next = query.selection;
                break;
                */
                case 'attribute':
                    if (query.selection !== 'rollsroot' || query.selection !== 'exit') {
                        const selected_attribute = query.selection.split('~');
                        query.attribute = cache.attrdb[selected_attribute[0]][selected_attribute[1]];
                        const range_index = query.attribute.enhancements.findIndex(e => e.name === 'range');
                        roll.weapon = {
                            damage_type: 'none',
                            elevel: query.attribute.elevel,
                            index: int(selected_attribute[1]),
                            is_attribute: true,
                            maneuver: roll.type,
                            name: query.attribute.name || query.attribute.attribute,
                            range: range_index !== -1 ?
                                query.attribute.enhancements[range_index].rank : 0,
                            severity: 'none',
                            weapon_class: 'special',
                        };
                        /*if (roll.type !== 'defense') /*{
                            const range_index = query.attribute.enhancements.indexOf(e => e.name === 'range');
                            roll.weapon.range = range_index !== -1 ?
                                query.attribute.enhancements[range_index].rank : 0;
                            roll.weapon.elevel = query.attribute.elevel;
                            roll.weapon.name = query.attribute.name || selected_attribute[0];
                            roll.weapon.severity = 'none';
                        } else*/ //{
                            query.name = query.attribute.name;
                            query.result = query.attribute.stat === 'variable' ?
                                [] : [query.attribute.stat];
                        //}
                    }
                    query.next = query.selection === 'rollsroot' || query.selection === 'exit' ? 
                        query.selection : roll.type === 'defense' ? 'done' : 'stat';
                break;
                case 'skill_group':
                    if (query.skill_groups.length !== 0 && query.selection !== 'exit') {
                        query.index = int(query.selection);
                        query.name = getTranslationByKey(`${query.skill_groups[query.index].name.toKebobCase()}`);
                        query.level = query.skill_groups[query.index].elevel;
                    } else {
                        roll.type = 'stat';
                    }
                    query.next = 
                        query.selection === 'exit' ? query.selection : 'stat';
                break;
                case 'skill':
                    if (query.skills.length !== 0 && query.selection !== 'exit') {
                        const is_rollmacro = cache.source_attribute === 'rollmacro';
                        query.index = is_rollmacro ? 0 : int(query.selection);
                        query.name = is_rollmacro ?
                            getTranslationByKey(`${query.skilldb.skill.toKebobCase()}`) :
                            getTranslationByKey(`${query.skills[query.index].name.toKebobCase()}`);
                        query.level = is_rollmacro ? query.skilldb.rank : query.skills[query.index].rank;
                        query.stat = is_rollmacro ? query.skilldb.stat : query.skills[query.index].stat;
                        query.specializations = '';
                        if (is_rollmacro) {
                            if (query.skilldb.maneuver !== '') {
                                query.skills[query.selection].spec.push(
                                    cache.rolldb[query.macro_index].maneuver
                                );
                            }
                        }
                        query.next = 
                            query.selection === 'exit' ? query.selection : 
                            query.skills[query.selection].spec.length !== 0 ? 'specialization' :
                            'stat';
                    } else {
                        roll.type = 'stat';
                        query.next = 'stat';
                    }
                break;
                case 'specialization':
                    if (query.selection !== 'none') {
                        query.specialization = query.skills[query.index].spec[query.selection];
                        roll.mod.edge += 1;
                    }
                    query.result = query.stat;
                    query.next = 'stat';
                break;
                case 'attack':
                case 'defense':
                case 'stat':
                    roll.target = {
                        id: '',
                        name: '',
                        target: 0
                    };
                    query.shortcoming = {
                        exists: false,
                        temp: [],
                        stats: [],
                    };
                    if (cache.defectdb.shortcoming.length !== 0) {
                        query.shortcoming.temp = cache.defectdb.shortcoming.map(s => {
                            if (s.active) {
                                if (
                                    roll.denominator === 1 &&
                                    s.config[0].rank === roll.stat[0]
                                ) {
                                    return s.config[0].rank;
                                } else {
                                    for (let i = 0; i < roll.stat.length; i++) {
                                        if (s.config[0].rank === roll.stat[i]) {
                                            return s.config[0].rank;
                                        }
                                    }
                                }
                            }
                        }).filter(n => n);
                        query.shortcoming.stats = [...new Set(query.shortcoming.temp)];
                    }
                    query.next = 
                        query.next === 'stat' ? 
                        query.shortcoming.stats.length !== 0 && applyShortcomingObstacle(cache, query) ? 'shortcoming' :
                        'target_type' : 'select_weapon';
                    query.do_roll = cache.source_type === 'react' && (
                        cache.source_attribute === 'skill' ||
                        cache.source_attribute === 'stat'
                    ) ? true : false;
                break;
                case 'shortcoming':
                    if (query.selection !== 'no') {
                        roll.s_index = int(query.selection);
                        roll.mod.obstacle -= 
                            cache.defectdb.shortcoming[roll.s_index].config[1].rank === 'minor' ? 2 :
                            cache.defectdb.shortcoming[roll.s_index].config[1].rank === 'major' ? 1 : 0;
                    }
                    query.next = 'target_type';
                break;
                case 'select_weapon':
                    roll.weapon = {
                        elevel: 0,
                        index: -1,
                        is_attribute: false,
                        maneuver: roll.type,
                        name: '',
                        range: 0
                    };
                    // Get weapon range and name
                    if (cache.source_attribute === 'rollmacro') {
                        roll.weapon.index = 
                            cache.attrdb.weapon.findIndex(w => w.row_id === cache.rolldb[query.macro_index].attribute.id);
                        query.weapondb = cache.attrdb.weapon[roll.weapon.index];
                        roll.weapon.name = query.weapondb.name;
                        const range_index = 
                            query.weapondb.enhancements.findIndex(e => e.name === 'range');
                        roll.weapon.range = range_index !== -1 ?
                            query.weapondb.enhancements[range_index].rank : 0;
                        roll.weapon.elevel = query.weapondb.elevel;
                    } else if (query.selection === 'attribute') {
                        query.next = 'attribute';
                        break;
                    } else if (
                        //query.selection === 'rollsroot' || 
                        query.selection === 'select_weapon'
                    ) {
                        query.next = query.selection;
                        query.do_roll = false;
                        break;
                    } else if (
                        query.selection === 'personal' ||
                        query.selection === 'movement' ||
                        query.selection === 'unarmed'
                    ) {
                        roll.weapon.name = query.selection;
                    } else if (query.selection === 'touch') {
                        roll.weapon.name = 'touch';
                        roll.weapon.elevel = -1;
                        roll.mod.edge += 1;
                    } else if (
                        isNaN(query.selection) &&
                        query.selection.indexOf('~') !== -1
                    ) {
                        query.load = query.selection.split("~");
                        roll.weapon.index = int(query.load[1]);
                        roll.weapon.name = 
                            cache.attrdb[query.load[0]][roll.weapon.index].name;
                        roll.weapon.is_attribute = true;
                    } else {
                        roll.weapon.index = int(query.selection);
                        roll.weapon.name = 
                            cache.attrdb.weapon[roll.weapon.index].name;
                        roll.weapon.elevel = 
                            cache.attrdb.weapon[roll.weapon.index].elevel;
                        const range_index = cache.attrdb.weapon[roll.weapon.index].enhancements.findIndex(e => e.name === 'range');
                        if (range_index !== -1) {
                            roll.weapon.range = cache.attrdb.weapon[roll.weapon.index].enhancements[range_index].rank;
                        }
                    }
                    roll.weapon.severity = 
                        roll.is_swarm ? 'damage' : (
                            roll.weapon.index === -1 || 
                            roll.weapon.is_attribute || 
                            query.selection === 'touch'
                        ) ? 'none' : 
                        query.selection === 'unarmed' ? 'stun' :
                        cache.attrdb.weapon[roll.weapon.index].enhancements.findIndex(e => e.name === 'stun') !== -1 ?
                            'stun' : 'damage';
                    query.next = (
                            cache.rulesdb.rules_optional_maneuvers_status &&
                            roll.type === 'attack'
                        ) ? 'target_type' ://'combat_maneuver' : 
                        cache.source_type !== 'react' ?
                            'target_type' : 'is_enemy';
                break;
                case 'is_enemy':
                    if (query.selection === 'no' || query.selection === 'done') {
                        query.next = 'done';
                        query.do_roll = true;
                    } else {
                        const select_index = roll.enemies.findIndex(e => e.toLowerCase() === query.selection.toLowerCase());
                        const enemy_index = query.enemies.findIndex(e => e.toLowerCase() === query.selection.toLowerCase());
                        if (select_index !== -1) {
                            roll.enemies.splice(select_index, 1);
                        } else {
                            roll.enemies.push(query.enemies[enemy_index]);
                            if (roll.type === 'defense' || roll.type === 'attack') {
                                query.next = 'done';
                                query.do_roll = true;
                            }
                        }
                    }
                break;
                case 'combat_maneuver':
                    roll.maneuver = query.selection;
                    switch (roll.maneuver) {
                        case 'disarm':
                            roll.mod.obstacle -= roll.weapon.range === 0 ? 1 : 2;
                        break;
                        case 'knockout':
                            roll.weapon.severity = 'stun';
                        case 'reduce armor':
                            roll.mod.obstacle -= 1;
                        break;
                        case 'bypass armor':
                        case 'vital spot':
                            roll.mod.obstacle -= 2;
                        break;
                        case 'weak point':
                            roll.mod.obstacle -= roll.target.has_weak_point === 1 ? 1 : 2;
                        break;
                    }
                    query.next = 
                        query.selection === 'select_weapon' ||
                        query.selection === 'specific location' ? 
                        query.selection : 'is_enemy';
                break;
                case 'specific location':
                    roll.maneuver = query.selection;
                    roll.target.specific_location = 
                        roll.maneuver === 'large spot' ? 1 :
                        roll.maneuver === 'small spot' ? 2 : 3;
                    roll.mod.obstacle -= roll.target.specific_location === 1 ? 1 : 2;
                    query.next = 'is_enemy';
                break;
                case 'target_type':
                    query.target = query.selection;
                    roll.target_type = query.selection;
                    query.next = roll.type === 'stat' ? query.selection : (
                        query.target === 'target_number' &&
                        cache.rulesdb.rules_optional_maneuvers_status &&
                        roll.weapon.range
                    ) ? 'ranged_combat_maneuver' : query.selection;
                break;
                case 'ranged_combat_maneuver':
                    query.tn = query.selection;
                    query.next = 'target_number';
                break;
                case 'target_number':
                    roll.target.number = int(query.selection);
                    // There is inentionally no 'break' statement here so code execution falls through to exit loop (i.e. query.do_roll = true).
                case 'target_select':
                    query.next = 
                        roll.type === 'stat' || 
                        roll.type === 'attribute' || 
                        roll.type === 'skill' ||
                        roll.type === 'skill_group' || (
                            query.target === 'target_number' &&
                            cache.rulesdb.rules_optional_maneuvers_status &&
                            roll.weapon.range
                        ) ? 'done' : 'combat_maneuver';
                break;
            }
        }
        switch(roll.type) {
            case 'attack': //=> build weapon metadata
            case 'defense':
                roll.name = cache.character_name;
                roll.pronoun = cache.static_character_details_pronoun;
                if (roll.type === 'defense') {
                    if (
                        roll.attacker.target.has_weak_point === 3 ||
                        roll.attacker.target.specific_location === 3
                    ) {
                        roll.mod.edge += 1;
                    }
                }
                if (roll.weapon.index !== -1 && !roll.weapon.is_attribute) {
                    const sections = ['config','enhancements','limiters'];
                    const indexes = {
                        config:['damage_type','weapon_class'],
                        enhancements:['accurate','autofire','flexible','homing','indirect','penetrating','piercing','range'],
                        limiters:['inaccurate'],
                    };
                    for (let i = 0; i < sections.length; i++) {
                        for (let j = 0; j < indexes[sections[i]].length; j++) {
                            const index = 
                                cache.attrdb.weapon[roll.weapon.index][sections[i]].findIndex(c => {
                                    return c.name === indexes[sections[i]][j];
                                });
                            if (index !== -1) {
                                roll.weapon[indexes[sections[i]][j]] =
                                    cache.attrdb.weapon[roll.weapon.index][sections[i]][index].rank;
                            } else {
                                roll.weapon[sections[i]] = [];
                            }
                        }
                    }
                    // Weapon edges and obstacles
                    const mods = [...indexes.enhancements, ...indexes.limiters].sort();
                    for (let i = 0; i < mods.length; i++) {
                        switch(mods[i]) {
                            case 'accurate':
                                roll.mod.edge += roll.weapon.accurate || 0;
                            break;
                            case 'flexible':
                                roll.mod.obstacle -= 
                                    roll.weapon.flexible === 1 ? 2 :
                                    roll.weapon.flexible === 2 ? 1 : 0;
                            break;
                            case 'homing':
                                roll.mod.edge += 
                                    roll.weapon.homing === 2 ? 1 : 0;
                            break;
                            case 'inaccurate':
                                roll.mod.obstacle -= roll.weapon.inaccurate || 0;
                            break;
                            case 'indirect':
                                roll.mod.obstacle -= roll.weapon.indirect || 0;
                            break;
                        }
                    }
                } else if (roll.weapon.name !== 'touch' && !roll.weapon.is_attribute) {
                    roll.weapon.weapon_class = roll.is_swarm ? 'special' : 'unarmed';
                    roll.weapon.damage_type = roll.is_swarm ? 'penetrating' : 'blunt';
                    roll.weapon.elevel = 
                        roll.maneuver === 'grab' || 
                        roll.maneuver === 'pin' ||
                        roll.maneuver === 'disarm' ? -1 : 0;
                    roll.weapon.range = 0;
                    roll.weapon.severity = roll.is_swarm ? 'damage' :
                        roll.maneuver === 'grab' || 
                        roll.maneuver === 'pin' ||
                        roll.maneuver === 'disarm' ? 'none' : 'stun';
                    if (roll.is_swarm) {
                        roll.swarm_acv = 4 + query.elevel;
                        roll.swarm_damage = 
                            cache.statsdb.health.base -
                            cache.statsdb.health.damage;
                    }
                }
                // Weapon ACV/DCV
                const cv = roll.type === 'attack' ? 'acv' : 'dcv';
                roll.cv = roll.is_swarm ? roll.swarm_acv :
                    cache.statsdb[cv].base + cache.statsdb[cv].mastery;
                const attribute_type = roll.type === 'attack' ? 
                    `${roll.weapon.range !== 0 ? 'ranged' : 'melee'} ${roll.type}` :
                    `${roll.attacker.weapon.range !== 0 ? 'ranged' : 'melee'} ${roll.type}`;
                //=> apply melee/ranged attack/defense attribute
                if (
                    attribute_type === 'ranged defense' && 
                    (
                        roll.weapon.name === 'personal' || roll.weapon.name === 'movement'
                    )
                ) {
                    for (let i = 0; i < cache.attrdb[attribute_type].length; i++) {
                        if (cache.attrdb[attribute_type][i].active) {
                            const defense_index = cache.attrdb[attribute_type][i].config.findIndex(c => c.name === 'defense type');
                            if (cache.attrdb[attribute_type][i].config[defense_index].rank === roll.weapon.name) {
                                roll.cv += cache.attrdb[attribute_type][i].elevel * 2;
                            }
                        }
                    }
                } else if (
                    roll.type === 'attack' || roll.type === 'defense' && 
                    cache.attrdb[attribute_type].length !== 0
                ) {
                    for (let i = 0; i < cache.attrdb[attribute_type].length; i++) {
                        const class_index = 
                            cache.attrdb[attribute_type][i].config.findIndex(c => c.name === 'weapon_class');
                        if (
                            cache.attrdb[attribute_type][i].active &&
                            cache.attrdb[attribute_type][i].config[class_index].rank === roll.weapon.weapon_class
                        ) {
                            roll.cv += cache.attrdb[attribute_type][i].elevel * 2;
                        }
                    }
                }
                //=> Apply conditional inept attack/defense (i.e. melee/ranged or enemy criteria)
                if (
                    roll.type === 'attack' || roll.type === 'defense' && 
                    cache.defectdb[`inept ${roll.type}`].length !== 0
                ) {
                    for (let i = 0; i < cache.defectdb[`inept ${roll.type}`].length; i++) {
                        const attack_index = cache.defectdb[`inept ${roll.type}`][i].config.findIndex(c => c.name === 'attack_type');
                        const attack_type = cache.defectdb[`inept ${roll.type}`][i].config[attack_index].rank;
                        if (cache.defectdb[`inept ${roll.type}`][i].active && attack_type !== 'any') {
                            if (
                                roll.weapon.range === 0 && attack_type === 'melee attacks' ||
                                roll.weapon.range !== 0 && attack_type === 'ranged attacks'
                            ) {
                                roll.cv = Math.max(0, roll.cv -= cache.defectdb[`inept ${roll.type}`][i].level * 2);
                            } else if (attack_type === 'enemy' && roll.enemies.length !== 0) {
                                const enemy_index = cache.defectdb[`inept ${roll.type}`][i].config.findIndex(c => c.name === 'enemy');
                                const enemy_name = cache.defectdb[`inept ${roll.type}`][i].config[enemy_index].rank;
                                if (
                                    cache.defectdb[`inept ${roll.type}`][i].active && 
                                    roll.enemies.findIndex(e => e === enemy_name) !== -1
                                ) {
                                    roll.cv = Math.max(0, roll.cv -= cache.defectdb[`inept ${roll.type}`][i].level * (
                                        attack_type === 'any' ? 1 : 2
                                    ));
                                }
                            }
                        }
                    }
                }
                //=> apply enemy attack/defense
                if (
                    roll.type === 'attack' || roll.type === 'defense' && 
                    cache.attrdb[`enemy ${roll.type}`].length !== 0 &&
                    roll.enemies.length !== 0
                ) {
                    for (let i = 0; i < cache.attrdb[`enemy ${roll.type}`].length; i++) {
                        const enemy_index = cache.attrdb[`enemy ${roll.type}`][i].config.findIndex(c => c.name === 'enemy');
                        const enemy_name = cache.attrdb[`enemy ${roll.type}`][i].config[enemy_index].rank;
                        if (
                            cache.attrdb[`enemy ${roll.type}`][i].active && 
                            roll.enemies.findIndex(e => e === enemy_name) !== -1
                        ) {
                            roll.cv += (cache.attrdb[`enemy ${roll.type}`][i].elevel * 2);
                        }
                    }
                }
                // Weapon DM
                //=> Apply Superstrength
                //   weapons whose class is 'melee'
                //   weapons with 'muscle' enhancement
                //   weapons with elevel 0 get superstrength damage instead of DM
                //   weapons with elevel -1 get no damage bonus
                roll.superstrength_damage = 0;
                if (roll.weapon.weapon_class === 'unarmed') {
                    for (let i = 0; i < cache.attrdb['superstrength'].length; i++) {
                        if (cache.attrdb['superstrength'][i].active) {
                            roll.superstrength_damage += cache.attrdb['superstrength'][i].elevel * (
                                cache.rulebook === 'absolutepower' ? 10 : 5
                            );
                        }
                    }
                }
                roll.dm = roll.weapon.elevel < 1 ? 0 : cache.statsdb.dm.base;
                //=> Apply conditional massive damage (i.e. focused or targeted)
                for (let i = 0; i < cache.attrdb['massive damage'].length; i++) {
                    const enemy_index = cache.attrdb['massive damage'][i].config.findIndex(e => e.name === 'enemy');
                    const enemy_name = enemy_index !== -1 ? cache.attrdb['massive damage'][i].config[enemy_index].rank : '';
                    const weapon_index = cache.attrdb['massive damage'][i].config.findIndex(e => e.name === 'weapon_class');
                    const weapon_class = weapon_index !== -1 ? cache.attrdb['massive damage'][i].config[weapon_index].rank : '';
                    const is_enemy = roll.enemies.length !== 0 ? 
                        roll.enemies.findIndex(e => e.toLowerCase() === enemy_name.toLowerCase()) !== -1 : false;
                    if (cache.attrdb['massive damage'][i].active) {
                        if (
                            enemy_index !== -1 && weapon_index !== -1 &&
                            is_enemy && roll.weapon.weapon_class === weapon_class
                        ) {
                            roll.dm += cache.attrdb['massive damage'][i].elevel;
                        } else if (enemy_index !== -1 && weapon_index === -1 && is_enemy) {
                            roll.dm += cache.attrdb['massive damage'][i].elevel;
                        } else if (
                            weapon_index !== -1 && enemy_index === -1 && 
                            roll.weapon.weapon_class === weapon_class
                        ) {
                            roll.dm += cache.attrdb['massive damage'][i].elevel;
                        }
                    }
                }
                if (
                    (
                        !roll.weapon.range ||
                        roll.weapon.enhancements.findIndex(e => e.name === 'muscle') !== -1
                    ) && roll.weapon.weapon_class !== 'unarmed'
                ) {
                    for (let i = 0; i < cache.attrdb['superstrength'].length; i++) {
                        if (cache.attrdb['superstrength'][i].active) {
                            roll.dm += cache.attrdb['superstrength'][i].elevel * (
                                cache.rulebook === 'absolutepower' ? 2 : 1
                            );
                        }
                    }
                }
                if (cache.defectdb['reduced damage'].length !== 0) {
                    const reduced_damage = cache.defectdb['reduced damage'].map(r => r.active ? r.level : 0).reduce((m, n) => m + n, 0);
                    roll.dm = Math.max(0, roll.dm -= reduced_damage);
                }
            break;
            case 'initiative':
                cache.actions = cache.attrdb['extra actions'].length !== 0 ?
                    cache.attrdb['extra actions'].map(a => {
                        return a.active ? a.elevel : 0;
                    }).filter(n => n).reduce((m, n) => m + n, 0) + 1 : 1;
                cache.reflexes = 0;
                cache.attrdb['combat technique'].forEach(a => {
                    for (let i = 0, n = a.config.length; i < n; i++) {
                        if (
                            a.config[i].name === 'lightning reflexes' &&
                            a.active
                        ) {
                            cache.reflexes += (a.config[i].rank);
                        }
                    }
                });
                roll.mod.edge += cache.reflexes;
                roll.cv = cache.statsdb.acv.base;
                roll.initiative_dice = await getDice(cache, query, roll);
                roll.initiative_roll = await startRoll(`! ${roll.initiative_dice}`);
                finishRoll(roll.initiative_roll.rollId);
                roll.dice_values = 
                    roll.initiative_roll.results.total.expression.split("+");
                if (roll.dice.type === 'edge') {
                    roll.dice_values.sort((a, b) => b - a);
                } else if (roll.dice.type === 'obstacle') {
                    roll.dice_values.sort((a, b) => a - b);
                }
                roll.dice_total = 
                    `{{total=[[ [[1d0+${roll.dice_values[0]}]] + [[1d0+${roll.dice_values[1]}]] `;
                for (let i = 2, n = roll.dice_values.length; i < n; i++) {
                    roll.dice_total += `+ [[1d0+${roll.dice_values[i]}]] - [[${roll.dice_values[i]}]] `
                }
                roll.dice_total += 
                    `+ [[${roll.cv}]] &{tracker} ]]}}`;
                roll.dice_total += ` {{dice0=$[[0]]}} {{dice1=$[[1]]}}`;
                for (let i = 2, n = roll.dice_values.length; i < n; i++) {
                    roll.dice_total += ` {{dice${i}=$[[${i}]]}}`;
                }
                roll.tracker = true;
            break;
            case 'attribute':
            case 'skill':
            case 'skill_group':
            case 'stat':
                for (let i = 0; i < roll.denominator; i++) {
                    query.get[i] = isNaN(query.get[i]) ?
                        query.get[i] : int(query.get[i]);
                }
                roll.cv = Math.round(query.get.reduce(
                    (m, n) => { return m + n; }, 0) / roll.denominator
                ) + int(`${roll.type === 'skill' || roll.type === 'skill_group' ? query.level : 0}`);
                roll.cv -= roll.s_index !== undefined ? 
                    cache.defectdb.shortcoming[roll.s_index].config[1].rank === 'minor' ? (2 * cache.defectdb.shortcoming[roll.s_index].rank) :
                    cache.defectdb.shortcoming[roll.s_index].config[1].rank === 'major' ? cache.defectdb.shortcoming[roll.s_index].rank :
                    0 : 0;
                if (query.shortcoming.stats !== undefined) {
                    for (let i = 0; i < cache.defectdb.shortcoming.length; i++) {
                        for (let j = 0; j < query.shortcoming.stats.length; j++) {
                            if (
                                cache.defectdb.shortcoming[i].config[1].rank === 'all' &&
                                query.shortcoming.stats[j] === cache.defectdb.shortcoming[i].config[0].rank
                            ) {
                                roll.cv -= Math.round(cache.defectdb.shortcoming[i].rank / 2);
                            }
                        }
                    }
                }
                roll.name = cache.character_name;
            break;
        }
        // Build initial roll template.
        roll.pronoun = cache.static_character_details_pronoun;
        roll.template += ` {{base=${roll.cv}}}`;
        roll.template += roll.tracker ? ` ${roll.dice_total}` : 
            await getDice(cache, query, roll);
        switch (roll.type) {
            case 'attack':
            case 'attribute':
                if (roll.target_type === "target_select") {
                    roll.template += roll.type === 'attack' ?
                        ` {{emote=${roll.name} attempts an attack on ${roll.target.name}}}` :
                        ` {{emote=${roll.name} attempts to use ${roll.pronoun} ${query.attribute.name} attribute against ${roll.target.name}}}`;
                } else {
                    roll.template += roll.type === 'attack' ?
                        ` {{emote=${roll.name} attempts` +
                        ` ${cache.rulesdb.rules_optional_maneuvers_status &&
                            roll.maneuver !== 'attack' ?
                            ' a ' + roll.maneuver : ' an'} attack}}` :
                        ` {{emote=${roll.name} uses ${roll.pronoun} ${query.attribute.name} attribute}}`;
                }
            break;
            case 'defense':
                roll.template += ` {{emote=${roll.name} respods to ${roll.attacker.name}'s ` +
                `${roll.attacker.maneuver || roll.attacker.type} ${roll.weapon.name === 'unarmed' ?
                    'unarmed' : 'with ' + roll.pronoun + ' ' + roll.weapon.name
                }}}`;
            break;
            case 'skill':
            case 'skill_group':
            case 'stat':
                if (roll.target_type === "target_select") {
                    roll.template += ` {{emote=${roll.name} challenges ${roll.target.name} ` +
                        `with ${roll.pronoun} ` +
                    `${roll.type === 'skill' && query.specialization !== undefined ?
                            query.specialization.capitalize() + ' ' : ''}` +
                    `${roll.type === 'skill' || roll.type === 'skill_group' ?
                            query.name.capitalize() + ' ' : ''}` +
                    `${roll.type === 'stat' ? roll.title_stats + ' ' : ''}` +
                    `${roll.type.capitalize()} roll!}}`;
                } else if (cache.source_type === 'react') {
                    roll.template += ` {{emote=${roll.name} responds to ${roll.attacker.name} ` +
                        `with ${roll.pronoun} ` +
                    `${roll.type === 'skill' && query.specialization !== undefined ?
                            query.specialization.capitalize() + ' ' : ''}` +
                    `${roll.type === 'skill' || roll.type === 'skill_group' ?
                            query.name.capitalize() + ' ' : ''}` +
                    `${roll.type === 'stat' ? roll.title_stats + ' ' : ''}` +
                    `${roll.type.capitalize()} roll!}}`;
                } else {
                    roll.template += ` {{emote=${roll.name} attempts a ` +
                    `${roll.type === 'skill' && query.specialization !== undefined ?
                            query.specialization.capitalize() + ' ' : ''}` +
                    `${roll.type === 'skill' || roll.type === 'skill_group' ?
                            query.name.capitalize() + ' ' : ''}` +
                    `${roll.type === 'stat' ? roll.title_stats + ' ' : ''}` +
                    `${roll.type.capitalize()} roll!}}`;
                }
            break;
        }
        // Build react template.
        roll.template += query.target === 'target_select' ?
            ` {{react=1}} {{reactheader=${getTranslationByKey("opposed-rolls")}}}` +
            ` {{react-button=1}} {{reacttitle=${
                roll.type === 'attack' ? 
                getTranslationByKey("defense") : roll.type.capitalize()
            } Roll (${roll.target.name})}}` +
            ' {{reactlabel=IJ}} {{reactdata=[[0]]}}' +
            ` {{reactlink=${
                (
                    roll.type === 'stat' ||
                    roll.type === 'attribute'
                ) ? 'react_button_roll_stat' :
                roll.type === 'skill' || roll.type === 'skill_group' ? 'react_button_roll_skill' :
                'react_button_roll_defense'}}}` :
            query.target === 'target_number' ? 
            ` {{react=1}} {{reactheader=${getTranslationByKey("target-number")}}}` +
            ` {{reacttitle=${roll.type === 'skill_group' ? getTranslationByKey("skill-group") : getTranslationByKey(roll.type)}` +
            ` ${getTranslationByKey("roll-vs")}}}` +
            ` {{react-tn=${roll.target.number}}}` : '';
        // Roll against initial roll template and determine dice.
        query.crp = await startRoll(roll.template);
        roll.results = [];
        for (let i = 0; i < roll.dice.number; i++) {
            roll.results.push(query.crp.results[`dice${i}`].result);
        }
        roll.computed = {
            total: 0,
        };
        for (let i = 0; i < roll.dice.number; i++) {
            if (i === 0 || i === 1) {
                roll.computed[`dice_value${i}`] = 
                    roll.dice.type === 'obstacle' ? _.min(roll.results) :
                    roll.dice.type === 'edge' ? _.max(roll.results) :
                    roll.results[i];
                roll.computed[`dice${i}`] = 
                    getDiceIcon(roll.computed[`dice_value${i}`]);
                roll.computed.total += roll.computed[`dice_value${i}`];
                if (roll.dice.type !== 'normal') {
                    const results_length = 
                        roll.results.indexOf(roll.computed[`dice_value${i}`]);
                    roll.results.splice(results_length, 1);
                }
            } else {
                roll.computed[`dice_value${i}`] = roll.results[i-2];
                roll.computed[`dice${i}`] = 
                    getDiceIcon(roll.computed[`dice_value${i}`], true);
            }
        }
        roll.computed.total += roll.cv;
        if (roll.target_type === 'target_select') {
            roll.computed.reactdata = rollEscape.escape(roll);
        }
        finishRoll(query.crp.rollId,roll.computed);
        // Determine post-roll event(s).
        switch (roll.type) {
            case 'initiative':
                if (
                    cache.rulesdb.rules_optional_spreadinitiative_status &&
                    cache.actions !== 1
                ) {
                    const actions_by_initiative = [];
                    for (let i = 0; i < cache.actions; i++) {
                        actions_by_initiative.push(
                            Math.floor((roll.computed.total / cache.actions) * (cache.actions - i))
                        );
                    }
                    set_values.static_character_initiative_base =
                        actions_by_initiative.join(", ");
                } else {
                    set_values.static_character_initiative_base = 
                        roll.computed.total;
                }
            break;
            case 'attack':
            case 'attribute':
            case 'defense':
            case 'skill':
            case 'skill_group':
            case 'stat':
                if (
                    (roll.type === 'attack' && roll.target_type !== 'target_number') ||
                    (
                        (
                            roll.type === 'attribute' ||
                            roll.type === 'skill' ||
                            roll.type === 'skill_group' ||
                            roll.type === 'stat'
                        ) && (
                            cache.source_type !== 'react' &&
                            roll.target_type !== 'target_number'
                        )
                    )
                ) { break; }
                roll.result = 
                    roll.target_type === 'target_number' ?
                        roll.computed.total - roll.target.number :
                    (
                        roll.type === 'attribute' ||
                        roll.type === 'skill' ||
                        roll.type === 'skill_group' ||
                        roll.type === 'stat'
                    ) && cache.source_type !== 'react' ?
                        roll.computed.total :
                        roll.attacker.computed.total - roll.computed.total;
                roll.mos = getMarginOfSuccess(cache, roll.result);
                roll.template = `&{template:rolls-result}`;
                roll.template += roll.target_type === 'target_number' ?
                    ' {{result-spacer=result-nospacer}}' : 
                    ' {{result-spacer=result-spacer}}';
                roll.template +=
                    ` {{color=color-${color}}} {{result-header=${roll.mos}}}`;
                if (roll.result >= 0) {
                    roll.template += ` {{result=[[1d1]]}}`;
                    if (
                        (
                            (
                                roll.type === 'attack' ||
                                roll.type === 'attribute' ||
                                roll.type === 'skill' ||
                                roll.type === 'skill_group' ||
                                roll.type === 'stat'
                            ) && (
                                roll.target_type === 'target_number' &&
                                cache.source_type !== 'react'
                            )
                        )
                    ) {
                        roll.template += ` {{emote=${
                            roll.target_type === 'target_number' ?
                            roll.name : roll.attacker.name
                        }'s` +
                        `${
                            roll.type === 'skill' && query.specialization !== undefined ?
                                ' ' + query.specialization.capitalize() : ''
                        }` +
                        `${
                            roll.type === 'skill' || roll.type === 'skill_group' ?
                                ' ' + query.name.capitalize() : ''
                        }` +
                        ` ${
                            cache.source_type === 'react' ?
                            roll.attacker.type.capitalize() :
                            roll.type.capitalize()
                        } roll vs. ${
                            roll.target_type === 'target_number' ?
                            'TN ' + roll.target.number : roll.name
                        } succeeded.}}`;
                    } else if (roll.type === 'defense') {
                        roll.template += ` {{emote=${roll.attacker.name}` +
                        `${
                            roll.attacker.weapon.maneuver === 'attack' ?
                            ' attacks' : ' executes a ' + roll.attacker.maneuver + ' on'
                        }` +
                        ` ${roll.name} with ` +
                            `${roll.attacker.weapon.name === 'unarmed' ? 'an unarmed attack' :
                            roll.attacker.pronoun + ' ' + roll.attacker.weapon.name}}}`;
                    } else if (
                        (
                            roll.type === 'attribute' ||
                            roll.type === 'skill' ||
                            roll.type === 'skill_group' ||
                            roll.type === 'stat'
                        ) && roll.attacker !== undefined
                    ) {
                        roll.template += ` {{emote=${roll.attacker.name}'s ${roll.attacker.type.fromSnakeCase().capitalize()} ` +
                        `roll vs. ${roll.name} was a ${roll.mos.toLowerCase()}}}`;
                    }

                    if (roll.type === 'defense') {
                        const damage = {};
                        clog(cache, damage, 'actionRoll(damage)');
                        damage.percentage = 1;
                        if (roll.attacker.weapon.elevel !== -1) {
                            if (cache.rulesdb.rules_optional_variable_status !== 'fixed') {
                                damage.attack_roll = 
                                    roll.attacker.computed.dice_value0 + 
                                    roll.attacker.computed.dice_value1;
                                if (cache.rulesdb.rules_optional_variable_status.indexOf('damageroll') !== -1) {
                                    damage.template = 
                                        '! {{total=[[ [[1d6]]+[[1d6]] ]]}}' +
                                        ' {{dice0=$[[0]]}} {{dice1=$[[1]]}}';
                                    damage.crp = await startRoll(damage.template);
                                        damage.dice =
                                            `${getDiceIcon(damage.crp.results.dice0.result)} ` +
                                            `${getDiceIcon(damage.crp.results.dice1.result)}`;
                                        damage.roll = damage.crp.results.total.result;
                                    finishRoll(damage.crp.rollId);
                                    roll.template += ` {{damage-dice=${damage.dice}}}`;
                                }
                                switch (cache.rulesdb.rules_optional_variable_status) {
                                    case 'mos-dm':
                                        switch (roll.result) {
                                            case 0:
                                                roll.attacker.dm += -2;
                                            break;
                                            case 1:
                                            case 2:
                                                roll.attacker.dm += -1;
                                            break;
                                            case 3:
                                            case 4:
                                            case 5:
                                                roll.attacker.dm += 0;
                                            break;
                                            case 6:
                                            case 7:
                                            case 8:
                                            case 9:
                                            case 10:
                                            case 11:
                                                roll.attacker.dm += 1;
                                            break;
                                            default:
                                                roll.attacker.dm += 2;
                                        }
                                    break;
                                    case 'attackroll-dm':
                                        switch (damage.attack_roll) {
                                            case 2:
                                            case 3:
                                                roll.attacker.dm += -2;
                                            break;
                                            case 4:
                                            case 5:
                                                roll.attacker.dm += -1;
                                            break;
                                            case 9:
                                            case 10:
                                                roll.attacker.dm += 1;
                                            break;
                                            case 11:
                                            case 12:
                                                roll.attacker.dm += 2;
                                            break;
                                            default:
                                                roll.attacker.dm += 0;
                                        }
                                    break;
                                    case 'damageroll-dm':
                                        switch (damage.roll) {
                                            case 2:
                                            case 3:
                                                roll.attacker.dm += -2;
                                            break;
                                            case 4:
                                            case 5:
                                                roll.attacker.dm += -1;
                                            break;
                                            case 9:
                                            case 10:
                                                roll.attacker.dm += 1;
                                            break;
                                            case 11:
                                            case 12:
                                                roll.attacker.dm += 2;
                                            break;
                                            default:
                                                roll.attacker.dm += 0;
                                        }
                                    break;
                                    case 'mos-td':
                                        switch (roll.result) {
                                            case 0:
                                                damage.percentage = 0.25;
                                            break;
                                            case 1:
                                            case 2:
                                                damage.percentage = 0.5;
                                            break;
                                            case 3:
                                            case 4:
                                            case 5:
                                                damage.percentage = 1;
                                            break;
                                            case 6:
                                            case 7:
                                            case 8:
                                            case 9:
                                            case 10:
                                            case 11:
                                                damage.percentage = 1.25;
                                            break;
                                            default:
                                                damage.percentage = 1.5;
                                        }
                                    break;
                                    case 'attackroll-td':
                                        switch (damage.attack_roll) {
                                            case 2:
                                            case 3:
                                                damage.percentage = 0.25;
                                            break;
                                            case 4:
                                            case 5:
                                                damage.percentage = 0.5;
                                            break;
                                            case 9:
                                            case 10:
                                                damage.percentage = 1.25;
                                            break;
                                            case 11:
                                            case 12:
                                                damage.percentage = 1.5;
                                            break;
                                            default:
                                                damage.percentage = 1;
                                        }
                                    break;
                                    case 'damageroll-td':
                                        switch (damage.roll) {
                                            case 2:
                                            case 3:
                                                damage.percentage = 0.25;
                                            break;
                                            case 4:
                                            case 5:
                                                damage.percentage = 0.5;
                                            break;
                                            case 9:
                                            case 10:
                                                damage.percentage = 1.25;
                                            break;
                                            case 11:
                                            case 12:
                                                damage.percentage = 1.5;
                                            break;
                                            default:
                                                damage.percentage = 1;
                                        }
                                    break;
                                    default:
                                }
                                damage.multiplier = Math.max(roll.attacker.dm, 0);
                            } else {
                                damage.multiplier = roll.attacker.dm;
                            }
                        }
                        damage.percentage = roll.attacker.weapon.is_attribute ? 0 : damage.percentage;
                        damage.received = 
                            roll.attacker.is_swarm ? roll.attacker.swarm_damage :
                            roll.attacker.weapon.elevel !== -1 ? Math.round(
                                (
                                    (
                                        damage.multiplier * roll.attacker.weapon.elevel
                                    ) + roll.attacker.cv + roll.attacker.superstrength_damage
                                ) * damage.percentage
                            ) : 0;
                        damage.hits = roll.attacker.weapon.autofire !== undefined ?
                            roll.result === 0 ? 1 : Math.ceil(roll.result/3) : 1;
                        roll.template += ` {{damage=${damage.received}}}`;
                        roll.template += roll.attacker.weapon.severity === 'stun' ?
                            ` {{stun=Stun }}` : '';
                        roll.template += roll.attacker.weapon.autofire !== undefined ?
                            ` {{autofire=${damage.hits}}}` : '';
                        roll.template += roll.attacker.weapon.penetrating !== undefined ?
                            ` {{penetrating=${roll.attacker.weapon.penetrating * 10}}}` : '';
                        roll.template += roll.attacker.weapon.piercing !== undefined ?
                            ` {{piercing=${roll.attacker.weapon.piercing * 10}}}` : '';
                        damage.taken = damage.received;
                        if (damage.received !== 0) {
                            damage.absorbed = [];
                            damage.converted = [];
                            damage.stopped = 0;
    
                            const protections = ['force field','armor','absorption'];
                            const defenses = {
                                armor_rating:0,
                                'force field':[],
                                'armor':[],
                                'absorption':[]
                            };
                            clog(cache, defenses, 'actionRoll(defenses)');
                            roll.has_protections = false;
                            for (let p = 0; p < protections.length; p++) {
                                for (let i = 0; i < cache.attrdb[protections[p]].length; i++) {
                                    if (cache.attrdb[protections[p]][i].active) {
                                        roll.has_protections = true;
                                        const protection = cache.attrdb[protections[p]][i];
                                        const ar_index = 
                                            protection.config.findIndex(c => c.name === 'armor rating');
                                        defenses.armor_rating = ar_index !== -1 ? 
                                            protection.config[ar_index].rank : 0;
                                        // Determine armor_rating if Emphasized or Optimized.
                                        const eo_index = protection.limiters.findIndex(l => l.name === 'emphasized' || l.name === 'optimized');
                                        if (eo_index !== -1) {
                                            const dt_index = protection.config.findIndex(c => c.name === 'damage_type');
                                            defenses.armor_rating = 
                                                roll.attacker.weapon.damage_type === protection.config[dt_index].rank ? //=> specialized
                                                defenses.armor_rating * 2 : //=> not specialized
                                                protection.limiters[eo_index].rank === 1 ? //=> emphasized
                                                Math.round(defenses.armor_rating / 2) : 0; //=> optimized
                                        }
                                        if (
                                            defenses.armor_rating !== 0 &&
                                            cache.groupdb[protection.group_id].group_type !== 'shield'
                                        ) {
                                            if (
                                                protections[p] === 'absorption' && (
                                                    roll.attacker.weapon.severity !== 'stun'
                                                    // add psychic
                                                    // add continuing
                                                    // add tangle
                                                    // add drain
                                                    // add flare
                                                    // add incapacitating
                                                    // add irritant
                                                )
                                            ) {
                                                const transform_index = protection.config.findIndex(c => c.name === 'transform');
                                                damage.absorbed.push({
                                                    name: protection.name,
                                                    total: damage.received > defenses.armor_rating ? 
                                                        defenses.armor_rating * damage.hits : damage.received * damage.hits,
                                                    transform: protection.config[transform_index].rank.substring(
                                                        0, protection.config[transform_index].rank.length - 7
                                                    ),
                                                    synergistic: protection.enhancements.findIndex(c => c.name === 'synergistic') !== -1 ?
                                                        true : false,
                                                    capped: protection.limiters.findIndex(c => c.name === 'capped') !== -1 ?
                                                        true : false,
                                                });
                                            }
                                            // Determine if armor has Gap and has been reduced or bypassed.
                                            const gap_index = protection.limiters.findIndex(c => c.name === 'gap');
                                            const has_gap = 
                                                gap_index !== -1 && roll.attacker.maneuver === 'bypass armor' ? 0 :
                                                gap_index !== -1 && roll.attacker.maneuver === 'reduce armor' ? 0.5 : 1;
                                            // Calculate damage against armor_rating.
                                            for (let i = 0; i < damage.hits; i++) {
                                                damage.taken = (Math.max(damage.taken - (
                                                    protections[p] === 'armor' && roll.attacker.weapon.penetrating !== undefined ?
                                                        Math.max(Math.round(defenses.armor_rating * has_gap) - (roll.attacker.weapon.penetrating * 10), 0) :
                                                    protections[p] === 'force field' && roll.attacker.weapon.piercing !== undefined ?
                                                        Math.max(defenses.armor_rating - (roll.attacker.weapon.piercing * 10), 0) :
                                                    protections[p] === 'armor' ? Math.round(defenses.armor_rating * has_gap) : 
                                                    defenses.armor_rating
                                                ), 0)) * (roll.attacker.maneuver === 'vital spot' ? 2 : 1);
                                                // Record damage stopped for Conversion with Escalate.
                                                if (protections[p] === 'force field' || protections[p] === 'armor') {
                                                    damage.stopped += damage.received - damage.taken;
                                                    if (protections[p] === 'force field' && damage.taken !== 0) {
                                                        defenses.armor_rating = Math.max(defenses.armor_rating - 10, 0);
                                                    }
                                                }
                                            }
                                            // Add active protection to the roll template.
                                            const label = protections[p] === 'force field' ?
                                                protections[p].removeWhiteSpace() : protections[p];
                                            roll.template += protections[p] !== 'absorption' ?
                                                ` {{${label}${i}key=${protection.name}${has_gap !== 1 ? ' ('+roll.attacker.maneuver+')' : ''}}}` +
                                                ` {{${label}${i}value=${has_gap * defenses.armor_rating}}}` : '';
                                            if (
                                                damage.taken !== 0 &&
                                                protections[p] === 'force field'
                                            ) {
                                                protection.config[ar_index].rank = defenses.armor_rating;
                                                let value = '';
                                                for (let j = 0; j < protection.config.length; j++) {
                                                    value += `${protection.config[j].name.capitalize()}` +
                                                    ` (${protection.config[j].rank})\n`;
                                                }
                                                set_values[`repeating_attribute_${protection.row_id.toLowerCase()}_configuration`] = value;
                                                if (defenses.armor_rating === 0) {
                                                    set_values[`repeating_attribute_${protection.row_id.toLowerCase()}_active`] = false;
                                                    protection.active = false;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (!roll.has_protections) {
                                damage.taken = 
                                    (damage.taken * (roll.attacker.maneuver === 'vital spot' ? 2 : 1)) * damage.hits;
                            }
                            // Apply Damage, Absorption, and Conversion
                            // Apply Absorption
                            for (let i = 0; i < damage.absorbed.length; i++) {
                                damage.absorbed_remainder = 0;
                                if (damage.absorbed[i].total !== 0) {
                                    const absortion_type = damage.absorbed[i].transform;
                                    const max_points = Math.round(cache.statsdb[absortion_type].base / 2);
                                    const current_damage = cache.statsdb[absortion_type].damage + (
                                        absortion_type === 'health' ? cache.statsdb.health.stun : 0
                                    );
                                    damage.absorbed[i].temp = 0;
                                    damage.absorbed[i].over = 0;
                                    //=> Note: has to be damage and temp...remaining calculated later.
                                    //=> also, should heal stun since it is loss of health.
                                    for (let j = 0; j < damage.hits; j++) {
                                        if (
                                            damage.absorbed[i].total > current_damage
                                        ) {
                                            damage.absorbed[i].over = damage.absorbed[i].total - current_damage;
                                            cache.statsdb[absortion_type].damage = 0;
                                            if (absortion_type === 'health') { cache.statsdb.health.stun = 0; }

                                            damage.absorbed[i].temp += damage.absorbed[i].capped ? 
                                                0 : damage.absorbed[i].over;
                                            damage.absorbed[i].temp = damage.absorbed[i].capped ?
                                                damage.absorbed[i].temp : damage.absorbed[i].temp > max_points ? 
                                                    max_points : damage.absorbed[i].temp;
                                                    
                                            roll.template += 
                                                ` {{absorption${i}key=${damage.absorbed[i].name}}}` +
                                                ` {{absorption${i}value=${damage.absorbed[i].total}}}`;
                                        } else {
                                            cache.statsdb[absortion_type].damage -= damage.absorbed[i].total;
                                            if (cache.statsdb[absortion_type].damage < 0) {
                                                damage.absorbed[i].temp = damage.absorbed[i].capped ? 0 :
                                                    cache.statsdb[absortion_type].damage * -1;
                                                cache.statsdb[absortion_type].damage = 0;
                                            }
                                            if (
                                                absortion_type === 'health' &&
                                                cache.statsdb[absortion_type].damage === 0 &&
                                                damage.absorbed[i].temp !== 0
                                            ) {
                                                cache.statsdb.health.stun -= damage.absorbed[i].temp;
                                                if (cache.statsdb.health.stun < 0) {
                                                    damage.absorbed[i].temp = damage.absorbed[i].capped ? 0 :
                                                        cache.statsdb.health.stun * -1;
                                                    cache.statsdb.health.stun = 0;
                                                }
                                            }
                                            
                                            const healed_points = damage.absorbed[i].total > current_damage ?
                                                current_damage : damage.absorbed[i].total;
                                            roll.template += 
                                                ` {{absorption${i}key=${damage.absorbed[i].name}}}` +
                                                ` {{absorption${i}value=${healed_points}}}`;
                                        }
                                    }
                                }
                            }
                            if (damage.absorbed.length !== 0) {
                                const absorption_types = ['health','energy'];
                                for (let i = 0; i < absorption_types.length; i++) {
                                    const temp_points = damage.absorbed.map(a => {
                                        return a.transform === absorption_types[i] ? a.temp : 0;
                                    }).reduce((a, b) => a + b, 0);
                                    const max_points = Math.round(cache.statsdb[absorption_types[i]].base / 2);
                                    cache.statsdb[absorption_types[i]].temp +=
                                        Math.min(temp_points, max_points);

                                    if (temp_points > max_points) {
                                        cache.statsdb[absorption_types[i]].damage += temp_points - max_points;
                                    }

                                    cache.statsdb[absorption_types[i]].remaining =
                                        cache.statsdb[absorption_types[i]].base
                                        + cache.statsdb[absorption_types[i]].temp
                                        - cache.statsdb[absorption_types[i]].damage
                                        - (absorption_types[i] === 'health' ? cache.statsdb.health.stun : 0);

                                    set_values[`static_character_${absorption_types[i]}_damage`] = cache.statsdb[absorption_types[i]].damage;
                                    set_values[`static_character_${absorption_types[i]}_remaining`] = cache.statsdb[absorption_types[i]].remaining;
                                    if (absorption_types[i] === 'health') { set_values.static_character_health_stun = cache.statsdb.health.stun; }
                                    set_values[`static_character_${absorption_types[i]}_temp`] = cache.statsdb[absorption_types[i]].temp;
                                }
                            }
                            // Apply Conversion
                            for (let i = 0; i < cache.attrdb.conversion.length; i++) {
                                const absorbed_convertable = damage.absorbed.length !== 0 ? 
                                    damage.absorbed.map(a => a.synergistic ? a.total : 0).reduce((m, n) => m + n, 0) : 0;
                                const absorbed = damage.absorbed.length !== 0 ? 
                                    damage.absorbed.map(a => a.total).reduce((m, n) => m + n, 0) : 0;
                                if (
                                    damage.taken !== 0 || 
                                    absorbed_convertable !== 0
                                ) {
                                    if (roll.attacker.weapon.elevel !== -1) {
                                        for (let i = 0; i < cache.attrdb.conversion.length; i++) {
                                            const group_id = cache.attrdb.conversion[i].group_id;                           
                                            if (
                                                cache.attrdb.conversion[i].active &&
                                                cache.groupdb[group_id].group_type !== 'shield'
                                            ) {
                                                const has_escalate = 
                                                    cache.attrdb.conversion[i].enhancements.findIndex(c => c.name === 'escalate') !== -1;
                                                damage.convertable = Math.max(damage[`${has_escalate ? 'received' : 'taken'}`] - (absorbed - absorbed_convertable), 0);
                                                damage.converted[i] = Math.floor(damage.convertable / 10);
                                                roll.template += 
                                                    ` {{conversion${i}key=${cache.attrdb.conversion[i].name}}}` +
                                                    ` {{conversion${i}value=${damage.converted[i]}}}`;
                                                if (damage.taken === 0) {
                                                    break;
                                                }
                                            }
                                        }
                                        damage.temp_cp = Math.floor(
                                            damage.converted.filter(n => n).reduce((m, n) => m + n, 0)
                                        );
                                        if (damage.temp_cp !== 0) {
                                            const cp_temp = Math.min(
                                                damage.temp_cp + int(cache.statsdb.cp.temp),
                                                Math.round(int(cache.statsdb.cp.base) / 2)
                                            );
                                            set_values.static_character_points_temp = cp_temp;
                                            cache.statsdb.cp.temp = cp_temp;
                                            set_values.static_character_points_remaining = (
                                                int(cache.statsdb.cp.base) +
                                                int(cache.statsdb.cp.gained) +
                                                set_values.static_character_points_temp
                                            ) - int(cache.statsdb.cp.spent);
                                        }
                                    }
                                }
                            }

                            cache.statsdb.health.temp = damage.taken !== 0 ? 
                                Math.max(0, cache.statsdb.health.temp - damage.taken) : 0;

                            damage.taken = cache.statsdb.health.temp < 0 ?
                                cache.statsdb.health.temp * -1 : damage.taken;

                            cache.statsdb.health[`${roll.attacker.weapon.severity}`] += damage.taken;

                            cache.statsdb.health.remaining =
                                cache.statsdb.health.base
                                + cache.statsdb.health.temp
                                - cache.statsdb.health.damage
                                - cache.statsdb.health.stun;

                            set_values.static_character_health_damage = cache.statsdb.health.damage;
                            set_values.static_character_health_remaining = cache.statsdb.health.remaining;
                            set_values.static_character_health_stun = cache.statsdb.health.stun;
                            set_values.static_character_health_temp = cache.statsdb.health.temp;
                            
                            const max = cache.statsdb.health.base + cache.statsdb.health.temp;
                            const loss = cache.statsdb.health.damage + cache.statsdb.health.stun;
                            setStatusStateDescription(cache, set_values, 'health', max, loss);
                            roll.template += ` {{damagetaken=${damage.taken}}}`;
                        }
                    }
                } else {
                    if (roll.attacker === undefined) {
                        roll.template += ' {{result=[[1d0]]}}' +
                        ` {{emote=${roll.name}'s ${roll.type.capitalize()}` +
                        ` roll vs TN ${roll.target.number} failed.}}`;
                    } else {
                        roll.template += ' {{result=[[1d0]]}}' +
                        ` {{emote=${roll.attacker.name}'s ${roll.attacker.type.capitalize()}` +
                        ` ${roll.attacker.type === 'attack' ? 'on' : 'roll vs'} ${roll.name} failed.}}`;
                    }
                }
                roll.crp = await startRoll(roll.template);
                finishRoll(roll.crp.rollId);
            break;
        }
    }

    /* Menu Functions */
    async function displayHelp(cache) {
        const display = {};
        clog(cache, display, 'displayHelp()');
        display.template = `&{template:display-help} {{roll=1d0}}`;
        display.roll = await startRoll(display.template);
        finishRoll(display.roll.rollId);
    }

    async function openMenu(cache, set_values) {
        const query = {};
        let commit_changes = true;
        clog(cache, query, 'openMenu()');
        // Determine which menu to present
        switch (cache.source_id) {
            case 'details':
            case 'points':
            case 'settings':
                switch (cache.source_section) {
                    case 'character':
                    case 'sheet':
                        switch (cache.source_attribute) {
                            case 'base':
                            case 'class':
                            case 'damage':
                            case 'gained':
                            case 'gm':
                            case 'height':
                            case 'player':
                            case 'pronoun':
                            case 'race':
                            case 'size':
                            case 'stun':
                            case 'temp':
                            case 'theme':
                            case 'type':
                            case 'weight':
                                query.selection = cache.source;
                            break;
                        }
                    break;
                }
            break;
            case 'body':
            case 'mind':
            case 'soul':
                query.selection = 'setstatpoints';
            break;
            case 'energy':
            case 'health':
            case 'sanity':
            case 'society':
                const point = cache.source.split('_');
                query.point_section = point[2];
                query.point_type = point[3];
                query.point_method = 'setpoints';
                query.selection = 'setpoints';
                
            break;
            case 'add':
            case 'edit':
                switch (cache.source_section) {
                    case 'screen':
                    case 'gmscreen':
                        query.selection = 'screenroot';
                    break;
                    case 'skills':
                        query.selection = 'skillsroot';
                    break;
                    case 'stats':
                        query.selection = 'statsroot';
                    break;
                    case 'status':
                        query.selection = 'addcondition';
                    break;
                }
            break;
            case 'delete':
                await cacheSectionIDs(cache, 'condition');
                if (cache.condition_ids.length === 0) {
                    clog(cache, 'No conditions exist to remove.', 'ERROR');
                    query.selection = 'exit';
                } else {
                    query.selection = 'removecondition';
                }
                
            break;
            case 'update':
                query.selection = 'timeelapseroot';
                await cacheSectionIDs(cache, 'condition');
            break;
        }
        // Loop through menu choices until an answer is provided
        while (query.answer === undefined) {
            switch(query.selection) {
                // Screen Menu Options Root
                case 'screenroot':
                    query.title = `${getTranslationByKey("choose-section-to-edit")}`;
                    query.options = 
                        `|${getTranslationByKey("character-details")},characterdetails` +
                        `|${getTranslationByKey("character-points")},characterpoints` +
                        `|${getTranslationByKey("sheet-settings")},sheetsettings`;
                break;
                // Screen Menu Options Level 1
                case 'characterdetails':
                    query.title = `${getTranslationByKey("character-details")}`;
                    query.options = 
                        `|${getTranslationByKey("class")},static_character_details_class` +
                        `|${getTranslationByKey("height")},static_character_details_height` +
                        `|${getTranslationByKey("possessive-pronoun")},static_character_details_pronoun` +
                        `|${getTranslationByKey("race")},static_character_details_race` +
                        `|${getTranslationByKey("size")},static_character_details_size` +
                        `|${getTranslationByKey("weight")},static_character_details_weight` +
                        `|${getTranslationByKey("go-back")},screenroot`;
                break;
                case 'characterpoints':
                    query.title = `${getTranslationByKey("character-points")}`;
                    query.options = 
                        `|${getTranslationByKey("base")},static_character_points_base` +
                        `|${getTranslationByKey("gained")},static_character_points_gained` +
                        `|${getTranslationByKey("temporary")},static_character_points_temp` +
                        `|${getTranslationByKey("go-back")},screenroot`;
                break;
                case 'sheetsettings':
                    query.title = `${getTranslationByKey("sheet-settings")}`;
                    query.options = 
                            `|${getTranslationByKey("debug-level")},static_sheet_settings_debug` +
                            `|${getTranslationByKey("game-master-name")},static_sheet_settings_gm` +
                            `|${getTranslationByKey("player-name")},static_sheet_settings_player` +
                            `|${getTranslationByKey("sheet-type")},static_sheet_settings_type` +
                            `|${getTranslationByKey("theme")},static_sheet_settings_theme` +
                            `|${getTranslationByKey("go-back")},screenroot`;
                break;
                // Screen Menu Options Level 2
                case 'static_character_details_size':
                    query.title = `${getTranslationByKey("select-size-template")}`;
                    query.options = 
                        `|${getTranslationByKey("point")},point` +
                        `|${getTranslationByKey("mote")},mote` +
                        `|${getTranslationByKey("speck")},speck` +
                        `|${getTranslationByKey("minute-small")},minute` +
                        `|${getTranslationByKey("wee")},wee` +
                        `|${getTranslationByKey("teeny")},teeny` +
                        `|${getTranslationByKey("fine")},fine` +
                        `|${getTranslationByKey("diminutive")},diminutive` +
                        `|${getTranslationByKey("tiny")},tiny` +
                        `|${getTranslationByKey("small")},small` +
                        `|${getTranslationByKey("medium")},medium` +
                        `|${getTranslationByKey("large")},large` +
                        `|${getTranslationByKey("huge")},huge` +
                        `|${getTranslationByKey("mammoth")},mammoth` +
                        `|${getTranslationByKey("gigantic")},gigantic` +
                        `|${getTranslationByKey("gargantuan")},gargantuan` +
                        `|${getTranslationByKey("colossal")},colossal` +
                        `|${getTranslationByKey("enormous")},enormous` +
                        `|${getTranslationByKey("monstrous")},monstrous` +
                        `|${getTranslationByKey("titanic")},titanic` +
                        `|${getTranslationByKey("monumental")},monumental`;
                    query.attribute = query.selection;
                break;
                case 'static_sheet_settings_debug':
                    query.title = 'Debug Level';
                    query.options = 
                        `|${getTranslationByKey("none")},none` +
                        `|${getTranslationByKey("info")},info` +
                        `|${getTranslationByKey("events")},events` +
                        `|${getTranslationByKey("performance")},performance` +
                        `|${getTranslationByKey("go-back")},sheetsettings`;
                    query.attribute = query.selection;
                break;
                case 'static_sheet_settings_type':
                    query.title = `${getTranslationByKey("sheet-type")}`;
                    query.options = 
                        `|${getTranslationByKey("player")},Player` +    
                        `|${getTranslationByKey("game-master-u")},GM`;
                    query.attribute = query.selection;
                break;
                case 'static_sheet_settings_theme':
                    query.title = `${getTranslationByKey("theme")}`;
                    query.options = 
                        `|${getTranslationByKey("tri-stat-core")},tri stat core` +
                        `|${getTranslationByKey("big-eyes-small-mouth-u")},besm` +
                        `|${getTranslationByKey("absolute-power")},absolute power` +
                        `|${getTranslationByKey("bela-lugosi")},bela lugosi` +
                        `|${getTranslationByKey("dark-forest")},dark forest` +
                        `|${getTranslationByKey("galaxy-express")},galaxy express` +
                        `|${getTranslationByKey("high-contrast")},high contrast` +
                        `|${getTranslationByKey("imperial")},imperial` +
                        `|${getTranslationByKey("lavender")},lavender` +
                        `|${getTranslationByKey("oceans")},oceans` +
                        `|${getTranslationByKey("pomegranate")},pomegranate` +
                        `|${getTranslationByKey("sandstone")},sandstone` +
                        `|${getTranslationByKey("stormtrooper")},stormtrooper` +
                        `|${getTranslationByKey("valley-of-the-wind")},valley of the wind`;
                    query.attribute = query.selection;
                break;
                // Screen Menu Free Text Responses
                case 'static_character_details_pronoun':
                    query.title = `${getTranslationByKey("possessive-pronoun")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_character_points_base':
                    query.title = `${getTranslationByKey("character-point-base")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_character_points_gained':
                    query.title = `${getTranslationByKey("character-point-gained")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_character_points_temp':
                    query.title = `${getTranslationByKey("character-point-temporary")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_sheet_settings_player':
                    query.title = `${getTranslationByKey("player-name")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_character_details_height':
                    query.standard = 0;
                    query.template = getSizeTemplate(cache);
                    query.title = 
                        `${getTranslationByKey("enter-height-in")} ${query.template.height.unit[query.standard]} (` +
                        `${query.template.height.min[query.standard]}-` +
                        `${query.template.height.max[query.standard]})`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_character_details_weight':
                    query.standard = 0;
                    query.template = getSizeTemplate(cache);
                    query.title = 
                        `${getTranslationByKey("enter-weight-in")} ${query.template.mass.unit[query.standard]} (` +
                        `${query.template.mass.min[query.standard]}-` +
                        `${query.template.mass.max[query.standard]})`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_character_details_race':
                    query.title = `${getTranslationByKey("enter-character-race")}`;
                    query.options = cache[cache.source] === undefined ? '' : `|${cache[cache.source]}`;
                    query.attribute = query.selection;
                break;
                case 'static_character_details_class':
                    query.title = `${getTranslationByKey("enter-character-class")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_sheet_settings_gm':
                    query.title = `${getTranslationByKey("enter-game-master-name")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                // Stats Menu Options Root
                case 'statsroot':
                    query.title = `Choose Stat to edit`;
                    query.options = 
                        `|${getTranslationByKey("body")},statbody` +
                        `|${getTranslationByKey("mind")},statmind` +
                        `|${getTranslationByKey("soul")},statsoul`;
                break;
                // Stats Menu Options Level 1
                case 'statbody':
                case 'statmind':
                case 'statsoul':
                    query.stat = query.selection.slice(4);
                    query.title = `${getTranslationByKey("choose-task")}`;
                    query.options = 
                        `|${getTranslationByKey("base")},statbase` +
                        `|${getTranslationByKey("temp")},stattemp` +
                        `|${getTranslationByKey("damage")},statdamage` +
                        `|${getTranslationByKey("go-back")},statsroot`;
                break;
                // Stats Menu Options Level 2
                case 'statbase':
                case 'stattemp':
                case 'statdamage':
                    query.point_type = query.selection.slice(4);
                    query.title = `${getTranslationByKey("choose-method")}`;
                    query.options = 
                        `|${getTranslationByKey("add-value")},addstatpoints` +
                        `|${getTranslationByKey("remove-value")},removestatpoints` +
                        `|${getTranslationByKey("set-value")},setstatpoints` +
                        `|${getTranslationByKey("go-back")},statsroot`;
                break;
                case 'addstatpoints':
                case 'removestatpoints':
                case 'setstatpoints':
                    query.point_method = query.selection.slice(0, query.selection.length - 10);
                    query.title = 
                        `${getTranslationByKey("enter-value")}`;
                    query.options = '';
                    query.attribute = 'stats_points';
                break;
                // Status Menu Options Root
                case 'statusroot':
                    query.title = `${getTranslationByKey("choose-section-to-edit")}`;
                    query.options = 
                        `|${getTranslationByKey("conditions")},conditions` +
                        `|${getTranslationByKey("energy-points")},energy` +
                        `|${getTranslationByKey("health-points")},health`;
                    query.options += cache.rulesdb.rules_optional_sanity_status ?
                        `|${getTranslationByKey("sanity-points")},sanity` : '';
                    query.options += cache.rulesdb.rules_optional_society_status ?
                        `|${getTranslationByKey("society-points")},society` : '';
                break;
                // Status Menu Options Level 1
                case 'conditions':
                    query.title = `${getTranslationByKey("choose-task")}`;
                    query.options = 
                        `|${getTranslationByKey("add-condition")},addcondition`;
                    query.options += cache.condition_ids.length !== 0 ?
                        `|${getTranslationByKey("remove-condition")},removecondition` : '';
                    query.options += 
                        `|${getTranslationByKey("go-back")},statusroot`;
                break;
                case 'energy':
                case 'health':
                case 'sanity':
                case 'society':
                    query.get_attrs = [
                        `static_character_${query.selection}_base`,
                        `static_character_${query.selection}_temp`,
                        `static_character_${query.selection}_damage`,
                    ];
                    if (query.selection === 'health') {
                        query.get_attrs.push(`static_character_${query.selection}_stun`);
                    }
                    query.point_section = query.selection;
                    query.title = `${getTranslationByKey("choose")} ${query.selection.capitalize()} ` +
                        `${getTranslationByKey("point-type")}`;
                    query.options = 
                            `|${getTranslationByKey("damage")},damage` +
                            `|${getTranslationByKey("temp")},temp`;
                    query.options += query.selection === 'health' ?
                        `|${getTranslationByKey("stun")},stun` : '';
                    query.options += `|${getTranslationByKey("go-back")},statusroot`;
                break;
                case 'damage':
                case 'temp':
                case 'stun':
                    query.point_type = query.selection;
                    query.title = `${getTranslationByKey("choose-method")}`;
                    query.options = 
                            `|${getTranslationByKey("add-value")},addpoints` +
                            `|${getTranslationByKey("remove-value")},removepoints` +
                            `|${getTranslationByKey("set-value")},setpoints` +
                            `|${getTranslationByKey("go-back")},statusroot`;
                break;
                case 'addpoints':
                case 'removepoints':
                case 'setpoints':
                    query.point_method = query.selection;
                    query.title = 
                        `${getTranslationByKey("enter-value")}`;
                    query.options = `|${cache.statsdb[query.point_section][query.point_type]}`;
                    query.attribute = 'status_points';
                break;
                // Status Menu Options Level 2
                case 'addcondition':
                    query.title = `${getTranslationByKey("choose-condition")}`;
                    query.options = await buildConditionsMenu(cache);
                    query.attribute = 'repeating_condition';
                break;
                case 'removecondition':
                    query.title = `${getTranslationByKey("remove-condition")}?`;
                    query.options = await buildActiveConditionsMenu(cache);
                    query.attribute = 'delete_condition';
                break;
                // Time Elapse Menu Options
                case 'timeelapseroot':
                    query.title = `${getTranslationByKey("choose-task")}`;
                    query.options = 
                        `|1 ${getTranslationByKey("round")},round` +
                        `|n ${getTranslationByKey("rounds").capitalize()},rounds` +
                        `|${getTranslationByKey("one-minute-or-dramatic-scene").capitalize()},minute` +
                        `|n ${getTranslationByKey("minutes-time")},minutes` +
                        `|1 ${getTranslationByKey("hour")},hour` +
                        `|n ${getTranslationByKey("hours")},hours` +
                        `|1 ${getTranslationByKey("day")},day` +
                        `|n ${getTranslationByKey("days")},days` +
                        `|${getTranslationByKey("go-back")},statusroot`;
                    query.attribute = 'time_elapsed';
                break;
                // Time Elapse Menu Options Level 1
                case 'rounds':
                case 'minutes':
                case 'hours':
                case 'days':
                    const number_of = 
                        query.selection === 'rounds' ? '1-20' :
                        query.selection === 'minutes' ? '1-60' :
                        query.selection === 'hours' ? '1-24' :
                        query.selection === 'days' ? '1+' : '';
                    query.title = `${getTranslationByKey("enter-number-of")} ` +
                        `${query.selection} (${number_of})`;
                    query.options = '';
                    query.time_unit = query.selection;
                break;
                // End of all menu options
                // Final result captured in query.answer
                default:
                    query.answer = query.selection;
            }
            if (query.answer === undefined) await crpQuery(cache, query);
        }
        switch (query.attribute) {
            case 'static_character_details_height':
                if (query.standard === 0) {
                    query.answer = `${parseFloat(query.answer)} ` +
                        `${query.template.height.unit_abv[query.standard]}`;
                } else {
                    query.feet = Math.floor(int(query.answer)/12);
                    query.inches = query.answer-(query.feet*12);
                    query.answer = `${query.feet}' ${query.inches}"`;
                }
            break;
            case 'static_character_details_weight':
                query.answer = `${parseFloat(query.answer)} ` +
                    `${query.template.mass.unit_abv[query.standard]}`;
            break;
            case 'static_character_points_base':
            case 'static_character_points_gained':
            case 'static_character_points_temp':
                const points = {};
                clog(cache, points, 'Character Points Accounting(points)');
                points.base = query.attribute === 'static_character_points_base' ?
                    int(query.answer) : 
                    int(cache.statsdb.cp.base);
                points.gained = query.attribute === 'static_character_points_gained' ?
                    int(query.answer) : 
                    int(cache.statsdb.cp.gained);
                points.temp = query.attribute === 'static_character_points_temp' ?
                    int(query.answer) : 
                    int(cache.statsdb.cp.temp);
                points.total = points.base + points.gained + points.temp;
                points.spent = getSpentCharacterPoints(cache);
                points.remaining = points.total - points.spent;
                set_values.static_character_points_total = points.total;
                set_values.static_character_points_remaining = points.remaining;
                const point_types = ['base','gained','temp','spent'];
                for (let i = 0; i < 4; i++) {
                    cache.statsdb.cp[point_types[i]] = points[point_types[i]];
                    set_values[`static_character_points_${point_types[i]}`] = 
                        points[point_types[i]];
                }
            break;
            case 'static_sheet_settings_theme':
                cache.newValue = query.answer.toLowerCase();
                cache.previousValue = cache.static_sheet_settings_theme;
                setTheme(cache, set_values, query.answer);
            break;
            case 'repeating_condition': // Add condition
                cache.condition_id = getConditionID(cache, query.selection);
                if (!cache.condition_id) {
                    return; //=> whisper to character can't add existing condition type
                } else {
                    //=> create new or stackable condition
                    cache.condition_ids = await getSectionIDsAsync('condition');
                    await setConditiondb(cache, set_values, query.selection);
                    set_values[`repeating_condition_${cache.condition_id}_name`] = 
                        query.selection.capitalize();
                }
                set_values[`repeating_condition_${cache.condition_id}_description`] = 
                    await getConditionDescription(cache, query.selection);
                commit_changes = false;
            break;
            case 'delete_condition':
                if (query.answer === 'no') { break; }
                cache.remove = query.selection.split('~');
                cache.condition = {
                    name: cache.remove[0],
                    id: cache.remove[1]
                };
                removeConditiondbEntry(cache, set_values);
                removeRepeatingRow(`repeating_condition_${cache.condition.id}`);
                commit_changes = false;
            break;
            case 'status_points':
                query.attribute = `static_character_${query.point_section}_${query.point_type}`;
                query.point_change = int(query.answer);
                if (query.point_method === 'addpoints') {
                    cache.statsdb[query.point_section][query.point_type] += query.point_change;
                } else if (query.point_method === 'removepoints') {
                    cache.statsdb[query.point_section][query.point_type] -= query.point_change;
                } else {
                    cache.statsdb[query.point_section][query.point_type] = query.point_change;
                }
                query.point_max = cache.statsdb[query.point_section].base + cache.statsdb[query.point_section].temp;
                query.point_loss = cache.statsdb[query.point_section].damage + (
                    query.point_section === 'health' ?
                        cache.statsdb.health.stun : 0
                );
                query.answer = cache.statsdb[query.point_section][query.point_type];
                setStatusStateDescription(cache, set_values, query.point_section, query.point_max, query.point_loss);
            break;
            case 'time_elapsed':
                const time_elapse = {};
                time_elapse.conditions = [
                    'anemic',
                    'blinded',
                    'continuing',
                    'demoralized',
                    'drained',
                    'force field',
                    'incapacitated',
                    'irritant',
                    'lethargic',
                    'serious injury',
                    'unconscious'
                ];
                for (let i = 0; i < time_elapse.conditions.length; i++) {
                    const current_condition = time_elapse.conditions[i] === 'force field' ?
                        cache.attrdb[`${time_elapse.conditions[i]}`] : 
                        cache.conditiondb[`${time_elapse.conditions[i]}`];
                    if (current_condition.length !== 0) {
                        query.time_unit = query.time_unit === undefined ?
                            query.selection : query.time_unit;
                        time_elapse.rounds = 
                            query.time_unit === 'round' ? 1 :
                            query.time_unit === 'rounds' ? query.selection :
                            query.time_unit === 'minute' ? 20 :
                            query.time_unit === 'minutes' ? query.selection * 20 :
                            query.time_unit === 'hour' ? 1200 :
                            query.time_unit === 'hours' ? query.selection * 1200 :
                            query.time_unit === 'day' ? 28800 :
                            query.time_unit === 'days' ? query.selection * 28800 :
                            Infinity;
                        for (let x = 0; x < current_condition.length; x++) {
                            
                            if (time_elapse.conditions[i] === 'force field') {
                                const ar_index = current_condition[x].config.findIndex(c => c.name === 'armor rating');
                                const has_regenerating = current_condition[x].enhancements.findIndex(c => c.name === 'regenerating') !== -1;
                                if (
                                    (
                                        current_condition[x].active === false &&
                                        current_condition[x].config[ar_index].rank < current_condition[x].elevel * 10
                                    ) || has_regenerating
                                ) {
                                    current_condition[x].config[ar_index].rank += time_elapse.rounds * 10;
                                    current_condition[x].config[ar_index].rank = 
                                        current_condition[x].config[ar_index].rank > current_condition[x].elevel * 10 ?
                                            current_condition[x].elevel * 10 : current_condition[x].config[ar_index].rank;

                                    current_condition[x].config.sort();
                                    let config_display = '';
                                    for (let i = 0; i < current_condition[x].config.length; i++) {
                                        config_display += `${current_condition[x].config[i].name.capitalize()} (${
                                            isNaN(current_condition[x].config[i].rank) ?
                                            current_condition[x].config[i].rank.capitalize() : 
                                            int(current_condition[x].config[i].rank)
                                        })\n`;
                                    }
                                    set_values[`repeating_attribute_${current_condition[x].row_id}_configuration`] = config_display;
                                }
                            } else {
                                time_elapse.rounds_remining =
                                    current_condition[x].duration - time_elapse.rounds;
                                current_condition[x].duration = time_elapse.rounds_remining;
                                time_elapse.condition_displays_rounds = [
                                    'blinded',
                                    'continuing',
                                    'unconscious'
                                ].indexOf(time_elapse.conditions[i]) !== -1;
                                if (time_elapse.condition_displays_rounds) {
                                    current_condition[x].input1 = time_elapse.rounds_remining;
                                } else if (time_elapse.conditions[i] === 'drained') {
                                    const drained = {};
                                    drained.answer = Math.ceil(time_elapse.rounds_remining / 1200);
                                    drained.stat = current_condition[x].input1.toLowerCase();
                                    drained.point_type = 'damage';
                                    drained.point_method = 'set';
                                    current_condition[x].input2 = drained.answer * -1;
                                    await setStat(cache, drained, set_values);
                                    await setDerivedValues(cache, set_values);
                                }
                                if (time_elapse.rounds_remining < 1) {
                                    cache.condition = {
                                        name: time_elapse.conditions[i],
                                        id: current_condition[x].id
                                    };
                                    removeConditiondbEntry(cache, set_values);
                                    removeRepeatingRow(`repeating_condition_${cache.condition.id}`);
                                } else {
                                    cache.condition_id = current_condition[x].id;
                                    set_values[`repeating_condition_${cache.condition_id}_description`] = 
                                    await getConditionDescription(cache, time_elapse.conditions[i]);
                                }
                            }
                        }
                    }
                }
                commit_changes = false;
            break;
            case 'stats_points':
                query.stat = cache.source_id;
                query.point_type = cache.source_attribute;
                await setStat(cache, query, set_values);
                await setDerivedValues(cache, set_values);
                commit_changes = false;
            break;
            case 'static_sheet_settings_type':
                set_values.static_sheet_state_type = query.answer.toLowerCase();
                set_values.static_sheet_settings_gm = cache.character_name;
                if (set_values.static_sheet_state_type === 'gm') {
                    cache.rulesdb = {
                        "rules_attribute_deathdodge_status":0,
                        "rules_attribute_debilitate_status":0,
                        "rules_attribute_eknockback_status":0,
                        "rules_attribute_expertise_status":0,
                        "rules_attribute_extradefenses_status":0,
                        "rules_attribute_flankdefense_status":0,
                        "rules_attribute_hardboiled_status":0,
                        "rules_attribute_miniobject_status":0,
                        "rules_attribute_speedburst_status":0,
                        "rules_attribute_taunt_status":0,
                        "rules_attribute_tournament_status":0,
                        "rules_defect_nohealing_status":0,
                        "rules_enhancement_absorption_status":0,
                        "rules_enhancement_cognition_status":0,
                        "rules_enhancement_conversion_status":0,
                        "rules_enhancement_forcefield_status":0,
                        "rules_enhancement_powerflux_status":0,
                        "rules_enhancement_sixthsense_status":0,
                        "rules_enhancement_sizechange_status":0,
                        "rules_enhancement_summoncreatures_status":0,
                        "rules_enhancement_teleport_status":0,
                        "rules_enhancement_transfer_status":0,
                        "rules_enhancement_weapon_status":0,
                        "rules_homebrew_ammotracking_status":0,
                        "rules_homebrew_depletereserve_status":0,
                        "rules_homebrew_disperse_status":0,
                        "rules_homebrew_specificlimiter_status":0,
                        "rules_limiter_capped_status":0,
                        "rules_limiter_plantcontrol_status":0,
                        "rules_limiter_proportionaldamage_status":0,
                        "rules_limiter_skillflux_status":0,
                        "rules_limiter_timed_status":0,
                        "rules_limiter_transmute_status":0,
                        "rules_optional_criticalfailures_status":"none",
                        "rules_optional_criticalhits_status":"none",
                        "rules_optional_dice_status":"normal",
                        "rules_optional_enhancedrecovery_status":0,
                        "rules_optional_extradamage_status":0,
                        "rules_optional_genre_status":0,
                        "rules_optional_individual_status":0,
                        "rules_optional_knockback_status":0,
                        "rules_optional_knockout_status":0,
                        "rules_optional_maneuvers_status":0,
                        "rules_optional_mos_status":0,
                        "rules_optional_movementpenalties_status":0,
                        "rules_optional_rangepenalties_status":0,
                        "rules_optional_sanity_status":0,
                        "rules_optional_seriousinjury_status":0,
                        "rules_optional_shield_status":0,
                        "rules_optional_shockvalue_status":0,
                        "rules_optional_society_status":0,
                        "rules_optional_spreadinitiative_status":0,
                        "rules_optional_variable_status":"fixed"
                    };
                    await setBaseRules(cache, set_values);
                }
            break;
        }
        if (commit_changes) {
            set_values[query.attribute] = 
                query.answer === 'besm' ? 'BESM' : (
                    cache.source === 'static_sheet_settings_type' ||
                    cache.source === 'static_sheet_settings_theme' ||
                    cache.source === 'static_character_details_size'
                ) ? query.answer.capitalize() :
                query.answer;
        }
    }

    async function skillsMenu(cache, set_values) {
        const query = {} ;
        clog(cache, query,'skillsMenu()');
        const skills_cost = {
            "acrobatics":[3,3,3,2,2,3,2,1,2,2,3,2,2,2,2,2,3,2,2,3,1,1,2,3,2,1,2,2,1,2],
            "animal training":[2,2,2,1,1,1,1,2,1,2,3,2,2,2,1,1,1,2,1,1,1,2,1,2,2,1,2,1,2,3],
            "architecture":[1,1,2,1,1,1,1,1,1,2,1,1,1,1,2,1,1,2,1,1,1,2,1,2,2,3,2,2,1,1],
            "area knowledge":[2,2,3,2,3,2,2,2,2,2,2,2,2,3,2,1,2,3,1,3,2,3,2,2,1,2,1,1,2,1],
            "artisan":[1,1,1,1,1,1,1,2,1,2,2,1,1,1,1,1,1,2,1,1,1,2,2,2,2,2,2,2,2,2],
            "biological sciences":[2,2,2,2,2,2,2,1,3,2,3,1,1,1,3,3,1,3,2,2,1,1,1,1,1,1,1,1,1,1],
            "boating":[2,2,1,1,2,1,1,1,2,1,1,2,2,2,2,2,2,1,1,1,2,2,3,1,2,1,2,1,1,1],
            "burglary":[2,2,2,2,3,2,2,1,2,1,2,2,2,2,2,1,2,2,2,2,2,1,3,2,2,1,2,2,1,2],
            "business":[1,1,1,1,1,1,1,2,1,2,1,1,2,1,2,1,2,1,1,2,1,2,1,1,1,3,1,1,1,1],
            "civilisation":[2,1,1,1,1,1,1,1,2,2,3,3,2,1,2,1,2,2,2,3,2,3,1,1,1,2,1,2,1,1],
            "climbing":[2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,1,1,2,2,1,2,1,3,1,1,1,1,2,2,1],
            "computers":[2,3,1,3,3,3,2,2,3,2,0,0,0,2,3,3,3,2,2,2,2,0,0,0,0,0,0,0,0,0],
            "controlled breathing":[1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1],
            "cultural arts":[1,1,1,1,1,1,2,2,1,2,2,1,1,2,1,1,2,1,2,1,1,2,1,2,2,2,1,2,1,1],
            "demolitions":[2,3,2,1,2,3,1,1,2,1,1,1,1,1,2,1,3,2,1,1,2,1,2,1,1,1,1,1,0,2],
            "disguise":[2,2,2,2,2,3,2,2,3,2,1,2,2,2,2,1,1,1,1,3,2,1,2,2,2,1,2,2,1,2],
            "domestic arts":[1,1,1,1,1,2,3,3,1,1,1,1,2,1,1,1,1,2,2,1,1,2,2,2,1,2,2,2,3,2],
            "driving":[2,3,1,2,3,2,2,2,2,2,0,0,0,2,2,2,3,2,2,2,3,1,1,1,1,1,1,3,2,1],
            "engineering":[2,1,2,2,1,1,1,1,2,2,2,2,1,1,3,3,3,2,1,2,2,2,1,1,2,3,1,3,1,1],
            "environmental sciences":[1,1,1,1,2,1,2,1,2,2,3,2,1,1,2,3,2,3,2,2,1,2,1,1,2,2,1,1,1,1],
            "electronics":[2,2,1,2,2,2,1,1,2,2,1,1,1,1,3,3,3,2,2,2,2,0,0,0,0,0,0,0,0,0],
            "empathy":[1,1,2,2,2,1,3,3,1,3,3,2,2,2,2,1,2,3,2,2,1,2,2,1,1,2,1,2,2,1],
            "etiquette":[1,1,1,1,1,1,2,2,1,1,2,2,1,1,1,1,2,1,1,1,1,2,1,3,2,2,1,2,1,1],
            "forgery":[1,1,1,1,2,1,2,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1],
            "gaming":[1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,3],
            "interrogation":[2,2,2,2,3,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,1,2],
            "intimidation":[2,3,2,3,2,2,2,1,2,3,2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,3,2,2,3,2],
            "languages":[1,1,1,2,1,1,1,2,1,3,2,2,1,1,1,1,1,1,3,1,1,2,2,1,1,2,1,1,1,1],
            "law":[1,1,1,1,3,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,2,1,1,1,2],
            "leadership":[1,2,2,2,2,1,2,1,2,3,1,1,2,2,2,2,3,2,2,2,2,3,2,3,2,2,2,2,3,3],
            "listening":[2,1,3,2,2,2,2,1,2,2,2,2,2,2,2,1,1,2,2,2,2,1,2,1,1,1,2,2,1,2],
            "mechanics":[2,2,1,1,2,1,1,2,2,2,1,1,1,2,2,2,3,3,2,2,2,2,1,1,1,3,1,3,0,1],
            "medical":[2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,3,2,2,2,3,2,2,2,2,3,2,1,2],
            "military sciences":[2,2,2,2,2,1,1,1,2,1,2,3,2,1,2,2,3,2,2,2,3,2,2,2,2,1,2,2,1,2],
            "naturopathy":[1,1,1,1,1,1,1,2,1,3,3,2,2,1,2,1,1,2,2,1,1,1,1,1,2,1,1,1,3,2],
            "navigation":[1,1,1,1,1,1,1,1,1,1,2,2,2,1,1,2,3,2,2,3,2,2,3,2,2,2,2,2,2,2],
            "occult":[2,1,1,3,1,1,1,1,2,3,3,3,2,3,1,1,1,1,1,1,1,1,1,2,1,1,2,2,2,2],
            "occupation":[1,1,1,1,1,2,1,2,1,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1],
            "performing arts":[1,1,2,1,2,2,2,2,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1],
            "persuasion":[3,3,2,1,2,2,3,2,3,2,2,2,2,2,2,2,2,2,2,3,2,2,3,2,2,2,2,2,2,2],
            "physical sciences":[2,1,1,1,2,2,1,1,2,2,2,1,1,1,1,3,2,2,2,2,1,1,1,1,1,2,1,2,1,1],
            "piloting":[2,2,1,2,2,2,1,1,2,1,1,1,0,1,2,2,2,2,2,3,3,0,0,0,0,0,0,3,0,0],
            "poisons":[1,1,1,1,1,1,1,1,2,1,2,2,2,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1],
            "police sciences":[2,2,1,2,3,1,1,1,2,1,1,1,1,2,2,2,2,1,1,1,1,1,0,0,0,1,0,1,0,1],
            "power lifting":[2,3,2,2,2,3,1,1,2,1,1,2,2,2,2,2,1,1,1,2,2,1,2,2,1,1,2,2,3,2],
            "religion":[1,1,1,3,1,1,1,1,2,3,2,2,2,2,1,1,1,1,1,2,1,2,1,2,3,1,2,1,1,1],
            "riding":[1,1,1,1,1,1,1,1,1,1,2,2,2,1,1,1,1,2,1,1,1,2,2,3,2,1,3,1,2,3],
            "search":[2,2,2,2,3,1,1,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2],
            "seduction":[2,2,2,2,2,1,3,2,2,3,2,2,2,2,2,2,3,2,3,2,2,2,3,2,2,2,2,2,2,3],
            "sleight of hand":[2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,1,2,1,2,1,1,1,1,1,1,2],
            "social sciences":[1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,2,2,2,3,1,1,2,1,1,1,1,1,2,1,1],
            "sports":[1,1,1,1,1,2,2,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1,1,1,1,1],
            "stealth":[3,2,3,2,2,2,2,2,3,2,2,2,3,3,2,2,2,3,2,2,2,2,2,2,2,1,2,2,2,2],
            "street sense":[2,2,1,2,3,2,2,2,3,2,1,1,2,2,3,2,2,3,2,2,2,1,2,2,2,2,3,1,1,2],
            "survival":[2,2,3,2,2,2,1,1,2,2,2,2,3,1,1,1,1,3,1,1,2,2,3,2,2,2,2,2,3,2],
            "swimming":[1,1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1],
            "urban tracking":[2,1,2,3,3,1,2,1,2,3,1,1,1,2,3,1,2,2,1,1,2,1,1,1,1,2,2,1,0,2],
            "visual arts":[1,1,1,1,1,1,2,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1],
            "wilderness tracking":[1,1,2,1,1,1,1,1,1,1,2,2,2,1,1,1,1,2,1,1,2,2,3,2,2,1,2,2,3,2],
            "writing":[1,1,1,1,1,1,2,2,1,2,2,1,1,2,1,1,1,1,1,1,1,2,1,1,1,2,1,2,1,1]
        };
        const skill_stats = {
            'acrobatics':["body"],
            'animal training':["soul"],
            'architecture':["mind"],
            'area knowledge':["mind"],
            'artisan':["body","soul"],
            'biological sciences':["mind"],
            'boating':["body","mind"],
            'burglary':["variable"],
            'business':["mind"],
            'civilisation':["mind"],
            'climbing':["body"],
            'computers':["mind"],
            'controlled breathing':["variable"],
            'cultural arts':["mind"],
            'demolitions':["variable"],
            'disguise':["variable"],
            'domestic arts':["variable"],
            'driving':["variable"],
            'engineering':["mind"],
            'environmental sciences':["mind"],
            'electronics':["mind"],
            'empathy':["soul"],
            'etiquette':["mind"],
            'forgery':["mind"],
            'gaming':["variable"],
            'interrogation':["variable"],
            'intimidation':["variable"],
            'languages':["mind"],
            'law':["mind"],
            'leadership':["soul"],
            'listening':["body","soul"],
            'mechanics':["variable"],
            'medical':["variable"],
            'military sciences':["mind"],
            'naturopathy':["variable"],
            'navigation':["mind"],
            'occult':["mind"],
            'occupation':["mind"],
            'performing arts':["body","mind","soul"],
            'persuasion':["soul"],
            'physical sciences':["mind"],
            'piloting':["body","mind"],
            'poisons':["mind"],
            'police sciences':["mind"],
            'power lifting':["body"],
            'religion':["variable"],
            'riding':["variable"],
            'search':["mind"],
            'seduction':["variable"],
            'sleight of hand':["body"],
            'social sciences':["mind"],
            'sports':["variable"],
            'stealth':["variable"],
            'street sense':["variable"],
            'survival':["variable"],
            'swimming':["body"],
            'urban tracking':["mind"],
            'visual arts':["variable"],
            'wilderness tracking':["variable"],
            'writing':["mind","soul"]
        };
        query.next = cache.source_type === 'repeating' ? 
            `skill_${cache.source_attribute}` : cache.source;
        query.commit = false;
        cache.skill_index = cache.static_skills_visible_id;
        if (cache.source_type === 'repeating') {
            query.individual_index = 
                cache.attrdb.skills[cache.skill_index].individual.findIndex(i => i.row_id.toLowerCase() === cache.source_id);
            query.skill = 
                cache.attrdb.skills[cache.skill_index].individual[query.individual_index].skill;
        }
        while (!query.commit) {
            switch (query.next) {
                case 'select_task':
                    query.skill = '';
                    query.rank = 0;
                    query.specializations = [];
                    query.stat = [];
                    query.total = cache.attrdb.skills[cache.skill_index].individual.length;
                    query.title = `${getTranslationByKey("choose-task")}`;
                    query.options = `|${getTranslationByKey("add")},add`;
                    query.options += query.total !== 0 ? 
                        `|${getTranslationByKey("edit")},edit` : '';
                    query.options += query.total !== 0 ? 
                        `|${getTranslationByKey("remove")},remove` : '';
                    query.options += `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'add_skill':
                case 'static_skills_add_button':
                    query.skill = '';
                    query.title = `${getTranslationByKey("add-skill")}`;
                    query.options = '';
                    for (let i = 0; i < all_skills.length; i++) {
                        query.options += 
                            cache.attrdb.skills[cache.skill_index].individual.findIndex(s => s.skill === all_skills[i]) === -1 ?
                            `|${getTranslationByKey(all_skills[i].toKebobCase())},${all_skills[i]}` : '';
                    }
                    if(query.options === '') {
                        query.title = '';
                    } else {
                        query.options += `|${getTranslationByKey("exit")},exit`;
                    }
                    query.last = query.next;
                break;
                case 'edit_skill':
                    query.title = `${getTranslationByKey("edit")}`;
                    query.options = '';
                    query.options = cache.attrdb.skills[cache.skill_index].individual.map((s, i) => {
                        return `|${s.skill.capitalize()},${i}`;
                    });
                    query.options += `|${getTranslationByKey("go-back")},select_task`;
                    query.last = query.next;
                break;
                case 'remove_skill':
                case 'static_skills_delete_button':
                    if (cache.attrdb.skills[cache.skill_index].individual.length === 0) {
                        query.title = '';
                        query.options = '';
                    } else {
                        query.title = 'Remove';
                        query.options = cache.attrdb.skills[cache.skill_index].individual.map((s, i) => {
                            return `|${s.skill.capitalize()},${s.skill}~${i}~${s.row_id}`;
                        });
                        query.options += `|${getTranslationByKey("exit")},exit`;
                    }
                    query.last = query.next;
                break;
                case 'remove_confirm':
                    query.title = `Confirm Remove ${query.remove[0].capitalize()}`;
                    query.options = `|No,${query.last}|Yes,yes`;
                    query.last = query.next;
                break;
                case 'skill_menu':
                    query.title = `${getTranslationByKey(query.skill.toKebobCase())}`;
                    query.options = 
                        `|${getTranslationByKey("rank")} [ ${query.rank} ],select_rank` +
                        `|${getTranslationByKey("specializations")} [ ${query.specializations.length} ],` +
                            `select_specializations` +
                        `|${getTranslationByKey("stat")} [ ${
                            query.stat.length === 1 ? 
                                query.stat[0].capitalize() : 'Avg ' + query.stat.capitalize().join("+")
                        } ],select_stat` +
                        `|${getTranslationByKey("go-back")},${query.task}_skill` +
                        `|${getTranslationByKey("done")},${
                            query.task === 'edit' ? 'update_skill' : 'write_newskill'
                        }`;
                    query.last = query.next;
                break;
                case 'select_rank':
                case 'skill_rank':
                    query.title = `${getTranslationByKey(query.skill.toKebobCase())} ` +
                        `${getTranslationByKey("rank")}`;
                    query.options = '';
                    query.last = query.next;
                break;
                case 'custom_specialization':
                    query.title = `${getTranslationByKey(query.selection)}`;
                    query.options = '';
                    query.last = query.next;
                    query.next = 'skill_specializations';
                break;
                case 'select_specializations':
                case 'skill_specializations':
                    const skill_specializations = {
                        'acrobatics':['balance','flexibility','jumps','tumbling'],
                        'animal training':['any-single-animal'],
                        'architecture':['aquatic','bridges','fortifications','small-buildings','skyscrapers'],
                        'area knowledge':['one-specific-locale'],
                        'artisan':['bowyer-fletcher','blacksmith','carpentry','enchanting-objects','leatherworking','metalworking','plumbing','pottery','tailoring','woodworking'],
                        'biological sciences':['astrobiology','bacteria-viruses','bioengineering','botany','genetics','physiology','zoology'],
                        'boating':['hovercraft','hydrofoils','large-ships','small-boats','submarines'],
                        'burglary':['breaking-and-entering','disarming-physical-traps','hot-wiring','safe-cracking'],
                        'business':['accounting','administration','economics','executive','fraud','government','management','marketing','negotiating','sales'],
                        'civilisation':['one-specific-culture-or-population'],
                        'climbing':['natural-surfaces','poles','ropes','vegetation','walls'],
                        'computers':['artificial-intelligence','cryptography','databases','electronic-warfare','intrusion-security','networks','programming'],
                        'controlled breathing':['calm','cyclic-breathing','holding-breath','slow-heart-rate'],
                        'cultural arts':['gastronomy','history','literature','mythology','nobility','philosophy','rare-object-appraisal','urban-legends'],
                        'demolitions':['artificial-structures','bomb-disposal','natural-structures','safe-cracking','underwater'],
                        'disguise':['costume','impersonation','make-up','prosthetics'],
                        'domestic arts':['childrearing','cleaning','cooking','decorating','gardening','home-budgeting'],
                        'driving':['armored-fighting-vehicle','bicycle','big-rig','bus','car','giant-robot','motorcycle','small-truck','teamster','walker'],
                        'engineering':['communications','computers','consumer-electronics','robotics','security','sensors'],
                        'environmental sciences':['body-language','calming','interpreting-words','intuition','lie-detection','listening'],
                        'electronics':['aerospace','agricultural','biomedical','chemical','civil','computer','electrical','environmental','mechanical','mining'],
                        'empathy':['climatology','ecology','geology','geography','geophysics','hydrology','meteorology','oceanography'],
                        'etiquette':['alien','lower-class','middle-class','upper-class'],
                        'forgery':['artwork','electronic-documents','financial-notes','handwriting','paper-documents','physical-objects'],
                        'gaming':['board-games','card-games','computer-games','gambling','military-simulations','role-playing-games'],
                        'interrogation':['business','drugs','physical','psychological','spiritual'],
                        'intimidation':['business','emotional','political','physical','spiritual','street'],
                        'languages':['any-one-language','braille','code-language','lip-reading','sign-language'],
                        'law':['civil','criminal','customs','family','international','political','real-estate'],
                        'leadership':['business','co-operative','political','spiritual','strategic','transformational'],
                        'listening':['background-noise','discrimination','eavesdropping','spiritual'],
                        'mechanics':['aeronautical','armorer','automotive','gunsmith','locksmith','nanotechnology','traps'],
                        'medical':['chiropractic','dentistry','diagnosis','emergency-response','family-practice','nursing','obstetrics','pathology','pharmacy','surgery','veterinary'],
                        'military sciences':['hardware-recognition','intelligence-analysis','logistics','strategy','tactics','teamwork'],
                        'naturopathy':['acupuncture','aromatherapy','herbalism','homoeopathy','massage-therapy','reflexology'],
                        'navigation':['air','highway','sea','space','undersea','urban','wilderness'],
                        'occult':['astrology','augury','channeling','dream-interpretation','numerology','rituals','spell-craft','spirits','tarot','voodoo','witchcraft'],
                        'occupation':['one-specific-occupation'],
                        'performing arts':['comedy','dance','drama','musical-instrument','public-speaking','singing'],
                        'persuasion':['bluffing','bribery','diplomacy','emotional','fast-talking','hypnosis','logic','mediation','rhetoric','social-networking','storytelling'],
                        'physical sciences':['alchemy','astronomy','biochemistry','chemistry','mathematics','physics'],
                        'piloting':['giant-robot','heavy-airplane','helicopter','jet-fighter','light-airplane','lighter-than-air-craft','spacecraft'],
                        'poisons':['alien','natural','synthetic','technological'],
                        'police sciences':['ballistics','community-policing','criminology','forensics','international'],
                        'power lifting':['bulky-objects','free-weights','humans','moving-objects','small-objects'],
                        'religion':['academic','dogma','congregational','context','enlightenment','guidance','interpretation','scripture'],
                        'riding':['by-species'],
                        'search':['compartments','detail-work','electronics','irregularities'],
                        'seduction':['emotional','mental','physical','political','social','spiritual','verbal'],
                        'sleight of hand':['card-sharking','lock-picking','pick-pocketing','stage-magic'],
                        'social sciences':['archaeology','anthropology','communication','education','politics','psychology','social-work','sociology'],
                        'sports':['one-specific-sport'],
                        'stealth':['camouflage','concealment','silent-movement'],
                        'street sense':['gang-activity','influential-individuals','territorial-divisions'],
                        'survival':['aquatic','arctic','desert','dimensional','forest','jungle','mountain','plains'],
                        'swimming':['aquabatics','competition','deep-sea-diving','free-diving','recreational','scuba','snorkeling'],
                        'urban tracking':['academic','corporate','political','residential','underworld'],
                        'visual arts':['animation','carving','drawing','flower-arranging','painting','photography','sculpting','video'],
                        'wilderness tracking':['aquatic','arctic','desert','forest','jungle','mountain','plains'],
                        'writing':['academic','fiction','journalistic','poetic','religious','technical']
                    };
                    query.specializations = cache.attrdb.skills[cache.skill_index].individual[query.individual_index].specializations;
                    query.title = `${getTranslationByKey("select-specializations")}`;
                    query.options = '';
                    const custom_specializations = query.specializations.filter(s => !skill_specializations[`${query.skill}`].includes(s));
                    for (let i = 0; i < custom_specializations.length; i++) {
                        skill_specializations[`${query.skill}`].push(custom_specializations[i]);
                    }
                    for (let i = 0; i < skill_specializations[`${query.skill}`].length; i++) {
                        const bracket = 
                            query.specializations.findIndex(s => s === skill_specializations[`${query.skill}`][i]) !== -1;
                        const specialization = 
                            `${
                                getTranslationByKey(skill_specializations[`${query.skill}`][i]) ||
                                skill_specializations[`${query.skill}`][i]
                            }`;
                        query.options += `|${bracket ? '[ ' : ''}${specialization}${bracket ? ' ]' : ''},` +
                            `${skill_specializations[`${query.skill}`][i]}`;
                    }
                    query.options += `|${getTranslationByKey("unique-specialization")},unique-specialization` +
                        `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'select_stat':
                case 'skill_stat':
                    query.title = `${getTranslationByKey("select-stats")}`;
                    query.options = 
                        `|${getTranslationByKey("body")},body` +
                        `|${getTranslationByKey("mind")},mind` +
                        `|${getTranslationByKey("soul")},soul` +
                        `|Avg ${getTranslationByKey("body")}+${getTranslationByKey("mind")},body~mind` +
                        `|Avg ${getTranslationByKey("body")}+${getTranslationByKey("soul")},body~soul` +
                        `|Avg ${getTranslationByKey("mind")}+${getTranslationByKey("soul")},mind~soul` +
                        `|Avg ${getTranslationByKey("body")}+${getTranslationByKey("mind")}+${getTranslationByKey("soul")},body~mind~soul` +
                        `|${getTranslationByKey("variable")},variable` +
                        `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                default: query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.last) {
                    case 'select_task':
                        if (query.selection === 'exit') {
                            query.commit = true;
                            break;
                        } else {
                            query.task = query.selection;
                            query.next = `${query.task}_skill`;
                        }
                    break;
                    case 'add_skill':
                    case 'static_skills_add_button':
                        query.skill = query.selection === 'exit' || query.options === '' ?
                            '' : query.selection;
                        query.stat = skill_stats[query.skill];
                        query.next = query.selection === 'exit' || query.options === '' ?
                            'exit' : 'write_newskill';
                    break;
                    case 'edit_skill':
                        if (query.selection !== 'select_task') {
                            query.load = int(query.selection);
                            const skill = cache.attrdb.skills[cache.skill_index].individual[query.load];
                            const skill_settings = ['rank','row_id','skill','specializations','stat'];
                            for (let i = 0; i < skill_settings.length; i++) {
                                query[skill_settings[i]] = skill[skill_settings[i]];
                            }
                            query.skill_translation = query.skill.toKebobCase();
                        }
                        query.next = query.selection !== 'select_task' ?
                            'skill_menu' : query.selection;
                    break;
                    case 'remove_skill':
                    case 'static_skills_delete_button':
                        if (cache.attrdb.skills[cache.skill_index].individual.length === 0) {
                            query.next = 'exit';
                            query.commit = true;
                        } else if (query.selection === 'select_task') {
                            query.next = 'select_task';
                        } else {
                            query.remove = query.selection.split('~');
                            query.next = 'remove_confirm';
                        }
                    break;
                    case 'remove_confirm':
                        if (query.selection === 'yes') {
                            cache.attrdb.skills[cache.skill_index].individual.splice(int(query.remove[1]),1);
                            setSkillsPointTotal(cache, set_values);
                            removeRepeatingRow(`repeating_skill_${query.remove[2]}`);
                            query.next = 'exit'; //=> This is used just to exit the loop, end script.
                        } else {
                            query.next = query.selection;
                        }
                    break;
                    case 'skill_menu':
                        query.selection = query.selection.split("~");
                        if (query.selection.length === 2) {
                            query.index = int(query.selection[1]);
                        }
                        query.selection = query.selection[0];
                        if (query.selection === `${query.task}_skill`) {
                            query.rank = 0;
                            query.specializations = [];
                        }
                        query.next = query.selection === 'update_skill' || query.selection === 'write_newskill' ? 
                            'done' : query.selection;
                        query.last = query.selection === 'update_skill' || query.selection === 'write_newskill' ? 
                            query.selection : query.last;
                    break;
                    case 'select_rank':
                    case 'skill_rank':
                        if (isNaN(query.selection)) {
                            query.next = 'select_rank';
                        } else {
                            query.rank = int(query.selection);
                            query.next = 'write_skillrank';
                        }
                    break;
                    case 'select_specializations':
                    case 'custom_specialization':
                    case 'skill_specializations':
                        if (
                            query.selection === 'any-single-animal' ||
                            query.selection === 'one-specific-locale' ||
                            query.selection === 'one-specific-culture-or-population' ||
                            query.selection === 'one-specific-occupation' ||
                            query.selection === 'by-species' ||
                            query.selection === 'one-specific-sport' ||
                            query.selection === 'unique-specialization'
                        ) {
                            query.next = 'custom_specialization';
                        } else if (query.selection !== 'exit') {
                            query.spec_index = query.specializations.findIndex(s => s === query.selection);
                            if (query.spec_index === -1) {
                                query.specializations.push(query.selection);
                            } else {
                                query.specializations.splice(query.spec_index, 1);
                            }
                        }
                        query.next = query.next === 'custom_specialization' ? 'custom_specialization' :
                            query.selection === 'exit' ? 'exit' : 
                            'write_skillspecializations';
                    break;
                    case 'select_stat':
                    case 'skill_stat':
                        query.stat = query.selection === 'variable' ? 
                            [] : query.selection.split("~");
                        query.next = 'write_skillstat';
                    break;
                }
            } else {
                const skilldb = query.next === 'write_newskill' ?
                    cache.attrdb.skills[cache.skill_index].individual :
                    cache.attrdb.skills[cache.skill_index].individual[query.individual_index];
                const cost = query.next === 'exit' ? 0 : skills_cost[query.skill][cache.rulesdb.rules_optional_genre_status];
                switch (query.next) {
                    case 'write_newskill'://-> write skill object into cache and create repeating section
                        const fields = ['cost','points','rank','skill','specializations','stat'];
                        const row_id = generateRowID();
                        const attrdb_entry = {};
                        for (let i = 0; i < fields.length; i++) {
                            let value = '';
                            switch (fields[i]) {
                                case 'cost':
                                    value = cost;
                                break;
                                case 'points':
                                    query.points = 0;
                                    value = 0;
                                break;
                                case 'rank':
                                    query.rank = 0;
                                    value = 0;
                                break;
                                case 'skill':
                                    value = getTranslationByKey(query.skill.toKebobCase()).capitalize();
                                break;
                                case 'specializations':
                                    query.specializations = [];
                                break;
                                case 'stat':
                                    query.stat = skill_stats[query.skill];
                                    if (query.stat.length === 1) {
                                        value = getTranslationByKey(query.stat[0]).capitalize();
                                    } else {
                                        value = 'Avg ';
                                        const stat_translations = query.stat.map(s => getTranslationByKey(`${s}`).capitalize());
                                        value += stat_translations.join("+");
                                    }
                                break;
                            }
                            set_values[`repeating_skill_${row_id}_${fields[i]}`] = value;
                        }
                        attrdb_entry.points = cost * query.rank;
                        attrdb_entry.rank = query.rank;
                        attrdb_entry.row_id = row_id;
                        attrdb_entry.skill = query.skill;
                        attrdb_entry.specializations = query.specializations;
                        attrdb_entry.stat = query.stat;
                        attrdb_entry.active = true;
                        attrdb_entry.visibility = 1;
                        cache.attrdb.skills[cache.skill_index].individual.push(attrdb_entry);
                        set_values[`repeating_skill_${row_id}_active`] = 1;
                        setSkillsPointTotal(cache, set_values);
                    break;
                    case 'write_skillspecializations':
                        skilldb.specializations = query.specializations;
                        skilldb.points = (skilldb.rank * cost) + Math.max(0, skilldb.specializations.length - 1);
                        set_values[`${cache.source_path}_points`] = skilldb.points;
                        set_values[`${cache.source_path}_specializations`] = '';
                        for (let i = 0; i < query.specializations.length; i++) {
                            set_values[`${cache.source_path}_specializations`] += 
                                getTranslationByKey(query.specializations[i]) || query.specializations[i];
                            set_values[`${cache.source_path}_specializations`] += i !== query.specializations.length -1 ?
                                '\n' : '';
                        }
                        setSkillsPointTotal(cache, set_values);
                    break;
                    case 'write_skillrank':
                        skilldb.points = (cost * query.rank) + Math.max(0, skilldb.specializations.length - 1);
                        skilldb.rank = query.rank;
                        set_values[`${cache.source_path}_rank`] = query.rank;
                        set_values[`${cache.source_path}_points`] = skilldb.points;
                        setSkillsPointTotal(cache, set_values);
                    break;
                    case 'write_skillstat':
                        cache.attrdb.skills[cache.skill_index].individual[query.individual_index].stat = query.stat;
                        query.transpated_stat = query.stat.map(s => getTranslationByKey(s));
                        query.display_stat = `${query.transpated_stat.join('+')}`;
                        set_values[`${cache.source_path}_stat`] = query.display_stat;
                    break;
                }
            }
        }
    }

    async function rollMenu(cache, set_values) {
        const query = {};
        const button_supported = {
            "2d6": {
                "default": false,
            },
            "attack": {
                "target":true,
                "attribute":true,
                "maneuver":true,
                "enemy":true,
                "default": false,
            },
            "attribute": {
                "target":true,
                "attribute":true,
                "stat":true,
                "default": false,
            },
            "initiative": {
                "default": false,
            },
            "skill": {
                "attribute":true,
                "maneuver": cache.rulesdb.rules_optional_individual_status ? true : false,
                "target":true,
                "stat":true,
                "default": false,
            },
            "stat": {
                "target":true,
                "stat":true,
                "default": false,
            },
            
        };
        clog(cache, query, 'rollMenu()');
        query.next = cache.source_type === 'static' ? cache.source_id : cache.source_attribute;
        query.index = query.next !== 'add' ? cache.rolldb.findIndex(r => r.id.toLowerCase() === cache.source_id) : -1;
        query.commit = false;
        while (!query.commit) {
            switch (query.next) {
                case 'add':
                    query.fields = ['attribute','enemy','icon','maneuver','modifier','name','stat','target','type'];
                    query.title = '';
                    query.last = query.next;
                break;
                case 'attribute':
                    if (button_supported[cache.rolldb[query.index].type][cache.source_attribute || 'default']) {
                        const attributes = [];
                        query.type = 
                            cache.rolldb[query.index].type === 'attack' ? 'weapon' :
                            cache.rolldb[query.index].type;
                        query.title = getTranslationByKey(`${query.type === 'weapon' ?
                            'choose-attack' : 'choose-attribute'}`);
                        if (query.type === 'weapon') {
                            const translation = getTranslationByKey("weapon");
                            for (let i = 0; i < cache.attrdb.weapon.length; i++) {
                                if (cache.attrdb.weapon[i].active) {
                                    const name = cache.attrdb.weapon[i].name === '' ?
                                        translation : cache.attrdb.weapon[i].name;
                                    attributes.push(`${name},${name}~${i}~weapon`);
                                }
                            }
                        } else if (query.type === 'skill') {
                            const skilldb = cache.rulesdb.rules_optional_individual_status ?
                                cache.attrdb.skills : cache.attrdb['skill group'];
                            for (let i = 0; i < skilldb.length; i++) {
                                if (skilldb[i].active) {
                                    if (cache.rulesdb.rules_optional_individual_status) {
                                        for (let j = 0; j < skilldb[i].individual.length; j++) {
                                            attributes.push(
                                                `${skilldb[i].individual[j].skill.capitalize()},` +
                                                `${skilldb[i].individual[j].skill}~${i}~skills~${j}`
                                            );
                                        }
                                    } else {
                                        attributes.push(
                                            `${skilldb[i].name.capitalize()},` +
                                            `${skilldb[i].name}~${i}~skill group`
                                        );
                                    }
                                }
                            }
                        } else {
                            const filtered_attributes = all_attributes.map(a => {
                                return (a === 'skills' || a === 'skill group'|| a === 'weapon') ? '' : a;
                            }).filter(n => n);
                            for (let i = 0; i < filtered_attributes.length; i++) {
                                for (let j = 0; j < cache.attrdb[filtered_attributes[i]].length; j++) {
                                    const attribute = cache.attrdb[filtered_attributes[i]][j];
                                    if (attribute.active && attribute.stat !== 'none') {
                                        attributes.push(
                                            `${attribute.name === '' ? 
                                                getTranslationByKey(filtered_attributes[i].toKebobCase()) : 
                                                attribute.name},` +
                                            `${attribute.name}~${j}~${filtered_attributes[i]}`
                                        );
                                    }
                                }
                            }
                        }
                        if (attributes.length === 0 && query.type !== 'weapon') {
                            query.title = '';
                            clog(cache, `No ${query.type} found`, 'ERROR');
                            query.commit = true;
                        } else {
                            const unarmed = getTranslationByKey("unarmed");
                            const touch = getTranslationByKey("touch");
                            query.options = '|' + attributes.sort().join("|") +
                                `${query.type === 'weapon' ?
                                '|' + unarmed + ',' + unarmed + '~-1~unarmed' +
                                '|' + touch + ',' + touch + '~-1~touch' : 
                                '|' + getTranslationByKey("exit") + ',exit'
                            }`;
                        }
                        query.last = query.next;
                    } else {
                        clog(cache, 'Not Applicable', 'ERROR');
                        query.commit = true;
                    }
                break;
                case 'delete':
                    const rolls = [];
                    query.title = getTranslationByKey("remove");
                    for (let i = 0; i < cache.rolldb.length; i++) {
                        rolls.push(`${cache.rolldb[i].name},${cache.rolldb[i].id}`);
                    }
                    query.options = '|' + rolls.sort().join("|");
                    query.options += `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'enemy':
                    if (button_supported[cache.rolldb[query.index].type][cache.source_attribute || 'default']) {
                        query.title = getTranslationByKey("choose-enemy");
                        query.enemies = [];
                        const enemy_attrs = ['enemy attack','massive damage'];
                        for (let i = 0; i < enemy_attrs.length; i++) {
                            for (let j = 0; j < cache.attrdb[enemy_attrs[i]].length; j++) {
                                if (cache.attrdb[enemy_attrs[i]][j].active) {
                                    const enemy_index = cache.attrdb[enemy_attrs[i]][j].config.findIndex(c => c.name === 'enemy');
                                    if (enemy_index !== -1) {
                                        const enemy_name = cache.attrdb[enemy_attrs[i]][j].config[enemy_index].rank;
                                        let enemy_exists = query.enemies.length !== 0 ? query.enemies.findIndex(e => e === enemy_name) : -1;
                                        if (enemy_exists === -1) {
                                            enemy_exists = query.enemies.push({}) - 1;
                                            query.enemies[enemy_exists] = enemy_name;
                                        }
                                    }
                                }
                            }
                        }
                        query.options = `|${getTranslationByKey("none")},not-configured`;
                        query.options += '|' + query.enemies.map(e => `${e.capitalize()},${e}`).filter(n => n).sort().join("|");
                        query.options += `|${getTranslationByKey("exit")},exit`;
                        query.last = query.next;
                    } else {
                        clog(cache, 'Not Applicable', 'ERROR');
                        query.commit = true;
                    }
                break;
                case 'maneuver':
                    if (button_supported[cache.rolldb[query.index].type][cache.source_attribute || 'default']) {
                        if (cache.rolldb[query.index].type === 'skill' && cache.rulesdb.rules_optional_individual_status) {
                            query.title = getTranslationByKey("select-specialization");
                            const skill_index = cache.attrdb.skills.findIndex(s => s.row_id);
                            const individual_index = cache.attrdb.skills[skill_index].individual.findIndex(s => s.row_id);
                            const specializations = [...cache.attrdb.skills[skill_index].individual[individual_index].specializations];
                            query.options = `|${getTranslationByKey("none")},not-configured|`;
                            query.options += specializations.map(s => `${getTranslationByKey(s) || s.capitalize()},${s}`).sort().join("|");
                            query.options += `|${getTranslationByKey("exit")},exit`;
                        } else if (cache.rulesdb.rules_optional_maneuvers_status) {
                            query.title = getTranslationByKey("select-maneuver");
                            query.options =
                                `|${getTranslationByKey("attack")},attack` +
                                `|${getTranslationByKey("called-shot")},?{${getTranslationByKey("select-called-shot")}` +
                                    `&#124;${getTranslationByKey("bypass-armor")}&#44;bypass armor` +
                                    `&#124;${getTranslationByKey("disarm")}&#44;disarm`;
                                query.options += cache.rulesdb.rules_optional_knockout_status ?
                                    `&#124;${getTranslationByKey("knockout")}&#44;knockout` : '';
                                query.options +=
                                    `&#124;${getTranslationByKey("reduce-armor")}&#44;reduce armor` +
                                    `&#124;${getTranslationByKey("specific-location")}&#44;specific location` +
                                    `&#124;${getTranslationByKey("vital-spot")}&#44;vital spot` +
                                    `&#124;${getTranslationByKey("weak-point")}&#44;weak point&#125;` +
                                `|${getTranslationByKey("grapple")},?{${getTranslationByKey("select-grapping-maneuver")}` +
                                    `&#124;${getTranslationByKey("bite")}&#44;bite` +
                                    `&#124;${getTranslationByKey("grab")}&#44;grab` +
                                    `&#124;${getTranslationByKey("lock")}&#44;lock` +
                                    `&#124;${getTranslationByKey("pin")}&#44;pin` +
                                    `&#124;${getTranslationByKey("throw")}&#44;throw&#125;`;
                        } else {
                            query.title = '';
                            query.selection = 'attack';
                        }
                        query.last = query.next; 
                    } else {
                        clog(cache, 'Not Applicable', 'ERROR');
                        query.commit = true;
                    }
                break;
                case 'modifier':
                    query.title = getTranslationByKey("modifier");
                    query.options = '|Normal,0|Minor Edge,1|Minor Obstacle,-1|Major Edge,2|Major Obstacle,-2';
                    query.last = query.next;
                break;
                case 'name':
                    query.title = getTranslationByKey("name");
                    query.options = `|${cache.rolldb[query.index].name || ''}`;
                    query.last = query.next;
                break;
                case 'stat':
                    if (button_supported[cache.rolldb[query.index].type][cache.source_attribute || 'default']) {
                        query.title = `${getTranslationByKey("select-stats")}`;
                        query.options = 
                            `|${getTranslationByKey("body")},body` +
                            `|${getTranslationByKey("mind")},mind` +
                            `|${getTranslationByKey("soul")},soul` +
                            `|Avg ${getTranslationByKey("body")}+${getTranslationByKey("mind")},body~mind` +
                            `|Avg ${getTranslationByKey("body")}+${getTranslationByKey("soul")},body~soul` +
                            `|Avg ${getTranslationByKey("mind")}+${getTranslationByKey("soul")},mind~soul` +
                            `|Avg ${getTranslationByKey("body")}+${getTranslationByKey("mind")}+${getTranslationByKey("soul")},body~mind~soul` +
                            `|${getTranslationByKey("variable")},variable`;
                        query.last = query.next;
                    } else {
                        clog(cache, 'Not Applicable', 'ERROR');
                        query.commit = true;
                    }
                break;
                case 'target':
                    if (button_supported[cache.rolldb[query.index].type][cache.source_attribute || 'default']) {
                        query.title = getTranslationByKey("target");
                        query.options =
                            `|${getTranslationByKey("opposed-roll")},target_select` +
                            `|${getTranslationByKey("target-number")},target_number`;
                        query.last = query.next;
                    } else {
                        clog(cache, 'Not Applicable', 'ERROR');
                        query.commit = true;
                    }
                break;
                case 'type':
                    query.title = getTranslationByKey("type");
                    query.options = '|2d6,2d6' +
                        `|${getTranslationByKey("attack")},attack` +
                        `|${getTranslationByKey("attribute")},attribute` +
                        `|${getTranslationByKey("initiative")},initiative` +
                        `|${getTranslationByKey("skill")},skill` +
                        `|${getTranslationByKey("stat")},stat`;
                    query.last = query.next;
                break;
            }
            if (!query.commit) {
                if (query.title !== '') { await crpQuery(cache, query, query.last); }
                switch (query.last) {
                    case 'add':
                        query.row_id = generateRowID();
                        query.type = query.selection;
                        query.rolldb = Object.assign({}, roll_macro_template);
                        query.rolldb.id = query.row_id;
                        set_values[`repeating_roll_${query.row_id}_attrlabel`] = getTranslationByKey("attribute");
                        set_values[`repeating_roll_${query.row_id}_maneuverlabel`] = getTranslationByKey("maneuver");
                        for (let i = 0; i < query.fields.length; i++) {
                            let value = '';
                            switch(query.fields[i]) {
                                case 'icon':
                                    value = 'casino';
                                break;
                                case 'modifier':
                                    value = getTranslationByKey("normal");
                                    query.rolldb.modifier = 'normal';
                                break;
                                case 'name':
                                    value = getTranslationByKey("roll-macro");
                                    query.rolldb.name = value;
                                break;
                                case 'type':
                                    value = '2d6';
                                    query.rolldb.type = '2d6';
                                break;
                                default: value = getTranslationByKey("not-applicable");
                            }
                            set_values[`repeating_roll_${query.row_id}_${query.fields[i]}`] = value;
                        }
                        if (cache.rolldb === undefined) {
                            cache.rolldb = [];
                        }
                        cache.rolldb.push(query.rolldb);
                        query.commit = true;
                    break;
                    case 'attribute':
                        const [attr_name, attr_index, attr, skill_index] = query.selection.split("~");
                        set_values[`${cache.source_path}_attribute`] = attr_name === '' ?
                            getTranslationByKey(attr.toKebobCase()) : attr_name.capitalize();
                        cache.rolldb[query.index].attribute.id = attr === 'unarmed' || attr === 'touch' ?
                            attr : cache.attrdb[attr][attr_index].row_id;
                        cache.rolldb[query.index].attribute.name = attr;
                        if (skill_index !== undefined) {
                            cache.rolldb[query.index].attribute.skill_id = 
                                cache.attrdb.skills[attr_index].individual[skill_index].row_id;
                        }
                        query.commit = true;
                    break;
                    case 'delete':
                        if (query.selection !== 'exit') {
                            const index = cache.rolldb.findIndex(r => r.id === query.selection);
                            if (index !== -1) {
                                cache.rolldb.splice(index, 1);
                                removeRepeatingRow(`repeating_roll_${query.selection}`);
                            }
                        }
                        query.commit = true;
                    break;
                    case 'enemy':
                        set_values[`${cache.source_path}_enemy`] = query.selection === 'not-configured' ?
                            `${getTranslationByKey(query.selection)}` : query.selection.capitalize();
                        cache.rolldb[query.index].enemy = query.selection === 'not-configured' ?
                            '' : query.selection;
                        query.commit = true;
                    break;
                    case 'maneuver':
                        set_values[`${cache.source_path}_maneuver`] = getTranslationByKey(query.selection.toKebobCase());
                        cache.rolldb[query.index].maneuver = query.selection;
                        query.commit = true;
                    break;
                    case 'modifier':
                        query.modifier =
                            query.selection === 1 ? getTranslationByKey("minor-edge") :
                            query.selection === 2 ? getTranslationByKey("major-edge") :
                            query.selection === -1 ? getTranslationByKey("minor-obstacle") :
                            query.selection === -2 ? getTranslationByKey("major-obstacle") :
                            getTranslationByKey("normal");
                        set_values[`${cache.source_path}_modifier`] = query.modifier;
                        cache.rolldb[query.index].modifier = query.selection;
                        query.commit = true;
                    break;
                    case 'name':
                        if (query.selection !== '') {
                            cache.rolldb[query.index].name = query.selection;
                            set_values[`${cache.source_path}_name`] = query.selection;
                            query.commit = true;
                        } else {
                            query.next = 'name';
                        }
                    break;
                    case 'stat':
                        query.stat = query.selection.split("~");
                        cache.rolldb[query.index].stat = query.stat;
                        set_values[`${cache.source_path}_stat`] = query.stat.length === 1 ? 
                            getTranslationByKey(query.stat[0]) :
                            `Avg ${query.stat.map(s => getTranslationByKey(s)).join(" + ")}`;
                        query.commit = true;
                    break;
                    case 'target':
                        query.target = query.selection === 'target_select' ?
                            getTranslationByKey("opposed-roll") :
                            getTranslationByKey("target-number");
                        set_values[`${cache.source_path}_target`] = query.target;
                        cache.rolldb[query.index].target = query.selection;
                        query.commit = true;
                    break;
                    case 'type':
                        const macro_fields = ['attribute','enemy','maneuver','modifier','stat','target'];
                        set_values[`${cache.source_path}_icon`] =
                            query.selection === 'attack' ? 'swords' :
                            query.selection === 'attribute' ? 'cognition' :
                            query.selection === 'initiative' ? 'acute' :
                            query.selection === 'skill' ? 'multimodal_hand_eye' :
                            query.selection === 'stat' ? 'person' : 'casino';
                        cache.rolldb[query.index].type = query.selection;
                        set_values[`${cache.source_path}_type`] =
                            query.selection === '2d6' ? '2d6' : getTranslationByKey(query.selection);
                        set_values[`${cache.source_path}_button`] = query.selection === '2d6' ? 0 : 1;
                        switch (query.selection) {
                            case '2d6':
                            case 'initiative':
                                for (let i = 0; i < macro_fields.length; i++) {
                                    let value = '';
                                    switch (macro_fields[i]) {
                                        case 'modifier': value = getTranslationByKey("not-configured"); break;
                                        default: value = getTranslationByKey("not-applicable");
                                    }
                                    set_values[`${cache.source_path}_${macro_fields[i]}`] = value;
                                }
                                set_values[`${cache.source_path}_attrlabel`] = getTranslationByKey("attribute");
                                set_values[`${cache.source_path}_maneuverlabel`] = getTranslationByKey("maneuver");
                            break;
                            case 'attack':
                                for (let i = 0; i < macro_fields.length; i++) {
                                    let value = '';
                                    switch(macro_fields[i]) {
                                        case 'attribute':
                                        case 'enemy':
                                        case 'maneuver':
                                        case 'modifier':
                                        case 'target': value = getTranslationByKey("not-configured"); break;
                                        default: value = getTranslationByKey("not-applicable");
                                    }
                                    set_values[`${cache.source_path}_${macro_fields[i]}`] = value;
                                }
                                set_values[`${cache.source_path}_attrlabel`] = getTranslationByKey("weapon");
                                set_values[`${cache.source_path}_maneuverlabel`] = getTranslationByKey("maneuver");
                            break;
                            case 'attribute':
                            for (let i = 0; i < macro_fields.length; i++) {
                                let value = '';
                                switch(macro_fields[i]) {
                                    case 'attribute':
                                    case 'modifier':
                                    case 'stat':
                                    case 'target': value = getTranslationByKey("not-configured"); break;
                                    default: value = getTranslationByKey("not-applicable");
                                }
                                    set_values[`${cache.source_path}_${macro_fields[i]}`] = value;
                                }
                                set_values[`${cache.source_path}_attrlabel`] = getTranslationByKey(`${'attribute'}`);
                                set_values[`${cache.source_path}_maneuverlabel`] = getTranslationByKey(`${'maneuver'}`);
                            break;
                            case 'skill':
                                for (let i = 0; i < macro_fields.length; i++) {
                                    let value = '';
                                    switch(macro_fields[i]) {
                                        case 'attribute':
                                        case 'modifier':
                                        case 'stat':
                                        case 'target': value = getTranslationByKey("not-configured"); break;
                                        case 'maneuver':
                                            value = getTranslationByKey(`${
                                                cache.rulesdb.rules_optional_individual_status ?
                                                    "not-configured" : "not-applicable"
                                            }`);
                                        break;
                                        default: value = getTranslationByKey("not-applicable");
                                    }
                                    set_values[`${cache.source_path}_${macro_fields[i]}`] = value;
                                }
                                set_values[`${cache.source_path}_attrlabel`] = getTranslationByKey(`${'skill'}`);
                                set_values[`${cache.source_path}_maneuverlabel`] = getTranslationByKey(`${'specialized'}`);
                            break;
                            case 'stat':
                                for (let i = 0; i < macro_fields.length; i++) {
                                    let value = '';
                                    switch(macro_fields[i]) {
                                        case 'modifier':
                                        case 'stat':
                                        case 'target': value = getTranslationByKey("not-configured"); break;
                                        default: value = getTranslationByKey("not-applicable");
                                    }
                                    set_values[`${cache.source_path}_${macro_fields[i]}`] = value;
                                }
                                set_values[`${cache.source_path}_attrlabel`] = getTranslationByKey("attribute");
                                set_values[`${cache.source_path}_maneuverlabel`] = getTranslationByKey("maneuver");
                            break;
                        }
                        query.commit = true;
                    break;
                }
            }
        }
    }

    async function attributesMenu(cache, set_values) {
        const query = {} ;
        const gear_amount = {
            1:'1-2',
            2:'3-5',
            3:'6-10',
            4:'11-25',
            5:'26-50',
            6:'51-100'
        };
        query.type = cache.source_id === 'group' ? 'group' : cache.source_section;
        clog(cache, query, 'attributesMenu()');
        switch (cache.source_type) {
            case 'repeating':
                switch (cache.source_attribute) {
                    case 'attribute':
                    case 'configuration':
                    case 'defect':
                    case 'enhancements':
                    case 'level':
                    case 'limiters':
                    case 'rank':
                    case 'stat':
                        query.next = `repeating_${cache.source_section}_${cache.source_attribute}`;
                        const all_list = cache.source_section === 'attribute' ? all_attributes : all_defects;
                        for (let a = 0; a < all_list.length; a++) {
                            if (cache.source_section === 'attribute') {
                                query.db = cache.attrdb[all_list[a]].find((b, i) => {
                                    if (b.row_id.toLowerCase() === cache.source_id) {
                                        query[cache.source_section] = all_list[a];
                                        query.index = i;
                                        return true;
                                    }
                                });
                            } else {
                                const test_section = all_list[a];
                                const testdb = cache.defectdb[test_section];
                                query.db = testdb.find((b, i) => {
                                    if (b.row_id.toLowerCase() === cache.source_id) {
                                        query[cache.source_section] = all_list[a];
                                        query.index = i;
                                        return true;
                                    }
                                });
                            }
                            if (!_.isEmpty(query.db)) { break; }
                        }
                        query.elevel = query.db.elevel;
                    break;
                }
            break;
            case 'static':
                switch (cache.source_id) {
                    case 'add':
                    case 'delete':
                    case 'edit':
                        query.next = cache.source;
                    break;
                    case 'group':
                        query.db = cache.groupdb;
                        query.next = cache.source;
                    break;
                }
            break;
            default:
                query.next = 'select_type';
        }
        cache.attribute_ids = await getSectionIDsAsync('attributes');
        query.commit = false;
        while (!query.commit) {
            switch (query.next) {
                // Attributes Menu Options
                case 'static_attributes_add_button':
                case 'static_attributes_delete_button':
                    query.title = `${getTranslationByKey(
                        !cache.groupdb[cache.static_group_visible_id].locked ?
                        "attribute-defect-group" : "defect-group"
                    )}`;
                    query.options = !cache.groupdb[cache.static_group_visible_id].locked ?
                        `|${getTranslationByKey("attribute")},attribute` : '';
                    query.options += 
                        `|${getTranslationByKey("defect")},defect` +
                        `|${getTranslationByKey("group")},group`;
                    query.last = query.next;
                break;
                case 'add_attribute':
                    query.name = '';
                    query.config = [];
                    query.enhancements = [];
                    query.limiters = [];
                    query.level = 0;
                    query.elevel = 0;
                    query.title = getTranslationByKey("select-attribute");
                    const normalized_attributes = Object.keys(normalize_attributes);
                    query.attributes = base_attributes.concat(
                        Object.values(normalize_attributes).map((v, i) => {
                            return cache.rulesdb[`rules_${normalized_attributes[i]}_status`] ? v : '';
                        }).filter(n => n)
                    );
                    const skill_index = query.attributes.findIndex(a => { return a === `${
                        cache.rulesdb.rules_optional_individual_status ? 'skill group' : 'skills'
                    }`});
                    query.attributes.splice(skill_index, 1);
                    query.attributes.sort();
                    query.attribute_translations = query.attributes.toKebobCase();
                    query.options = '';
                    for (let i = 0; i < query.attribute_translations.length; i++) {
                        query.options += `|${getTranslationByKey(query.attribute_translations[i])},${query.attributes[i]}`;
                    }
                    query.last = query.next;
                break;
                case 'add_group':
                    query.title = '';
                    query.last = query.next;
                break;
                case 'static_attribute_group_type':
                    query.title = 
                        `${getTranslationByKey('group')} ` +
                        `${getTranslationByKey('type')}`;
                    query.options = 
                        `|${getTranslationByKey("standard")},standard` +
                        `|${getTranslationByKey("dynamic-powers")},dynamic powers` +
                        `|${getTranslationByKey("gear")},gear` +
                        `|${getTranslationByKey("power-flux")},power flux` +
                        `|${getTranslationByKey("power-variation")},power variation`;
                    query.last = query.next;
                break;
                case 'remove_attribute':
                    const removable_attributes = [];
                    query.title = 'Remove';
                    query.options = '';
                    for (let i = 0; i < all_attributes.length; i++) {
                        for (let j = 0; j < cache.attrdb[all_attributes[i]].length; j++) {
                            const attribute = cache.attrdb[all_attributes[i]];
                            if (attribute[j].group_id === cache.static_group_visible_id) {
                                removable_attributes.push(
                                    `${attribute[j].name === '' ? all_attributes[i].capitalize() : attribute[j].name}` +
                                    `${attribute[j].name === '' ? '' : ' [' + all_attributes[i].capitalize() + ']'},` +
                                    `${all_attributes[i]}~${cache.attrdb[all_attributes[i]][j].row_id}`
                                );
                            }
                        }
                    }
                    query.options = '|' + removable_attributes.sort().join("|");
                    query.options += `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'remove_defect':
                    const removable_defects = [];
                    query.title = 'Remove';
                    query.options = '';
                    for (let i = 0; i < all_defects.length; i++) {
                        for (let j = 0; j < cache.defectdb[all_defects[i]].length; j++) {
                            const defect = cache.defectdb[all_defects[i]];
                            if (defect[j].group_id === cache.static_group_visible_id) {
                                removable_defects.push(
                                    `${defect[j].name === '' ? all_defects[i].capitalize() : defect[j].name}` +
                                    `${defect[j].name === '' ? '' : ' [' + all_defects[i].capitalize() + ']'},` +
                                    `${all_defects[i]}~${cache.defectdb[all_defects[i]][j].row_id}`
                                );
                            }
                        }
                    }
                    query.options = '|' + removable_defects.sort().join("|");
                    query.options += `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'remove_group':
                    query.title = '';
                    query.selection = 
                        `${cache.groupdb[cache.static_group_visible_id].name}` +
                        `~${cache.static_group_visible_id}`;
                    query.last = query.next;
                break;
                case 'remove_confirm':
                    if (cache.rulesdb.rules_homebrew_donotconfirm_status) {
                        query.title = '';
                        query.selection = 'yes';
                    } else {
                        query.title = `Confirm Remove ${
                            Array.isArray(query.remove) ?
                            query.remove[0].capitalize() :
                            query.remove.capitalize()
                        }`;
                        query.options = `|No,${query.last}|Yes,yes`;
                    }
                    query.last = query.next;
                break;
                case 'reset_confirm':
                case 'reset_group':
                    query.title = query.next === 'reset_group' ?
                        `${getTranslationByKey("confirm-reset-of-all-attributes")}` :
                        `${getTranslationByKey("confirm-reset-of-attribute")}`;
                    query.options = `|No,${query.last}|Yes,yes`;
                    query.last = query.next;
                break;
                case 'reset_attribute':
                    query.title = getTranslationByKey("reset");
                    query.options = '';
                    for (let i = 0; i < all_attributes.length; i++) {
                        for (let j = 0; j < cache.attrdb[all_attributes[i]].length; j++) {
                            if (cache.attrdb[all_attributes[i]][j].group_id === cache.static_group_visible_id) {
                                query.options += `|${cache.attrdb[all_attributes[i]][j].name} [${all_attributes[i].capitalize()}],` +
                                `${all_attributes[i]}~${j}`;
                            }
                        }
                    }
                    query.options += `|${getTranslationByKey("go-back")},select_task`;
                    query.last = query.next;
                break;
                case 'attribute_type':
                    query.title = `${getTranslationByKey("select-defense-type")}`;
                    query.options =
                        `|${getTranslationByKey("personal")},personal` +
                        `|${getTranslationByKey("movement")},movement` +
                        `|${getTranslationByKey("go-back")},${query.last}`;
                    query.last = query.next;
                break;
                case 'attack_type':
                    query.title = `${getTranslationByKey("choose-attack-type")}`;
                    query.options = 
                        `|${getTranslationByKey("any")},any` +
                        `|${getTranslationByKey("enemy")},enemy` +
                        `|${getTranslationByKey("melee")},melee attacks` +
                        `|${getTranslationByKey("ranged")},ranged attacks`;
                    query.last = query.next;
                break;
                
                case 'set_skill':
                    //skill group
                    const skill_categories = ["background","field","action"];
                    const skill_groups = {
                        "background":[
                            "academic",
                            "artistic",
                            "domestic",
                            "occupation",
                        ],
                        "field":[
                            "business",
                            "social",
                            "street",
                            "technical",
                        ],
                        "action":[
                            "adventuring",
                            "detective",
                            "military",
                            "scientific",
                        ]
                    };
                    query.title = `${getTranslationByKey("skill-group")}`;
                    query.options = '';
                    for (let i = 0; i < skill_categories.length; i++) {
                        for (let j = 0; j < skill_groups[skill_categories[i]].length; j++) {
                            query.options += 
                            `|${getTranslationByKey(skill_groups[skill_categories[i]][j])} ` +
                            `(${getTranslationByKey(skill_categories[i])}),` +
                            `${skill_groups[skill_categories[i]][j]}~${skill_categories[i]}`;
                        }
                    }
                    query.options += `|${getTranslationByKey("go-back")},add_attribute`;
                    query.last = query.next;
                break;
                case 'rename_attribute':
                case 'rename_group':
                    query.title = `Provide a name for the ${query.type}`;
                    query.options = '';
                    query.last = query.next;
                break;
                case 'set_name':
                case 'static_attribute_group_name':
                case 'repeating_attribute_attribute':
                case 'repeating_defect_defect':
                    const type = cache.source_type === 'repeating' ? cache.source_section : 'group';
                    query.title = `${getTranslationByKey("rename-" + type)}`;
                    query.options = type === 'group' ? `|${cache.groupdb[cache.static_group_visible_id].name}` :
                        `|${query.db.name === '' ? query[cache.source_section].capitalize() : query.db.name}`;
                    query.last = query.next;
                break;
                case 'set_group_source':
                case 'static_attribute_group_source':
                    query.title = 'Choose Source';
                    query.options = '';
                    for (let i = 0, n = sources_4e.length; i < n; i++) {
                        query.options += `|${getTranslationByKey(sources_4e[i])},` +
                            `${sources_4e[i]}`;
                    }
                    query.last = query.next;
                break;
                case 'set_group_item':
                case 'static_attribute_group_item':
                    if (cache.groupdb[cache.static_group_visible_id].group_type === 'gear') {
                        clog(cache, 'Cannot change item type when Attribute is Gear.', 'ERROR');
                        query.next = 'exit';
                        query.title = '';
                        query.commit = true;
                    } else {
                        query.title = 'Is this group an item or shield?';
                        query.options = 
                            `|${getTranslationByKey("no")},no` +
                            `|${getTranslationByKey("item")},yes` +
                            `|${getTranslationByKey("shield")},shield`;
                        query.last = query.next;
                    }
                break;
                case 'lock_group':
                    query.title = 'Lock Group';
                    query.options = 
                        `|${getTranslationByKey("no")},no` +
                        `|${getTranslationByKey("yes")},yes` +
                        `|${getTranslationByKey("go-back")},group_menu`;
                    query.last = query.next;
                break;
                case 'select_level':
                case 'static_attribute_group_level':
                case 'repeating_attribute_level':
                case 'repeating_defect_rank':
                    if (query.attribute === 'unknown power') {
                        query.title = '';
                        query.options = '';
                    } else {
                        query.title = cache.source_section === 'defect' ?
                            `${getTranslationByKey("rank")}` :
                            `${getTranslationByKey("level")}`;
                        query.options = `|${query.db.level || 0}`;
                    }
                    query.last = query.next;
                break;
                case 'static_attribute_group_enhancements':
                case 'static_attribute_group_limiters':
                case 'repeating_attribute_enhancements':
                case 'repeating_attribute_limiters':
                case 'enhancements_add':
                    query.title = `${getTranslationByKey(cache.source_attribute)}`;
                    const normalized_enhancements = {
                        'absorption':['synergistic'],
                        'cognition':['area'],
                        'conversion':['escalate'],
                        'force field':['air-tight'],
                        'power flux':['debuff'],
                        'sixth sense':['range'],
                        'size change':['modified shrinking'],
                        'summon creatures':['area'],
                        'teleport':['blind'],
                        'transfer':['area','targets'],
                        'weapon':['anemic','demoralize','lethargy']
                    };
                    const normalized_limiters = {
                        'absorption':['capped'],
                        'force field':['impacting'],
                        'merge':['proportional damage'],
                        'plant control':['group','species'],
                        'power flux':['skill flux'],
                        'transmute':['material category']
                    };
                    let customizations = cache.source_attribute === 'enhancements' ? ['potent'].concat(
                        standard_enhancements[query.attribute] || 
                        standard_enhancements['default']
                    ) : [];
                    customizations = cache.source_attribute === 'enhancements' ?
                        customizations.concat(//=> enhancements
                            base_custom_enhancements[query.attribute] || 
                            base_custom_enhancements['default']
                        ) : 
                        customizations.concat(//=> limiters
                            base_limiters,
                            base_custom_limiters[query.attribute] || 
                            base_custom_limiters['default']
                        );
                    if (cache.source_attribute === 'enhancements') {
                        if (
                            Object.keys(normalized_enhancements).indexOf(query.attribute) !== -1 &&
                            cache.rulesdb[`rules_enhancement_${query.attribute.removeWhiteSpace()}_status`]
                        ) {
                            normalized_enhancements[`${query.attribute}`].forEach(e => customizations.push(e));
                        }
                    } else {
                        if (
                            Object.keys(normalized_limiters).indexOf(query.attribute) !== -1 &&
                            cache.rulesdb[`rules_limiter_${query.attribute.removeWhiteSpace()}_status`]
                        ) {
                            normalized_limiters[`${query.attribute}`].forEach(e => customizations.push(e));
                        }
                    }
                    customizations = customizations.sort();
                    let customizations_translations = customizations.toKebobCase();
                    query.options = '';
                    for (let i = 0; i < customizations.length; i++) {
                        if (query.customizations === undefined) {
                            query.customizations = query.type === 'group' ?
                                cache.groupdb[cache.static_group_visible_id][cache.source_attribute] :
                                cache.attrdb[query.attribute][query.index][cache.source_attribute];
                        }
                        const index = query.customizations.findIndex(e => e.name === customizations[i]);
                        const rank = index !== -1 ? query.customizations[index].rank : 0;
                        query.options += `|${getTranslationByKey(customizations_translations[i])}`;
                        query.options += rank ? ` (${rank}),` : ',';
                        query.options += `${customizations[i]}~${rank}~${index}`;
                    }
                    query.options += `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'limiters_add':
                    query.title = `${getTranslationByKey("add")} ${getTranslationByKey("limiter")}`;
                    let limiters = [];
                    limiters = limiters.concat(
                        base_limiters,
                        base_custom_limiters[query.attribute] || 
                        base_custom_limiters['default']
                    );
                    if (
                        Object.keys(normalized_limiters).indexOf(query.attribute) !== -1 &&
                        cache.rulesdb[`rules_limiter_${query.attribute.removeWhiteSpace()}_status`]
                    ) {
                        limiters.push(normalized_limiters[`${query.attribute}`]);
                    }
                    query.current_limiters = query.limiters.map(l => {
                        return l.name;
                    });
                    if (query.current_limiters.length !== 0) {
                        const test = nested_limiters[query.attribute] || [];
                        const exists = query.current_limiters.map(e => {
                            return test.indexOf(e) !== -1;
                        }).filter(Boolean);
                        if (test.length !== 0 && exists[0]) {
                            for (let i = 0, n = test.length; i < n; i++) {
                                query.current_limiters.push(test[i]);   
                            }
                            query.current_limiters = [...new Set(query.current_limiters.sort())];
                        }
                        for (let i = 0, n = query.current_limiters.length; i < n; i++) {
                            limiters.splice(limiters.indexOf(query.current_limiters[i]), 1);
                        }
                    }
                    limiters = limiters.sort();
                    let limiter_translations = limiters.toKebobCase();
                    query.options = '';
                    for (let i = 0, n = limiters.length; i < n; i++) {
                        query.options += `|${getTranslationByKey(limiter_translations[i])},` +
                        `${limiters[i]}`;
                    }
                    query.options += `|${getTranslationByKey("go-back")},${query.type}_menu`;
                    query.last = 'limiter_add';
                break;
                case 'enhancements_remove':
                case 'limiters_remove':
                    query.title = `${getTranslationByKey("remove")} ` +
                        `${getTranslationByKey(query.customization_type)}`;
                    let current_customizations = query[`${query.customization_type}s`].map(e => {
                        return e.name;
                    }).sort();
                    query.options = '';
                    for (let i = 0, n = current_customizations.length; i < n; i++) {
                        query.options +=
                        `|${getTranslationByKey(current_customizations[i].toKebobCase())},` +
                        `${current_customizations[i]}`;
                    }
                    query.options += `|${getTranslationByKey("go-back")},attribute_menu`;
                    query.last = `${query.customization_type}_remove`;
                    query.next = 'write_customizations';
                break;
                case 'customization_rank':
                case 'movement_rank':
                case 'sense_rank':
                case 'technique_rank':
                    query.title = `${getTranslationByKey("set-value")}`;
                    query.options = 
                        query.next === 'movement_rank' ? 
                        `|${query.has_movement !== -1 ? query.movements[query.movements.findIndex(m => m.name === query.movement)].rank : 0}` :
                        query.next === 'technique_rank' ? 
                        `|${query.has_technique !== -1 ? query.techniques[query.techniques.findIndex(t => t.name === query.technique)].rank : 0}` :
                        query.next === 'sense_rank' ?
                        `|${query.env_index !== -1 ? query.db.config[query.c_index].rank[query.env_index].rank : 0}` :
                        `|${query.customization[1]}`;
                    query.last = query.next;
                break;
                case 'enhancement_rank':
                    query.title = `${getTranslationByKey("enhancement")} ${getTranslationByKey("rank")}`;
                    query.options = '';
                    query.last = 'enhancement_rank';
                break;
                case 'limiter_rank':
                    query.title = `${getTranslationByKey("limiter")} ${getTranslationByKey("rank")}`;
                    query.options = '';
                    query.last = 'limiter_rank';
                break;
                case 'config_attribute':
                    query.title = `${getTranslationByKey(query.attribute_translation)}`;
                    switch (query.attribute) {
                        case 'absorption':
                            query.title = `${getTranslationByKey("choose-how-damage-is-transformed")}`;
                            query.options = 
                                `|${getTranslationByKey("health-points")},health points` +
                                `|${getTranslationByKey("energy-points")},energy points` +
                                `|${getTranslationByKey("go-back")},attribute_menu`;
                            query.last = query.next;
                        break;
                        case 'combat technique':
                            const base_combat_techniques = ['blind fighting','blind shooting','brutal','concealment','deflection','extended range','judge opponent','lethal blow','lightning reflexes','portable armory','refelction','weapon encyclopedia'];
                            const normalize_techniques = {
                                'attribute_deathdodge':'death dodge',
                                'attribute_debilitate':'debilitate',
                                'attribute_eknockback':'enhanced knockback',
                                'attribute_flankdefense':'flank defense',
                                'attribute_hardboiled':'hardboiled',
                                'attribute_tournament':'tournament encyclopedia',
                            };
                            const normalized_techniques = Object.keys(normalize_techniques);
                            await crpGet(cache, normalized_techniques);
                            let techniques = [];
                            techniques = base_combat_techniques.concat(
                                Object.values(normalize_techniques).map((v, i) => {
                                    return cache[`rules_${normalized_techniques[i]}_status`] ? v : '';
                                })
                            );
                            if (cache.rulebook !== 'besm') {
                                techniques.push('precise aim','rush attack');
                            }
                            if (cache.rulebook.indexOf('besm') === -1) {
                                techniques.push('death dodge','flanking defense');
                            }
                            query.techniques = techniques.filter(n => n).sort();
                            query.technique_translations = query.techniques.toKebobCase();
                            query.options = '';
                            for (let i = 0, n = query.techniques.length; i < n; i++) {
                                query.bracket = false;
                                for (let j = 0, m = query.config.length; j < m; j++) {
                                    if (query.techniques[i] === query.config[j].name) {
                                        query.bracket = true;
                                        break;
                                    }
                                }
                                query.options += 
                                    `|${query.bracket ? '[' : ''}` +
                                    `${getTranslationByKey(query.technique_translations[i])}` +
                                    `${query.bracket ? ']' : ''},${query.techniques[i]}`;
                            }
                            query.options += `|${getTranslationByKey("go-back")},attribute_menu`;
                            query.last = query.next;
                        break;
                        case 'special movement':
                            await crpGet(cache, 'rules_attribute_speedburst_status');
                            const special_movements = [
                                'balance',
                                'cat-like',
                                'fast',
                                'light-footed',
                                'slithering',
                                'swinging',
                                'untrackable',
                                'wall-bouncing',
                                'wall-crawling',
                                'water-walking',
                                'zen direction'
                            ].concat(
                                cache.rules_attribute_speedburst_status ?
                                    'speedburst' : ''
                            );
                            query.movements = special_movements.filter(n => n).sort();
                            query.movement_translations = query.movements.toKebobCase();
                            query.options = '';
                            for (let i = 0, n = query.movements.length; i < n; i++) {
                                const bracket = query.config.indexOf(query.movements[i]) !== -1;
                                query.options += 
                                    `|${bracket ? '[' : ''}` +
                                    `${getTranslationByKey(query.movement_translations[i])}` +
                                    `${bracket ? ']' : ''},${query.movements[i]}`;
                            }
                            query.options += `|${getTranslationByKey("go-back")},attribute_menu`;
                            query.last = query.next;
                        break;
                    }
                break;
                case 'config_flare':
                    if (query.config_index === undefined) {
                        query.config_index = query.config.push({
                            name: 'flare',
                            rank: 0,
                            senses: [
                                {name:'hearing',rank:0},
                                {name:'sight',rank:0},
                                {name:'smell',rank:0},
                                {name:'taste',rank:0},
                                {name:'touch',rank:0}
                            ]
                        }) - 1;
                    }
                    query.title = `Flare Configuration`;
                    query.options = '';
                    for (let i = 0, n = senses.length; i < n; i++) {
                        query.options += 
                            `|${senses[i].capitalize()} ` +
                            `[${query.config[query.config_index].senses[i].rank || 0}]` +
                            `,${senses[i]}`;
                    }
                    query.options += `|Done,attribute_menu`;
                    query.last = query.next;
                break;
                case 'config_rank':
                    query.title = `${query.customization.capitalize()} ${getTranslationByKey("rank")}`;
                    query.options = '';
                    query.last = query.next;
                break;
                case 'config_customization':
                case 'repeating_attribute_configuration':
                case 'repeating_defect_configuration':
                    const all_configurations = [
                        'achilles heel',
                        'aspect_stat',
                        'attack_type',
                        'attribute_type',
                        'augmented_stat',
                        'broad category',
                        'capacity_type',
                        'capped',
                        'complete_resilience',
                        'convert',
                        'damage_type',
                        'defense type',
                        'enemy',
                        'environments',
                        'features',
                        'focused damage',
                        'group',
                        'immunity',
                        'material category',
                        'movements',
                        'notes',
                        'origin template',
                        'resilient',
                        'senses',
                        'senses_or_techniques',
                        'sixth sense',
                        'size change',
                        'source',
                        'species',
                        'supersense',
                        'targeted damage',
                        'taunt',
                        'techniques',
                        'transform',
                        'trigger',
                        'unaffected',
                        'unknown power',
                        'weapon_class'
                    ];
                    query.configurations = [];
                    query.unaffected_index = query.attribute === 'unaffected' ? query.db.config.findIndex(c => c.name === 'unaffected') : -1;
                    query.all_attributes = query.unaffected_index !== -1 ? query.db.config[query.unaffected_index].rank.findIndex(u => u.name === 'all attributes') !== -1 : false;
                    query.all_weapons = query.unaffected_index !== -1 ? query.db.config[query.unaffected_index].rank.findIndex(u => u.name === 'all weapons') !== -1 : false;
                    for (let i = 0; i < query.db.config.length; i++) {
                        if (all_configurations.includes(query.db.config[i].name)) {
                            if (query.db.config[i].name === 'unaffected' && query.all_attributes && query.all_weapons) {
                                //=>do not add unaffected.
                            } else {
                                query.configurations.push(
                                    `${query.db.config[i].name.fromSnakeCase().capitalize()},${query.db.config[i].name}~${i}`
                                );
                            }
                        }
                    }
                    if (query.configurations.length === 0) {
                        clog(cache, `There is nothing to configure for ${query.db.name}.`, 'ERROR');
                        return;
                    } else if (query.configurations.length === 1) {
                        query.title = '';
                    } else {
                        query.title = getTranslationByKey("configuration");
                        query.options = '|' + query.configurations.sort().join('|') + 
                        `|${getTranslationByKey("exit")},exit`;
                    }
                    query.last = query.next;
                break;
                // => configurations
                case 'aspect_stat':
                    query.title = getTranslationByKey("choose-aspect");
                    query.options = '';
                    const aspects = [];
                    for (let i = 0; i < shortcomings.length; i++) {
                        const display = 
                            `${getTranslationByKey(shortcomings[i].stat)} - ` +
                            `${getTranslationByKey(shortcomings[i].type)} ${getTranslationByKey("aspect")}` +
                            `${
                                shortcomings[i].aspect === shortcomings[i].stat ? "" :
                                " (" + getTranslationByKey(shortcomings[i].aspect.toKebobCase()) + ")"
                            }`;
                        aspects.push(
                            `${display},${display}~${shortcomings[i].aspect}~${shortcomings[i].stat}~${shortcomings[i].type}`
                        );
                    }
                    query.options = '|' + aspects.sort().join('|') + 
                        `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'unaffected':
                    query.config_index = query.db.config.findIndex(c => c.name === 'unaffected');
                    query.attributes = query.db.config[query.config_index].rank.map(a => a.name);
                    query.weapon_index = query.db.config[query.config_index].rank.findIndex(a => a.name === 'weapon');
                    query.weapons = query.weapon_index !== -1 ? 
                        [...query.db.config[query.config_index].rank[query.weapon_index].rank] : [];
                    if (query.attributes.findIndex(a => a === 'all attributes') === -1) {
                        query.title = `${getTranslationByKey("choose-attribute")}`;
                        query.options = '|' + all_attributes.map(a => {
                            const bracket = query.attributes.indexOf(a);
                            const line = 
                                a === 'skill group' || 
                                a === 'skills' ||
                                a === 'unknown power' || 
                                (
                                    a === 'weapon' && query.attributes.findIndex(a => a === 'all weapons') !== -1
                                ) ? null :
                            `${bracket !== -1 ? '[' : ''}` +
                            `${a.capitalize()}` +
                            `${bracket !== -1 ? ']' : ''},${a}~${bracket}`;
                            return line;
                        }).filter(a => a).join('|');
                    } else if (
                        query.attributes.findIndex(a => a === 'all attributes') !== -1 &&
                        query.attributes.findIndex(a => a === 'all weapons') !== -1
                    ) {
                        query.next = 'exit';
                    }
                    query.last = query.next;
                break;
                case 'weapon_enhancement':
                    query.config_index = query.config_index === undefined ? query.db.config.findIndex(c => c.name === 'unaffected') : query.config_index;
                    query.attributes = query.attributes === undefined ? query.db.config[query.config_index].rank.map(a => a.name) : query.attributes;
                    query.weapon_index = query.weapon_index === undefined ? query.db.config[query.config_index].rank.findIndex(a => a.name === 'weapon') : query.weapon_index;
                    query.weapons = query.weapons === undefined ? query.weapon_index !== -1 ? 
                        [...query.db.config[query.config_index].rank[query.weapon_index].rank] : [] : query.weapons;
                    if (query.weapon_index === -1) { query.attributes.push('weapon'); }
                    query.title = `${getTranslationByKey("choose-weapon-enhancement")}`;
                    query.options = '|' + base_weapon_enhancements.map(e => {
                        const bracket = query.weapons.indexOf(e);
                        const line = 
                        `${bracket !== -1 ? '[' : ''}` +
                        `${e.capitalize()}` +
                        `${bracket !== -1 ? ']' : ''},${e}~${bracket}`;
                        return line;
                    }).join('|');
                    query.last = query.next;
                break;
                case 'augmented_stat':
                case 'choose_aspect_stat':
                    query.title = `${getTranslationByKey("choose-stat")}`;
                    query.options = 
                        `|${getTranslationByKey("body")},body` +
                        `|${getTranslationByKey("mind")},mind` +
                        `|${getTranslationByKey("soul")},soul` +
                        `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'capacity_type':
                    query.title = `${getTranslationByKey("choose-capacity-type")}`;
                    query.options = 
                        `|${getTranslationByKey("cargo")},cargo` +
                        `|${getTranslationByKey("carry")},carry` +
                        `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'damage_type':
                    query.title =
                        `${getTranslationByKey("choose")} ` +
                        `${getTranslationByKey("damage-type")}`;
                    query.options = '';
                    const temp_damage_types = [];
                    for (let i = 0; i < damage_types.length; i++) {
                        temp_damage_types.push(
                            `${getTranslationByKey(damage_types[i].toKebobCase())},${damage_types[i]}`
                        ); 
                    }
                    query.options += '|' + temp_damage_types.sort().join("|") + 
                        `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'defense type':
                    query.title = getTranslationByKey("choose-defense");
                    query.options = 
                        `|${getTranslationByKey("movement")},movement` +
                        `|${getTranslationByKey("ranged")},ranged`;
                    query.last = query.next;
                break;
                case 'achilles heel':
                case 'enemy':
                case 'group':
                case 'origin template':
                case 'species':
                case 'trigger':
                    query.title =
                        query.next === 'achilles heel' ? `${getTranslationByKey("choose-achilles-heel")}` :
                        query.next === 'enemy' ? `${getTranslationByKey("choose-enemy")}` :
                        query.next === 'group' ? `${getTranslationByKey("choose-group")}` :
                        query.next === 'origin template' ? `${getTranslationByKey("choose-origin-template")}` :
                        query.next === 'species' ? `${getTranslationByKey("choose-species")}` :
                        query.next === 'trigger' ? `${getTranslationByKey("choose-triggers")}` :
                        '';
                    query.options = `|${query.db.config[query.config_index].rank}`;
                    query.last = query.next;
                break;
                case 'add_sixth_sense':
                case 'environment':
                case 'feature':
                case 'resiliency':
                    query.title = getTranslationByKey(`${query.next === 'add_sixth_sense' ? 'choose-sixth-sense' : 'set-' + query.next}`);
                    query.options = '';
                    query.last = query.next;
                break;
                case 'complete_resilience':
                    query.r_index = query.db.config.findIndex(c => c.name === 'resilient');
                    if (query.db.config[query.r_index].rank.length === 0) {
                        clog(cache, 'Must be resilient to something before assigning complete resilence.', 'ERROR');
                        return;
                    }
                    query.temp_resilient = [...query.db.config[query.r_index].rank].sort();
                    query.title = getTranslationByKey("choose-complete-resilience");
                    for (let i = 0; i < query.temp_resilient.length; i++) {
                        const bracket = query.db.config[query.config_index].rank.findIndex(c => c === query.temp_resilient[i]);
                        query.temp_resilient[i] = 
                        `${bracket !== -1 ? '[' : ''}` +
                        `${query.temp_resilient[i].capitalize()}` +
                        `${bracket !== -1 ? ']' : ''}` +
                        `,${query.temp_resilient[i]}~${bracket}`;
                    }
                    query.options = '|' + query.temp_resilient.join("|");
                    query.options += `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'environments':
                case 'features':
                case 'immunity':
                case 'resilient':
                case 'sixth sense':
                    query.config_index = query.db.config.findIndex(c => c.name === query.next);
                    query.title = getTranslationByKey(`choose-${query.next.toKebobCase()}`);
                    if (query.next === 'immunity') {
                        query.options = query.db.config[query.config_index].rank !== '' ?
                            `|${query.db.config[query.config_index].rank}` : '';
                    } else {
                        query.complete = 
                            query.attribute === 'resilient' &&
                            query.db.enhancements.findIndex(e => e.name === 'complete');
                        query.options = `|${getTranslationByKey("add")},add`;
                        if (query.db.config[query.config_index].rank.length !== 0) {
                            query.options += '|' + 
                                query.db.config[query.config_index].rank.map((r, i) => r.capitalize() + ',' + i).sort().join("|");
                        }
                        query.options += `|${getTranslationByKey("exit")},exit`;
                    }
                    query.last = query.next;
                break;
                case 'movements':
                    const standard_movements = [
                        'balance',
                        'cat-like',
                        'fast',
                        'light-footed',
                        'slithering',
                        'swinging',
                        'untrackable',
                        'wall-bouncing',
                        'wall-crawling',
                        'water-walking',
                        'zen direction',
                    ];
                    const optional_movements = ['speedburst',];
                    query.movements = [];
                    query.title = getTranslationByKey("choose-special-movements");
                    for (let i = 0; i < optional_movements.length; i++) {
                        if (cache.rulesdb[`rules_attribute_${optional_movements[i].removeWhiteSpace()}_status`]) {
                            standard_movements.push(optional_movements[i]);
                        }
                    }
                    for (let i = 0; i < standard_movements.length; i++) {
                        const has_movement = query.db.config[query.load[1]].rank.findIndex(r => r.name === standard_movements[i]);
                        query.movements.push(
                            `${standard_movements[i].capitalize()}` +
                            `${has_movement !== -1 ? ' (' + query.db.config[query.load[1]].rank[has_movement].rank + ')' : ''}` +
                            `,${standard_movements[i]}`
                        );
                    }
                    query.options = '|' + query.movements.sort().join('|');
                    query.last = query.next;
                break;
                case 'notes':
                    query.title = getTranslationByKey("notes");
                    query.options = '|' + query.db.config[query.config_index].rank;
                    query.last = query.next;
                break;
                case 'other_sense':
                    query.title = getTranslationByKey("create-sense-or-technique");
                    query.options = '';
                    query.last = query.next;
                break;
                case 'other_supersense':
                    query.title = getTranslationByKey("choose-super-sense");
                    query.config_index = query.db.config.findIndex(c => c.name === 'supersense');
                    query.supersense = query.db.config[query.config_index].rank;
                    query.options = query.supersense === '' ? '' : `|${query.supersense}`;
                    query.last = query.next;
                break;
                case 'senses':
                    query.title = getTranslationByKey("choose-senses");
                    query.options = '|' + senses.map(s => `${s.capitalize()},${s}`).sort().join('|');
                    query.last = query.next;
                break;
                case 'senses_or_techniques':
                    query.blockable_senses = ['sixth sense', ...senses, ...supersenses];
                    for (let i = 0; i < query.db.config[query.config_index].rank.length; i++) {
                        if (query.blockable_senses.findIndex(s => s === query.db.config[query.config_index].rank[i]) === -1) {
                            query.blockable_senses.push(query.db.config[query.config_index].rank[i]);
                        }
                    }
                    query.options = '|' + query.blockable_senses.sort().map(s => query.db.config[query.config_index].rank.findIndex(a => a === s) !== -1 ? `[${s.capitalize()}],${s}` : `${s.capitalize()},${s}`).join('|');
                    query.title = getTranslationByKey("choose-senses");
                    query.options += `|${getTranslationByKey("other")},other`;
                    query.last = query.next;
                break;
                case 'size change':
                    query.title = getTranslationByKey("choose-size-change");
                    query.options = `|${getTranslationByKey("grow")},grow|${getTranslationByKey("shrink")},shrink`;
                    query.last = query.next;
                break;
                case 'source':
                    query.title = getTranslationByKey("choose-source");
                    query.options = '|' + sources_4e.map(s => `${s.capitalize()},${s}`).sort().join('|');
                    query.last = query.next;
                break;
                case 'supersense':
                case 'supersenses_or_techniques':
                    query.title = getTranslationByKey("choose-supersense");
                    query.options = '|' + supersenses.map(s => `${s.capitalize()},${s}`).sort().join('|');
                    query.options += '|Other,other';
                    query.last = query.next;
                break;
                case 'taunt':
                    query.config_index = query.db.config.findIndex(c => c.name === 'taunt');
                    query.title = getTranslationByKey("define-dice-roll");
                    query.options = `|${query.db.config[query.config_index].rank}`;
                    query.last = query.next;
                break;
                case 'techniques':
                    const standard_techniques = [
                        'blind fighting',
                        'blind shooting',
                        'brutal',
                        'concealment',
                        'deflection',
                        'extended range',
                        'judge opponent',
                        'lethal blow',
                        'lightning reflexes',
                        'portable armory',
                        'reflection',
                        'weapons encyclopedia',
                    ];
                    const optional_techniques = [
                        'blackout',
                        'critical strike',
                        'dead eye',
                        'debilitate',
                        'enhanced knockback',
                        'far shot',
                        'flanking defense',
                        'hardboiled',
                        'multiple targets',
                        'precise aim',
                        'rush attack',
                        'steady hand',
                        'tournament encyclopedia',
                        'two weapons',
                    ];
                    query.techniques = [];
                    query.title = getTranslationByKey("choose-combat-techniques");
                    for (let i = 0; i < optional_techniques.length; i++) {
                        if (cache.rulesdb[`rules_attribute_${optional_techniques[i].removeWhiteSpace()}_status`]) {
                            standard_techniques.push(optional_techniques[i]);
                        }
                    }
                    for (let i = 0; i < standard_techniques.length; i++) {
                        const has_technique = query.db.config[query.load[1]].rank.findIndex(r => r.name === standard_techniques[i]);
                        query.techniques.push(
                            `${standard_techniques[i].capitalize()}` +
                            `${has_technique !== -1 ? ' (' + query.db.config[query.load[1]].rank[has_technique].rank + ')' : ''}` +
                            `,${standard_techniques[i]}`
                        );
                    }
                    query.options = '|' + query.techniques.sort().join('|');
                    query.last = query.next;
                break;
                case 'transform':
                    query.title = `${getTranslationByKey("damage-is-transfored-into")}`;
                    query.options = 
                        `|${getTranslationByKey("energy-points")},energy points` +
                        `|${getTranslationByKey("health-points")},health points` +
                        `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'weapon_class':
                    const weapon_classes = 
                        query[`${query.type}`] === 'melee attack' ||
                        query[`${query.type}`] === 'melee defense' ? melee_types : 
                        query[`${query.type}`] === 'ranged attack' ? ranged_types :
                        melee_types.concat(ranged_types).sort();
                    query.title = `${getTranslationByKey("choose-weapon-class")}`;
                    query.options = query[`${query.type}`] === 'inept attack' ? 
                        `|${getTranslationByKey("any")},any` : '';
                    const classes = [];
                    for (let i = 0; i < weapon_classes.length; i++) {
                        classes.push(
                            `${getTranslationByKey(weapon_classes[i].toKebobCase())},${weapon_classes[i]}`
                        ); 
                            
                    }
                    query.options += '|' + classes.sort().join("|") + 
                        `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'unknown power':
                    query.title = getTranslationByKey("character-points");
                    //query.unknown_index = cache.attrdb['unknown power'].findIndex(u => u.row_id === cache.originalCaseRowID);
                    query.config_index = cache.attrdb['unknown power'][query.index].config.findIndex(c => c.name === 'unknown power');
                    query.options = `|${cache.attrdb['unknown power'][query.index].config[query.config_index].rank}`;
                    query.last = query.next;
                break;

                case 'add_defect':
                    query.config = [];
                    query.defects = cache.rulebook !== 'besm' ?
                        ['no healing'].concat(base_defects) : base_defects;
                    if (cache.rulesdb.rules_optional_sanity_status) {
                        query.defects = query.defects.concat(['unsettled']);
                    }
                    if (cache.rulesdb.rules_optional_society_status) {
                        query.defects = query.defects.concat(['demure']);
                    }
                    query.title = `${getTranslationByKey("add")} ${getTranslationByKey("defect")}`;
                    query.options = '|' + query.defects.map(d => `${d.capitalize()},${d}`).sort().join('|');
                    query.last = query.next;
                break;
                case 'defect_rank':
                    query.title = `${getTranslationByKey("defect")} ${getTranslationByKey("rank")}`;
                    query.options = '';
                    query.last = 'defect_rank';
                break;
                case 'stat_menu':
                case 'static_attribute_group_stat':
                case 'repeating_attribute_stat':
                    query.title = 
                        `${cache.source_id === 'group' ? getTranslationByKey("group") : getTranslationByKey("attribute")} ` +
                        `${getTranslationByKey("stat")}`;
                    query.options = 
                        `|${getTranslationByKey("body")},body` +
                        `|${getTranslationByKey("mind")},mind` +
                        `|${getTranslationByKey("soul")},soul` +
                        `|${getTranslationByKey("variable")},variable` +
                        `|${getTranslationByKey("none")},none`;
                    query.last = query.next;
                break;
                // Break out of while loop when there is no query.next step
                default:
                    query.commit = true;
            }
            if (!query.commit) {
                if (query.title !== '') { await crpQuery(cache, query, query.last); }
                switch (query.last) {
                    case 'select_type':
                    case 'static_attributes_add_button':
                    case 'static_attributes_delete_button':
                        query.type = query.selection;
                        query.next = query.last === 'static_attributes_add_button' ?
                            `add_${query.type}` :
                            `remove_${query.type}`;
                    break;
                    case 'select_task':
                        if (
                            query.selection === 'add' &&
                            query.type === 'attribute' &&
                            cache.groupdb[cache.static_group_visible_id].group_type === 'power variation' &&
                            cache.groupdb[cache.static_group_visible_id].locked === true
                        ) {
                            clog(cache, '', 'Cannot add Attributes or Defects to a Power Variation group when it is locked');
                            query.next = 'done';
                            break;
                        }
                        if (query.selection === 'select_type') {
                            query.next = 'select_type';
                        } else {
                            query.task = query.selection;
                            query.next = `${query.task}_${query.type}`;
                        }
                    break;
                    case 'attribute_menu':
                    case 'defect_menu':
                    case 'group_menu':
                        query.selection = query.selection.split("~");
                        if (query.selection.length === 2) {
                            query.index = int(query.selection[1]);
                        }
                        if (query.task === 'edit' && query.selection[0] === 'config_flare') {
                            query.config_index = query.config.findIndex(c => c.name === "flare");
                        }
                        query.selection = query.selection[0];
                        query.next = query.selection;
                    break;
                    case 'add_attribute':
                        query.attribute = query.selection;
                        query.attribute_translation = query.attribute.toKebobCase();
                        query.stat = all_attributes_stats[query.attribute] || 'none';
                        query.next = query.selection === 'skill group' ? 'set_skill' : 'write_newattr';
                    break;
                    case 'add_group':
                        query.next = 'write_newgroup';
                    break;
                    case 'attribute_type':
                        const index = query.config.findIndex(c => {
                            return c.name === 'defense type';
                        });
                        if (index !== -1) {
                            query.config[index].rank = query.selection;
                        } else {
                            query.config.push({
                                name: 'defense type',
                                rank: query.selection
                            });
                        }
                        query.attribute_type = query.selection;
                        query.next = 'attribute_menu';
                    break;
                    case 'attack_type':
                        query.attack_index = query.db.config.findIndex(c => c.name === 'attack_type');
                        query.db.config[query.attack_index].rank = query.selection;
                        query.config_index = query.db.config.findIndex(c => c.name === 'enemy');
                        if (query.selection === 'enemy') {
                            if (query.config_index === -1) {
                                query.config_index = query.db.config.push({
                                    name: 'enemy',
                                    rank: ''
                                }) - 1;
                            }
                        } else {
                            if (query.config_index !== -1) {
                                query.db.config.splice(query.config_index, 1);
                            }
                            set_values[`${cache.source_path}_configuration`] = 
                                await setDefectConfiguration(cache, set_values, query);
                            await setDerivedValues(cache, set_values);
                        }
                        query.next = query.selection === 'enemy' ? 'enemy' : 'exit';
                    break;
                    case 'set_skill':
                        const skill_and_group = query.selection.split("~");
                        query.name = `${skill_and_group[0]}`;
                        query.category = skill_and_group[1];
                        query.next = 'write_newattr';
                    break;
                    case 'set_name':
                        query.name = query.selection;
                        query.next = `${query.type}_menu`;
                    break;
                    case 'rename_attribute':
                    case 'rename_group':
                        query.next = `write_${query.type}name`;
                    break;
                    case 'static_attribute_group_name':
                        query.next = 'write_groupname';
                    break;
                    case 'repeating_attribute_attribute':
                    case 'repeating_defect_defect':
                        query.next = 'write_attributename';
                    break;
                    case 'static_attribute_group_type':
                        if (cache.groupdb[cache.static_group_visible_id].level === 0) {
                            query.next = 'write_grouptype';
                        } else {
                            //=> Whisper to player.
                            clog(cache, 'Group level must be set to 0 to change group type.', 'ERROR');
                            query.next = 'exit';
                        }
                    break;
                    case 'static_attribute_group_source':
                        query.next = 'write_groupsource';
                    break;
                    case 'set_group_source':
                        query.source = query.selection;
                        query.next = 'group_menu';
                    break;
                    case 'static_attribute_group_item':
                        query.next = 'write_groupitem';
                    break;
                    case 'set_group_item':
                        query.item = query.selection;
                        query.next = 'group_menu';
                    break;
                    case 'lock_group':
                        query.locked = query.selection === 'yes' ? true : false;
                        query.next = 'group_menu';
                    break;
                    case 'select_level':
                    case 'static_attribute_group_level':
                    case 'repeating_attribute_level':
                    case 'repeating_defect_rank':
                        if (query.attribute === 'unknown power') {
                            query.next = 'exit';
                            query.commit = true;
                            clog(cache, 'Unknown Power does not require levels. Add Character Points through Configuration instead.', 'ERROR');
                        }
                        if (isNaN(query.selection)) {
                            query.next = 'select_level';
                        } else {
                            query.level = int(query.selection);
                            query.next = 'write_level';
                        }
                    break;
                    case 'enhancement_task':
                    case 'limiter_task':
                        query.next = query.selection;
                    break;
                    case 'static_attribute_group_enhancements':
                    case 'static_attribute_group_limiters':
                    case 'repeating_attribute_enhancements':
                    case 'repeating_attribute_limiters':
                        if (query.selection === 'exit') { return; }
                        query.customization = query.selection.split('~').map(s => isNaN(s) ? s : Number(s));
                        query.has_rank = customizationHasRank(query);
                        query.next = query.has_rank ? 'customization_rank' : 'write_customizations';
                    break;
                    case 'enhancement_add':
                        if (query.selection === `${query.type}_menu`) {
                            query.next = query.selection;
                        } else {
                            query.rank = 
                                enhancement_ranks[`${query.attribute}`][`${query.selection}`] === undefined ? 0 :
                                enhancement_ranks[`${query.attribute}`][`${query.selection}`].rank;
                            query.enhancement_index = query.enhancements.push({
                                name: query.selection,
                                rank: query.rank,
                            }) - 1;
                            query.next = 
                                query.selection === 'flare' ?
                                    'attribute_menu' :
                                query.rank === 0 ? 
                                    'enhancement_rank' : `${query.type}_menu`;
                        }
                    break;
                    case 'limiter_add':
                        if (query.selection === `${query.type}_menu`) {
                            query.next = query.selection;
                        } else {
                            query.rank = 
                                limiter_ranks[`${query.attribute}`] === undefined ? 0 :
                                limiter_ranks[`${query.attribute}`][`${query.selection}`].rank;
                            query.limiters.push({
                                name:query.selection,
                                rank: int(`${query.rank}`),
                            });
                            query.next = 
                                query.rank === 0 ? 'limiter_rank' : `${query.type}_menu`;
                        }
                    break;
                    case 'enhancement_remove':
                    case 'limiter_remove':
                        query.index = query[`${query.customization_type}s`].findIndex(c => {
                            return query.selection === c.name;
                        });
                        query[`${query.customization_type}s`].splice(query.index, 1);
                        if (
                            query.attribute === 'armor' && (
                                query.selection === 'optimized' || 
                                query.selection === 'emphasized')
                        ) {
                            query.config_index = query.config.findIndex(c => {
                                return c.name === 'damage_type';
                            });
                            query.config.splice(query.config_index, 1);
                        } else if (query.attribute === 'weapon') {
                            query.customization_index = 
                                query[`${query.customization_type}s`].findIndex(c => {
                                    return c.name === query.selection;
                                });
                            query.config.splice(query.customization_index, 1);
                        }
                    break;
                    case 'customization_rank':
                    case 'movement_rank':
                    case 'sense_rank':
                    case 'technique_rank':
                        if (isNaN(query.selection)) {
                            clog(cache, 'Value must be an integer.', 'ERROR');
                            query.next = query.last;
                        } else {
                            query.rank = int(query.selection);
                            query.next = 
                                query.next === 'customization_rank' ? 'write_customizations' :
                                query.next === 'movement_rank' ? 'write_movement' :
                                query.next === 'sense_rank' ? 'write_sense' :
                                'write_technique';
                        }
                    break;
                    case 'enhancement_rank':
                        if (isNaN(query.selection)) {
                            query.next = 'enhancement_rank';
                        } else {
                            query.rank = int(query.selection);
                            query.next = `${query.type}_menu`;
                            query.enhancements[query.enhancements.length-1].rank = 
                                query.selection;
                        }
                    break;
                    case 'limiter_rank':
                        if (isNaN(query.selection)) {
                            query.next = 'limiter_rank';
                        } else {
                            query.rank = int(query.selection);
                            query.next = `${query.type}_menu`;
                            query.limiters[query.limiters.length-1].rank = 
                                query.selection;
                        }
                    break;
                    case 'remove_attribute':
                    case 'remove_defect':
                        if (query.selection === 'select_task') {
                            query.next = 'select_task';
                        } else {
                            query.remove = query.selection.split('~');
                            query.next = 'remove_confirm';
                        }
                        if (query.remove[0] === 'skills') {
                            let skills_index = -1;
                            for (let i = 0; i < cache.attrdb.skills.length; i++) {
                                if (cache.attrdb.skills[i].row_id === query.remove[1]) {
                                    skills_index = i;
                                    break;
                                }
                            }
                            if(cache.attrdb.skills[skills_index].individual.length !== 0) {
                                clog(cache, '', 'Skill Attributes with existing individual skills cannot be removed');
                                query.next = 'done';
                            }
                        } else if (query.remove[0] === 'shortcoming') {
                            const s_index = cache.defectdb.shortcoming.findIndex(s => s.row_id === query.remove[1]);
                            if (cache.defectdb.shortcoming[s_index].config[1].rank === 'all') {
                                const s_stat = cache.defectdb.shortcoming[s_index].config[0].rank;
                                delete cache.statsdb[s_stat].shortcoming;
                                set_values[`static_character_${s_stat}_remaining`] =
                                    cache.statsdb[s_stat].base +
                                    (cache.statsdb[s_stat].augmented || 0) +
                                    cache.statsdb[s_stat].temp -
                                    (cache.statsdb[s_stat].damage || 0);
                                await setDerivedValues(cache, set_values);
                            }
                        } else if (query.remove[0] === 'augmented') {
                            const aug_index = cache.attrdb.augmented.findIndex(a => a.row_id === query.remove[1]);
                            const stat_index = cache.attrdb.augmented[aug_index].config.findIndex(c => c.name === 'augmented_stat');
                            query.stat = cache.attrdb.augmented[aug_index].config[stat_index].rank;
                            cache.statsdb[query.stat].augmented = 0;
                            for (let i = 0; i < cache.attrdb.augmented.length; i++) {
                                if (cache.attrdb.augmented[i].row_id !== query.remove[1]) {
                                    const temp_index = cache.attrdb.augmented[i].config.findIndex(c => c.name === 'augmented_stat');
                                    if (query.stat = cache.attrdb.augmented[aug_index].config[temp_index].rank === query.stat) {
                                        cache.statsdb[query.stat].augmented += cache.attrdb.augmented[i].elevel;
                                    }
                                }
                            }
                            set_values[`static_character_${query.stat}_remaining`] =
                                cache.statsdb[query.stat].base +
                                (cache.statsdb[query.stat].augmented || 0) +
                                cache.statsdb[query.stat].temp -
                                (cache.statsdb[query.stat].damage || 0);
                            await setDerivedValues(cache, set_values);
                        }
                        if (cache.groupdb[cache.static_group_visible_id].locked) {
                            clog(cache, 'Attributes belonging to an active (i.e. locked) Power Variation cannot be removed', `Error Message (${query.last})`);
                            query.next = 'done';
                        }
                    break;
                    case 'remove_group':
                        query.remove = query.selection.split('~').map(s => isNaN(s) ? s : Number(s));
                        if (
                            cache.groupdb[cache.static_group_visible_id].attribute_ids.length === 0 &&
                            cache.groupdb[cache.static_group_visible_id].defect_ids.length === 0 &&
                            cache.groupdb[cache.static_group_visible_id].level === 0
                        ) {
                            query.next = 'remove_confirm';
                        } else {
                            clog(cache, 'Groups with Attributes, Defects, or level greater than 0 cannot be removed.', 'ERROR');
                            query.next = 'done';
                        }
                    break;
                    case 'remove_confirm':
                        if (query.selection === 'yes') {
                            if (query.type === 'attribute') {
                                const selecteddb = cache.attrdb[`${query.remove[0]}`];
                                const remove_index = selecteddb.findIndex(a => {
                                    return a.row_id === query.remove[1];
                                });
                                if (query.remove[0] === 'skills') {
                                    if(cache.attrdb.skills[remove_index].individual.length !== 0) {
                                        clog(cache, '', 'Skill Attributes with existing individual skills cannot be removed');
                                        query.next = 'done';
                                        break;
                                    }
                                }
                                const selectedgroup = cache.groupdb[selecteddb[remove_index].group_id];
                                if (selectedgroup.group_type === 'standard') {
                                    selectedgroup.group_points -= selecteddb[remove_index].points;
                                    set_values.static_attribute_group_totalpoints = selectedgroup.group_points;
                                }
                                const ids = selectedgroup.attribute_ids;
                                for (let i = 0; i < ids.length; i++) {
                                    if (ids[i] === query.remove[1]) {
                                        ids.splice(ids.indexOf(ids[i]), 1);
                                    }
                                }
                                selecteddb.splice(remove_index, 1);
                                if (query.remove[0] === 'skills') {
                                    set_values.static_skills_attribute_name = selecteddb.length !== 0 ?
                                        selecteddb[0].name : '';
                                    set_values.static_skills_points_total = selecteddb.length !== 0 ?
                                        selecteddb[0].elevel * 2 : '';
                                    set_values.static_skills_points_remaining = selecteddb.length !== 0 ?
                                        selecteddb[0].individual.map(s => s.points).reduce((m, n) => m + n, 0) : '';
                                    set_values.static_skills_visible_id = 0;
                                    cache.static_skills_visible_id = 0;
                                    setSkillUiVisibility(cache, set_values);
                                }
                                if (selectedgroup.group_type === 'power flux') {
                                    setPowerFluxPoolPoints(cache, set_values);
                                } else if (selectedgroup.group_type === 'power variation') {
                                    setPowerVariationGroupPoints(cache, set_values);
                                    setPowerVariationPoolPoints(cache, set_values);
                                } else if (selectedgroup.group_type === 'dynamic powers') {
                                    setDynamicPowersPoolLevels(cache, set_values)
                                }
                                removeRepeatingRow(`repeating_attribute_${query.remove[1]}`);
                                query.next = 'write_attrdb'; //=> This is used just to exit the loop, end script.
                            } else if (query.type === 'defect') {
                                const selecteddb = cache.defectdb[`${query.remove[0]}`];
                                const remove_index = selecteddb.findIndex(a => {
                                    return a.row_id === query.remove[1];
                                });
                                const selectedgroup = cache.groupdb[selecteddb[0].group_id];
                                selectedgroup.group_points -= selecteddb[0].points;
                                set_values.static_attribute_group_totalpoints = selectedgroup.group_points;
                                const ids = selectedgroup.defect_ids;
                                for (let i = 0; i < ids.length; i++) {
                                    if (ids[i] === query.remove[1]) {
                                        ids.splice(ids.indexOf(ids[i]), 1);
                                    }
                                }
                                selecteddb.splice(remove_index, 1);
                                removeRepeatingRow(`repeating_defect_${query.remove[1]}`);
                                query.next = 'write_defectdb'
                            } else if (query.type === 'group') {
                                cache.groupdb[cache.static_group_visible_id].removed = true;
                                query.next = 'removed_group';
                            }
                        } else {
                            query.next = query.selection;
                        }
                    break;
                    case 'reset_confirm':
                    case 'reset_group':
                        if (query.selection === 'yes') {
                            const customization = ['enhancements','limiters'];
                            if (query.type === 'group') {
                                for (let i = 0; i < all_attributes.length; i++) {
                                    for (let j = 0; j < cache.attrdb[all_attributes[i]].length; j++) {
                                        const attribute = cache.attrdb[all_attributes[i]];
                                        if (attribute[j].group_id === cache.static_group_visible_id) {
                                            const base_index = attribute[j].config.findIndex(c => c.name === 'base points');
                                            if (base_index !== -1) {
                                                for (k = 0; k < customization.length; k++) {
                                                    const customizations = attribute[j][customization[k]];
    
                                                    for (let l = 0; l < attribute[j][customization[k]].length; l++) {
                                                        const temp_cust = attribute[j][customization[k]][l];
                                                        const name = attribute[j][customization[k]][l].name;
                                                        const index = attribute[j].config.findIndex(c => c.name === name);
                                                        const temp_rank = attribute[j].config[index].rank;
                                                        attribute[j][customization[k]][l].rank = attribute[j].config[index].rank;
                                                    }
                                                }
                                                const enhancements = attribute[j].enhancements.map(r => r.rank).reduce((m, n) => { return m + n; }, 0);
                                                const limiters = attribute[j].limiters.map(r => r.rank).reduce((m, n) => { return m + n; }, 0);
                                                attribute[j].level = 
                                                    attribute[j].config[base_index].rank / attribute_costs[all_attributes[i]];
                                                attribute[j].elevel = 
                                                    attribute[j].level + limiters - enhancements;
                                                attribute[j].points = attribute[j].config[base_index].rank;
                                                set_values[`repeating_attribute_${attribute[j].row_id}_level`] =
                                                    `${attribute[j].level} (${attribute[j].elevel})`;
                                                set_values[`repeating_attribute_${attribute[j].row_id}_points`] = attribute[j].points;
                                            }
                                        }
                                    }
                                }
                            } else if (query.type === 'attribute') {
                                const attribute = cache.attrdb[query.load[0]][query.load[1]];
                                const base_index = attribute.config.findIndex(c => c.name === 'base points');
                                if (base_index !== -1) {
                                    for (k = 0; k < customization.length; k++) {
                                        const customizations = attribute[customization[k]];
    
                                        for (let l = 0; l < attribute[customization[k]].length; l++) {
                                            const temp_cust = attribute[customization[k]][l];
                                            const name = attribute[customization[k]][l].name;
                                            const index = attribute.config.findIndex(c => c.name === name);
                                            const temp_rank = attribute.config[index].rank;
                                            attribute[customization[k]][l].rank = attribute.config[index].rank;
                                        }
                                    }
                                    const enhancements = attribute.enhancements.map(r => r.rank).reduce((m, n) => { return m + n; }, 0);
                                    const limiters = attribute.limiters.map(r => r.rank).reduce((m, n) => { return m + n; }, 0);
                                    attribute.level = 
                                        attribute.config[base_index].rank / attribute_costs[query.load[0]];
                                    attribute.elevel = 
                                        attribute.level + limiters - enhancements;
                                    attribute.points = attribute.config[base_index].rank;
                                    set_values[`repeating_attribute_${attribute.row_id}_level`] =
                                        `${attribute.level} (${attribute.elevel})`;
                                    set_values[`repeating_attribute_${attribute.row_id}_points`] = attribute.points;
                                }
                            }
                            setPowerVariationGroupPoints(cache, set_values);
                            setPowerVariationPoolPoints(cache, set_values);
                        }
                        query.next = 'done';
                    break;
                    case 'edit_attribute':
                    case 'reset_attribute':
                        if (query.selection !== 'select_task') {
                            query.load = query.selection.split("~");
                            query.attribute = query.load[0];
                            const attribute = cache.attrdb[`${query.attribute}`];
                            const attribute_settings = ['config','elevel','enhancements','level','limiters','name','row_id','stat'];
                            for (let i = 0, n = attribute_settings.length; i < n; i++) {
                                query[attribute_settings[i]] = attribute[query.load[1]][attribute_settings[i]];
                            }
                            query.attribute_translation = query.load[0].toKebobCase();
                        }
                        query.next = query.selection === 'select_task' ? query.selection : 
                            query.task === 'reset' ? 'reset_confirm' : 'attribute_menu';
                    break;
                    case 'edit_defect':
                        query.load = query.selection.split("~");
                        query.defect = query.load[0];
                        const defect = cache.defectdb[`${query.defect}`];
                        const defect_settings = ['group_id','name','rank','row_id','visibility'];
                        for (let i = 0, n = defect_settings.length; i < n; i++) {
                            query[defect_settings[i]] = defect[query.load[1]][defect_settings[i]];
                        }
                        query.defect_translation = query.load[0].toKebobCase();
                        query.next = 'defect_menu'
                    break;
                    case 'edit_group':
                        query.load = query.selection.split('~').map(s => isNaN(s) ? s : Number(s));
                        const group_settings = ['group_points','group_type','level','name','item','source','stat'];
                        for (let i = 0, n = group_settings.length; i < n; i++) {
                            query[group_settings[i]] = cache.groupdb[query.load[1]][group_settings[i]] || 0;
                        }
                        const group_type_settings = query.group_type !== 'standard' ?
                            ['enhancements', 'limiters', 'level'] : [];
                        for (let i = 0, n = group_type_settings.length; i < n; i++) {
                            query[group_type_settings[i]] = cache.groupdb[query.load[1]][group_type_settings[i]] || 0;
                        }
                        if (query.group_type === 'power variation') {
                            query.locked = cache.groupdb[query.load[1]].locked;
                        }
                        query.attribute = query.group_type;
                        query.attribute_translation = query.attribute.toKebobCase();
                        query.next = 'group_menu'
                    break;
                    case 'config_attribute':
                        if (query.selection === 'attribute_menu') {
                            query.next = 'attribute_menu';
                        } else if (query.attribute === 'absorption') {
                            const index = query.config.findIndex(c => {
                                return c.name === 'transform';
                            });
                            if (index === -1) {
                                query.config.push({
                                    name: 'transform',
                                    rank: query.selection
                                });
                            } else {
                                query.config[index].rank = query.selection;
                            }
                            query.next = 'attribute_menu';
                        } else {
                            const index = query.config.findIndex(c => {
                                return c.name === query.selection;
                            });
                            if (index === -1) {
                                query.customization = query.selection;
                                if (
                                    query.customization === 'hardboiled' ||
                                    query.customization === 'lightning reflexes'
                                ) {
                                    query.next = 'config_rank';
                                } else {
                                    query.config.push({
                                        name: query.customization,
                                        rank: 1
                                    });
                                }
                            } else {
                                query.config.splice(index, 1);
                            }
                        }
                    break;
                    case 'config_flare':
                        query.customization = 'flare';
                        query.sense = query.selection;
                        query.next = query.selection === 'attribute_menu' ?
                            'attribute_menu' : 'config_rank';
                    break;
                    case 'config_rank':
                        if (query.customization === 'flare') {
                            query.sense_index = query.config[query.config_index].senses.findIndex(f => {
                                return f.name === query.sense;
                            });
                            if (query.sense_index === -1) {
                                query.config[query.config_index].senses.push({
                                    name: query.sense,
                                    rank: int(query.selection)
                                });
                            } else {
                                query.config[query.config_index].senses[query.sense_index].rank = 
                                    int(query.selection);
                            }
                            query.enhancement_index = query.enhancement_index === undefined ?
                                query.enhancements.findIndex(f => {
                                    return f.name === "flare";
                                }) : query.enhancement_index;
                            query.enhancements[query.enhancement_index].rank = 
                                query.config[query.config_index].senses.map(f => {
                                    return f.rank;
                                }).reduce((m, n) => { return m + n; }, 0);
                        } else {
                            query.config.push({
                                name: query.customization,
                                rank: int(query.selection)
                            });
                        }
                        query.next = query.customization === 'flare' ?
                            'config_flare' : 'config_attribute';
                    break;
                    case 'config_customization':
                    case 'repeating_attribute_configuration':
                    case 'repeating_defect_configuration':
                        if (query.selection === undefined && query.configurations.length === 1) {
                            const selection = query.configurations[0].split(",");
                            query.selection = selection[1];
                        } else if (query.selection === 'exit') { return; }
                        query.load = query.selection.split("~");
                        query.config_index = int(query.load[1]);
                        query.config_name = query.load[0];
                        query.next =
                            query.config_name === 'unaffected' &&
                            query.all_attributes &&
                            !query.all_weapons ?
                        'weapon_enhancement' : query.config_name;
                    break;
                    // => configurations
                    case 'aspect_stat':
                        if (query.selection === 'exit') { return; }
                        query.load = query.selection.split("~");
                        cache.defectdb.shortcoming[query.index].config = [
                            {name:'aspect_name',rank:query.load[1]},
                            {name:'aspect_stat',rank:query.load[2]},
                            {name:'aspect_type',rank:query.load[3]},
                        ];
                        set_values[`repeating_defect_${cache.source_id}_configuration`] = query.load[0];
                        query.points = query.db.level !== 0 ? query.db.level * -1 : 0;
                        if (query.load[3] === 'all') {
                            cache.statsdb[query.load[2]].shortcoming = query.db.level;
                            query.points *= 2;
                        }
                        query.db.points = query.points;
                        set_values[`${cache.source_path}_points`] = query.points;
                        await setStat(cache, query, set_values);
                        await setDerivedValues(cache, set_values);
                        if (cache.groupdb[cache.static_group_visible_id].group_type === 'power flux') {
                            setPowerFluxPoolPoints(cache, set_values);
                        } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'power variation') {
                            setPowerVariationGroupPoints(cache, set_values);
                            setPowerVariationPoolPoints(cache, set_values);
                        } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'dynamic powers') {
                            setDynamicPowersPoolLevels(cache, set_values);
                            setGroupCharacterPoints(cache, set_values);
                        } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'gear') {
                            setGearPoolLevels(cache, set_values);
                            setGroupCharacterPoints(cache, set_values);
                        } else {
                            setGroupCharacterPoints(cache, set_values);
                        }
                        query.next = 'exit';
                    break;
                    case 'unaffected':
                        const attribute_temp = query.selection.split('~');
                        query.unaffected = attribute_temp[0];
                        query.unaffected_index = int(attribute_temp[1]);
                        if (query.unaffected_index === -1) {
                            query.attributes.push(query.unaffected);
                        } else if (query.unaffected !== 'weapon') {
                            query.attributes.splice(query.unaffected_index, 1);
                        }
                        query.next = query.unaffected === 'weapon' ? 'weapon_enhancement' : 'write_unaffected';
                    break;
                    case 'weapon_enhancement':
                        const weapon_enhancement = query.selection.split('~');
                        const weapon_index = int(weapon_enhancement[1]);
                        query.unaffected = 'weapon';
                        if (weapon_index === -1) {
                            query.weapons.push(weapon_enhancement[0]);
                        } else {
                            query.weapons.splice(weapon_index, 1);
                            if (query.weapons.length === 0) {
                                query.attributes.splice(query.weapon_index, 1);
                            }
                        }
                        query.next = 'write_unaffected';
                    break;
                    case 'augmented_stat':
                        if (query.selection === 'exit') { return; }
                        cache.attrdb[query.attribute][query.index].config[query.config_index].rank = query.selection;
                        set_values[`${cache.source_path}_configuration`] = await setConfiguration(cache, set_values, query);
                        query.next = 'exit';
                    break;
                    case 'capacity_type':
                        if (query.selection === 'exit') { return; }
                        cache.attrdb[query.attribute][query.index].config[query.config_index].rank = query.selection;
                        set_values[`${cache.source_path}_configuration`] = await setConfiguration(cache, set_values, query);
                        query.next = 'exit';
                    break;
                    case 'damage_type':
                    case 'weapon_class':
                        if (query.selection === 'exit') { return; }
                        cache.attrdb[query.attribute][query.index].config[query.config_index].rank = query.selection;
                        set_values[`${cache.source_path}_configuration`] = await setConfiguration(cache, set_values, query);
                        query.next = 'exit';
                    break;
                    case 'achilles heel':
                    case 'defense type':
                    case 'enemy':
                    case 'group':
                    case 'origin template':
                    case 'species':
                    case 'trigger':
                        if (query.selection !== 0) {
                            query.db.config[query.config_index].rank = query.selection;
                            set_values[cache.source] = query.type === 'attribute' ?
                                await setConfiguration(cache, set_values, query) :
                                await setDefectConfiguration(cache, set_values, query);
                            if (query.next === 'enemy' && query.type === 'defect') {
                                await setDerivedValues(cache, set_values);
                            }
                            query.next = 'exit';
                        }
                    break;
                    case 'add_sixth_sense':
                        query['sixth sense'] = query.selection === 0 ? '' : query.selection;
                        query.next = 'write_sixth_sense';
                    break;
                    case 'environment':
                    case 'feature':
                    case 'resiliency':
                        query[query.next] = query.selection === 0 ? '' : query.selection;
                        query.next = `write_${query.next}`;
                    break;
                    case 'complete_resilience':
                        query.load = query.selection.split("~");
                        query.resilient = query.load[0];
                        query.is_complete = int(query.load[1]);
                        if (query.is_complete !== -1) {
                            query.db.config[query.config_index].rank.splice(query.is_complete, 1);
                        } else {
                            query.db.config[query.config_index].rank.push(query.resilient);
                        }
                        query.next = 'write_complete_resiliency';
                    break;
                    case 'environments':
                    case 'features':
                    case 'resilient':
                        if (query.selection === 'exit') { return; }
                        query.env_index = query.selection === 'add' ? -1 : int(query.selection);
                        query.next = 
                            query.next === 'resilient' ? 'resiliency' :
                            query.next === 'complete_resilience' ? 'complete_resiliency' :
                            query.next.slice(0, -1);
                        query[query.next] = query.selection === 'add' ? 
                            '' : query.db.config[query.config_index].rank[query.env_index];
                    break;
                    case 'immunity':
                        query.immunity = query.selection === 0 ? '' : query.selection;
                        query.next = 'write_immunity';
                    break;
                    case 'movements':
                        const special_movement_ranks = {
                            'balance':{rank:1},
                            'cat-like':{rank:1},
                            'fast':{},
                            'light-footed':{rank:1},
                            'slithering':{rank:1},
                            'speedburst':{},
                            'swinging':{rank:1},
                            'untrackable':{rank:1},
                            'wall-bouncing':{rank:1},
                            'wall-crawling':{rank:1},
                            'water-walking':{rank:1},
                            'zen direction':{rank:1},
                        };
                        query.movement = query.selection;
                        query.rank = special_movement_ranks[query.movement].rank;
                        query.has_rank = query.rank === undefined ? true : false;
                        query.movement_index = cache.attrdb[query.attribute][query.index].config.findIndex(c => c.name === 'movements');
                        query.movements = cache.attrdb[query.attribute][query.index].config[query.movement_index].rank;
                        query.has_movement = query.movements.findIndex(m => m.name === query.movement);
                        query.next = query.rank === undefined ? 'movement_rank' : 'write_movement';
                    break;
                    case 'notes':
                        query.selection = query.selection === 0 ? '' : query.selection;
                        query.next = 'write_notes';
                    break;
                    case 'other_sense':
                    case 'taunt':
                        if (query.selection === 0) { return; }
                        query.sense = query.selection;
                        query.next = query.next === 'taunt' ?
                            'write_taunt' :
                            'write_sensory_block';
                    break;
                    case 'other_supersense':
                        query.selection = query.selection === 0 ? '' : query.selection;
                        query.next = 'write_supersense';
                    break;
                    case 'senses':
                        query.c_index = query.db.config.findIndex(c => c.name === 'senses');
                        query.env_index = query.db.config[query.c_index].rank.findIndex(s => s.name === query.selection);
                        query.sense = query.selection;
                        query.next = 'sense_rank';
                    break;
                    case 'senses_or_techniques':
                        query.sense = query.selection === 0 ? '' : query.selection;
                        query.next = query.selection === 'other' ? 'other_sense' : 'write_sensory_block';
                    break;
                    case 'sixth sense':
                        if (query.selection === 'exit') { return; }
                        query.env_index = query.selection === 'add' ? -1 : int(query.selection);
                        query[query.next] = '';//query.selection === 'add' ? 
                            //'' : query.db.config[query.config_index].rank[query.env_index];
                        query.next = query.env_index === -1 ? 'add_sixth_sense' : 'write_sixth_sense';
                    break;
                    case 'size change':
                        query.config_index = query.db.config.findIndex(c => c.name === 'size change');
                        query.db.config[query.config_index].rank = query.selection;
                        set_values[`${cache.source_path}_configuration`] = await setConfiguration(cache, set_values, query);
                        query.next = 'exit';
                    break;
                    case 'source':
                        query.source = query.selection === 0 ? '' : query.selection;
                        query.next = 'write_source';
                    break;
                    case 'supersense':
                        query.next = query.selection === 'other' ? 'other_supersense' : 'write_supersense';
                    break;
                    case 'techniques':
                        const combat_techinique_ranks = {
                            'blackout':{rank:1},
                            'blind fighting':{rank:1},
                            'blind shooting':{rank:1},
                            'brutal':{rank:1},
                            'concealment':{rank:1},
                            'critical strike':{rank:1},
                            'dead eye':{rank:1},
                            'death dodge':{rank:1},
                            'debilitate':{rank:1},
                            'deflection':{rank:1},
                            'enhanced knockback':{rank:1},
                            'extended range':{rank:1},
                            'far shot':{rank:1},
                            'flanking defense':{rank:1},
                            'hardboiled':{},
                            'judge opponent':{rank:1},
                            'lethal blow':{rank:1},
                            'lightning reflexes':{},
                            'multiple targets':{rank:1},
                            'portable armory':{rank:1},
                            'precise aim':{rank:1},
                            'reflection':{rank:1},
                            'rush attack':{rank:1},
                            'steady hand':{rank:1},
                            'tournament encyclopedia':{rank:1},
                            'two weapons':{rank:1},
                            'weapons encyclopedia':{rank:1},
                        };
                        query.technique = query.selection;
                        query.rank = combat_techinique_ranks[query.technique].rank;
                        query.has_rank = query.rank === undefined ? true : false;
                        query.technique_index = cache.attrdb[query.attribute][query.index].config.findIndex(c => c.name === 'techniques');
                        query.techniques = cache.attrdb[query.attribute][query.index].config[query.technique_index].rank;
                        query.has_technique = query.techniques.findIndex(t => t.name === query.technique);
                        query.next = query.rank === undefined ? 'technique_rank' : 'write_technique';
                    break;
                    case 'transform':
                        if (query.selection === 'exit') { return; }
                        cache.attrdb[query.attribute][query.index].config[query.config_index].rank = query.selection;
                        set_values[`${cache.source_path}_configuration`] = await setConfiguration(cache, set_values, query);
                        query.next = 'exit';
                    break;
                    case 'unknown power':
                        if (isNaN(query.selection)) {
                            query.next = 'unknown power';
                        } else {
                            query.rank = int(query.selection);
                            cache.attrdb[query.attribute][query.index].config[query.config_index].rank = query.rank;
                            cache.attrdb[query.attribute][query.index].points = query.rank;
                            set_values[`${cache.source_path}_configuration`] = await setConfiguration(cache, set_values, query);
                            set_values[`${cache.source_path}_points`] = query.rank;
                            if (cache.groupdb[cache.static_group_visible_id].group_type === 'power flux') {
                                setPowerFluxPoolPoints(cache, set_values);
                            } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'power variation') {
                                setPowerVariationGroupPoints(cache, set_values);
                                setPowerVariationPoolPoints(cache, set_values);
                            } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'dynamic powers') {
                                setDynamicPowersPoolLevels(cache, set_values);
                            } else {
                                setGroupCharacterPoints(cache, set_values, cache.static_group_visible_id);
                            }
                            setCharacterPointsRemaining(cache, set_values);
                            query.next = 'exit';
                        }
                    break;

                    case 'add_defect':
                        query.defect = query.selection;
                        query.task = 'add';
                        query.defect_translation = query.defect.toKebobCase();
                        query.next = 'write_newdefect';
                    break;
                    
                    case 'defect_rank':
                        if (isNaN(query.selection)) {
                            query.next = 'defect_rank';
                        } else {
                            query.rank = int(query.selection);
                            query.next = 'defect_menu';
                        }
                    break;
                    case 'stat_menu':
                    case 'static_attribute_group_stat':
                    case 'repeating_attribute_stat':
                        query.stat = query.selection;
                        query.next = `write_stat`;
                    break;
                    default:
                        query.commit === true;
                }
            } else {
                query.fields = 
                    query.next === 'write_newattr' ? ['attribute','cost','level','name','points','stat'] :
                    query.next === 'write_newdefect' ? ['defect','name','points','rank'] : [];
                query.row_id = query.next === 'write_newattr' || query.next === 'write_newdefect' ? generateRowID() : '';
                switch (query.next) {
                    case 'write_newattr':
                        //-> write attribute object into cache and create repeating section
                        const attrdb_entry = {};
                        for (let i = 0; i < query.fields.length; i++) {
                            let value = '';
                            switch (query.fields[i]) {
                                case 'attribute':
                                    value = getTranslationByKey(query.attribute_translation).capitalize();
                                break;
                                case 'stat':
                                    value = getTranslationByKey(`${query[query.fields[i]]}`).capitalize();
                                break;
                                case 'cost':
                                    query.cost = query.attribute === 'skill group' ?
                                        skill_group_costs[query.category] :
                                        attribute_costs[query.attribute] * (
                                            query.attribute === 'superstrength' &&
                                            cache.rulebook === 'absolutepower' ? 2 : 1
                                        );
                                    value = query.cost;
                                break;
                                case 'level':
                                    value = '0 (0)';
                                break;
                                case 'name':
                                    value = query.attribute === 'skill group' ? 
                                        query.name.capitalize() :
                                        getTranslationByKey(query.attribute.toKebobCase());
                                break;
                                case 'points':
                                    value = 0;
                                break;
                            }
                            set_values[`repeating_attribute_${query.row_id}_${query.fields[i]}`] = value;
                        }
                        switch (query.attribute) {
                            case 'absorption':
                                query.config.push({
                                    name: 'transform',
                                    rank: 'health-points'
                                });
                            case 'armor':
                            case 'conversion':
                            case 'force field':
                                query.config.push({
                                    name: `${
                                        query.attribute === 'absorption' ? 'absorb' :
                                        query.attribute === 'conversion' ? 'convert' :
                                        'armor rating'
                                    }`,
                                    rank: 0
                                });
                            break;
                            case 'augmented':
                                query.config.push({
                                    name: 'augmented_stat',
                                    rank: 'body'
                                });
                            break;
                            case 'capacity':
                                query.config.push({
                                    name: 'capacity_type',
                                    rank: 'carry'
                                });
                            break;
                            case 'combat technique':
                                query.config.push({
                                    name: 'techniques',
                                    rank: []
                                });
                            break;
                            case 'control environment':
                                query.config.push({
                                    name: 'environments',
                                    rank: []
                                });
                            break;
                            case 'enemy attack':
                            case 'enemy defense':
                                query.config.push({
                                    name: 'enemy',
                                    rank: getTranslationByKey("not-configured")
                                });
                            break;
                            case 'features':
                                query.config.push({
                                    name: 'features',
                                    rank: []
                                });
                            case 'heightened senses':
                                query.config.push({
                                    name: 'senses',
                                    rank: []
                                });
                            break;
                            case 'melee attack':
                            case 'melee defense':
                            case 'ranged attack':
                                query.config.push({
                                    name: query.attribute,
                                    rank: 0
                                });
                                query.config.push({
                                    name: 'weapon_class',
                                    rank: ''
                                });
                            break;
                            case 'metamorphosis':
                                query.config.push({
                                    name: query.attribute,
                                    rank: 0
                                });
                                query.config.push({
                                    name: 'origin template',
                                    rank: ''
                                });
                            break;
                            case 'mimic':
                            case 'nullify':
                                query.config.push({
                                    name: query.attribute,
                                    rank: 0
                                });
                                query.config.push({
                                    name: 'source',
                                    rank: ''
                                });
                            break;
                            case 'ranged defense':
                                query.config.push({
                                    name: query.attribute,
                                    rank: 0
                                });
                                query.config.push({
                                    name: 'defense type',
                                    rank: 'personal'
                                });
                            break;
                            case 'sensory block':
                            case 'undetectable':
                                query.config.push({
                                    name: 'senses_or_techniques',
                                    rank: []
                                });
                            break;
                            case 'skills':
                                query.config.push({
                                    name: 'skill points',
                                    rank: 0
                                });
                            break;
                            case 'special movement':
                                query.config.push({
                                    name: 'movements',
                                    rank: []
                                });
                            break;
                            case 'swarm':
                                query.config.push({
                                    name: 'critter',
                                    rank: ''
                                });
                            break;
                            case 'unaffected':
                                query.config.push({
                                    name: 'unaffected',
                                    rank: [],
                                });
                                query.config.push({
                                    name: 'source',
                                    rank: '',
                                });
                            break;
                            case 'weapon':
                                query.config.push({
                                    name: 'damage',
                                    rank: 0,
                                });
                                query.config.push({
                                    name: 'damage_type',
                                    rank: '',
                                });
                                query.config.push({
                                    name: 'weapon_class',
                                    rank: '',
                                });
                            break;
                            default:
                                query.config.push({
                                    name: query.attribute,
                                    rank:
                                        query.attribute === 'immunity' ||
                                        query.attribute === 'supersense' ||
                                        query.attribute === 'taunt' ? '' :
                                        query.attribute === 'size change' ? 'grow' :
                                        query.attribute === 'resilient' ||
                                        query.attribute === 'sixth sense' ? [] :
                                        query.attribute === 'skill group' ? query.category :
                                        0
                                });
                        }
                        query.config.push({
                            name: 'notes',
                            rank: '',
                        });
                        if (cache.groupdb[cache.static_group_visible_id].group_type === 'power variation') {
                            query.config.push({
                                name: 'base points',
                                rank: 0
                            });
                        }
                        set_values[`repeating_attribute_${query.row_id}_configuration`] = await setConfiguration(cache, set_values, query);
                        
                        attrdb_entry.active = query.attribute === 'swarm' ? false : true;
                        attrdb_entry.config = query.config;
                        attrdb_entry.elevel = query.elevel;
                        attrdb_entry.enhancements = query.enhancements;
                        attrdb_entry.group_id = cache.static_group_visible_id;
                        attrdb_entry.level = query.level;
                        attrdb_entry.limiters = query.limiters;
                        attrdb_entry.name = query.name;
                        attrdb_entry.row_id = query.row_id;
                        attrdb_entry.stat = query.stat;
                        attrdb_entry.points = query.cost * query.level;
                        attrdb_entry.visibility = 1;
                        if (query.attribute === 'unaffected') {
                            attrdb_entry.unaffected_weapons = [];
                        }
                        cache.attrdb[query.attribute].push(attrdb_entry);
                        cache.groupdb[cache.static_group_visible_id].attribute_ids.push(query.row_id);
                        if (cache.groupdb[attrdb_entry.group_id].group_type === 'power flux') {
                            setPowerFluxPoolPoints(cache, set_values);
                        } else if (cache.groupdb[attrdb_entry.group_id].group_type === 'power variation') {
                            setPowerVariationGroupPoints(cache, set_values);
                            setPowerVariationPoolPoints(cache, set_values);
                        } else if (cache.groupdb[attrdb_entry.group_id].group_type === 'dynamic powers') {
                            setDynamicPowersPoolLevels(cache, set_values);
                        } else {
                            setGroupCharacterPoints(cache, set_values, attrdb_entry.group_id);
                        }
                        if (query.attribute === 'skills') {
                            cache.attrdb.skills[cache.attrdb.skills.length - 1].individual = [];
                            set_values.static_skills_attribute_name = query.name;
                            set_values.static_skills_points_total = query.config[0].rank;
                            set_values.static_skills_points_remaining = query.config[0].rank;
                            set_values.static_skills_visible_id = cache.attrdb.skills.length - 1;
                            setSkillUiVisibility(cache, set_values);
                        }
                        set_values[`repeating_attribute_${query.row_id}_active`] = 1;
                    break;
                    case 'write_newdefect':
                        for (let i = 0; i < query.fields.length; i++) {
                            let value = '';
                            switch (query.fields[i]) {
                                case 'defect':
                                    value = getTranslationByKey(query.defect.toKebobCase());
                                break;
                                case 'name':
                                    value = getTranslationByKey(query.defect.toKebobCase());
                                break;
                                case 'points':
                                    value = 0;
                                break;
                                case 'rank':
                                    value = 0;
                                break;
                            }
                            set_values[`repeating_defect_${query.row_id}_${query.fields[i]}`] = value;
                        }
                        switch (query.defect) {
                            case 'easily distracted':
                                query.config.push({
                                    name: 'trigger',
                                    rank: ''
                                });
                            break;
                            case 'inept attack':
                            case 'inept defense':
                                query.config.push({
                                    name: query.defect,
                                    rank: ''
                                });
                                query.config.push({
                                    name: 'attack_type',
                                    rank: 'any'
                                });
                            break;
                            case 'shortcoming':
                                query.config.push({
                                    name: 'aspect_name',
                                    rank: ''
                                });
                                query.config.push({
                                    name: 'aspect_stat',
                                    rank: ''
                                });
                                query.config.push({
                                    name: 'aspect_type',
                                    rank: ''
                                });
                            break;
                            default:
                                query.config.push({
                                    name: query.defect,
                                    rank: ''
                                });
                        }
                        //set_values[`repeating_defect_${query.row_id}_configuration`] = await setDefectConfiguration(cache, set_values, query);
                        set_values[`repeating_defect_${query.row_id}_active`] = 1;
                        const defectdb_entry = {};
                        defectdb_entry.active = true;
                        defectdb_entry.config = query.config;
                        defectdb_entry.group_id = cache.static_group_visible_id;
                        defectdb_entry.rank = 0;
                        defectdb_entry.name = '';
                        defectdb_entry.row_id = query.row_id;
                        defectdb_entry.points = 0;
                        defectdb_entry.visibility = 1;
                        cache.groupdb[cache.static_group_visible_id].defect_ids.push(query.row_id);
                        cache.defectdb[query.defect].push(defectdb_entry);
                    break;
                    case 'write_attributename':
                        const db = cache.source_attribute === 'attribute' ? cache.attrdb : cache.defectdb;
                        db[query[`${cache.source_attribute}`]][query.index].name = query.selection;
                        set_values[`repeating_${cache.source_attribute}_${cache.source_id}_name`] = query.selection;
                    break;
                    case 'write_complete_resiliency':
                        set_values[`${cache.source}`] = await setConfiguration(cache, set_values, query);
                    break;
                    case 'write_environment':
                    case 'write_feature':
                    case 'write_resiliency':
                    case 'write_sixth_sense':
                        query.config_name = query.next.substring(6).fromSnakeCase();
                        if (query.env_index === -1) {
                            query.db.config[query.config_index].rank.push(query[query.config_name]);
                        } else if (query.env_index !== -1 && query[query.config_name] === '') {
                            query.db.config[query.config_index].rank.splice(query.env_index, 1);
                        } else {
                            query.db.config[query.config_index].rank[query.env_index] = query[query.config_name];
                        }
                        if (query.next === 'write_sixth_sense') {
                            const sixth_senses = [];
                            for (let i = 0; i < cache.attrdb['sixth sense'].length; i++) {
                                const sixth_index = cache.attrdb['sixth sense'][i].config.findIndex(c => c.name === 'sixth sense');
                                Array.prototype.push.apply(sixth_senses, cache.attrdb['sixth sense'][i].config[sixth_index].rank);
                            }
                            set_values.static_character_capabilities_sixthsense = sixth_senses.sort().capitalize().join(", ");
                        }
                        set_values[`${cache.source}`] = await setConfiguration(cache, set_values, query);
                    break;
                    case 'write_immunity':
                        query.db.config[query.config_index].rank = query.immunity;
                        set_values[`${cache.source}`] = await setConfiguration(cache, set_values, query);
                    break;
                    case 'write_sense':
                        if (query.env_index === -1) {
                            if (query.rank === 0) { return; }
                            query.db.config[query.config_index].rank.push({
                                name: query.sense,
                                rank: query.rank
                            });
                        } else {
                            if (query.rank === 0) {
                                query.db.config[query.config_index].rank.splice(query.env_index, 1);
                            } else {
                                query.db.config[query.config_index].rank[query.env_index].rank = query.rank;
                            }
                        }
                        set_values[`${cache.source}`] = await setConfiguration(cache, set_values, query);
                    break;
                    case 'write_sensory_block':
                        query.has_sense = query.db.config[query.config_index].rank.findIndex(s => s === query.sense);
                        if (query.has_sense !== -1) {
                            query.db.config[query.config_index].rank.splice(query.has_sense, 1);
                        } else {
                            query.db.config[query.config_index].rank.push(query.sense);
                        }
                        set_values[`${cache.source}`] = await setConfiguration(cache, set_values, query);
                    break;
                    case 'write_source':
                        query.config_name = query.next.substring(6);
                        query.db.config[query.config_index].rank = query[query.config_name];
                        set_values[`${cache.source}`] = await setConfiguration(cache, set_values, query);
                    break;
                    case 'write_notes':
                    case 'write_supersense':
                    case 'write_taunt':
                        query.db.config[query.config_index].rank = query.selection;
                        set_values[`${cache.source}`] = await setConfiguration(cache, set_values, query);
                    break;
                    case 'write_unaffected':
                        query.db.config[query.config_index].rank = 
                            query.attributes.map(a => {
                                if (a === 'weapon') {
                                    return {name:a, rank:[...query.weapons]};
                                } else {
                                    return {name:a};
                                }
                            });
                        set_values[`${cache.source}`] = await setConfiguration(cache, set_values, query);
                    break;
                    case 'write_groupname':
                        cache.groupdb[cache.static_group_visible_id].name = query.selection;
                        set_values.static_attribute_group_name = query.selection;
                    break;
                    case 'write_groupsource':
                        cache.groupdb[cache.static_group_visible_id].source = query.selection;
                        set_values.static_attribute_group_source = query.selection.capitalize();
                    break;
                    case 'write_groupitem':
                        cache.groupdb[cache.static_group_visible_id].item = query.selection;
                        set_values.static_attribute_group_item = query.selection.capitalize();
                        await setGroupCharacterPoints(cache, set_values);
                        cache.statsdb.cp.spent =
                            getSpentCharacterPoints(cache);
                        set_values.static_character_points_spent = cache.statsdb.cp.spent;
                        set_values.static_character_points_remaining =
                            cache.statsdb.cp.base +
                            cache.statsdb.cp.gained +
                            cache.statsdb.cp.temp -
                            cache.statsdb.cp.spent;
                    break;
                    case 'write_grouptype':
                        cache.groupdb[cache.static_group_visible_id].group_type = query.selection;
                        set_values.static_attribute_group_type = 
                            getTranslationByKey(query.selection.toKebobCase());
                            //cache.groupdb[cache.static_group_visible_id].group_type.capitalize();
                        if (query.selection === 'gear') {
                            cache.groupdb[cache.static_group_visible_id].item = 'gear';
                            set_values.static_attribute_group_item = 
                                cache.groupdb[cache.static_group_visible_id].item.capitalize();
                        } else if (cache.groupdb[cache.static_group_visible_id].item === 'gear') {
                            cache.groupdb[cache.static_group_visible_id].item = 'no';
                            set_values.static_attribute_group_item = getTranslationByKey("no");
                        }
                        showDynamicGroupFields(cache, set_values);
                        setAttributeGroupVisibility(cache, set_values);
                    break;
                    case 'write_level':
                        if (query.type === 'group') {
                            query.enhancements_ranks = 
                                cache.groupdb[cache.static_group_visible_id].group_type === 'standard' ? 
                                0 : cache.groupdb[cache.static_group_visible_id].enhancements.length;
                            query.limiters_ranks = 
                                cache.groupdb[cache.static_group_visible_id].group_type === 'standard' ? 
                                0 : cache.groupdb[cache.static_group_visible_id].limiters.length;
                            query.elevel = query.level + query.limiters_ranks - query.enhancements_ranks;
                            query.cost = attribute_costs[cache.groupdb[cache.static_group_visible_id].group_type];
                            query.points = query.cost * query.level;
                            cache.groupdb[cache.static_group_visible_id].points = query.points;
                            cache.groupdb[cache.static_group_visible_id].elevel = query.elevel;
                            cache.groupdb[cache.static_group_visible_id].level = query.level;
                            set_values.static_attribute_group_points = query.points;
                            set_values.static_attribute_group_level = `${query.level} (${query.elevel})`;
                        } else {
                            if (cache.source_section === 'attribute') {
                                for (let i = 0; i < customization_type.length; i++) {
                                    query[`${customization_type[i]}_ranks`] = 
                                    cache.attrdb[query.attribute][query.index][`${customization_type[i]}`].map(c => c.rank).reduce((a, b) => a + b, 0);    
                                }
                                query.elevel = query.level + query.limiters_ranks - query.enhancements_ranks;
                                cache.attrdb[query.attribute][query.index].elevel = query.elevel;
                            }
                            query.type_index = query.attribute !== 'skill group' ? 0 :
                                query.db.config.findIndex(c => c.name === 'skill group');
                            query.cost_multiplier = 1;
                            if (query.defect === 'shortcoming') {
                                query.aspect_index = query.db.config.findIndex(c => c.name === 'aspect_type');
                                query.cost_multiplier = query.aspect_index !== -1 ?
                                    query.db.config[query.aspect_index].rank === 'all' ? 2 : 1 : 1;
                            } else if (query.attribute === 'armor' || query.attribute === 'force field') {
                                const ar_index = query.db.config.findIndex(c => c.name === 'armor rating');
                                if (ar_index !== -1) {
                                    query.db.config[ar_index].rank = (query.attribute === 'armor' ? 5 : 10) * query.elevel;
                                }
                            }
                            query.cost = (cache.source_section === 'attribute' ?
                                query.attribute === 'skill group' ?
                                skill_group_costs[query.db.config[query.type_index].rank] :
                                attribute_costs[query.attribute]  * (
                                    query.attribute === 'superstrength' &&
                                    cache.rulebook === 'absolutepower' ? 2 : 1
                                ) :
                                defect_costs[query.defect]) * query.cost_multiplier;
                            query.points = cache.groupdb[cache.static_group_visible_id].group_type === 'gear' ?
                                0 : (query.cost * query.level) * (cache.source_section === 'attribute' ? 1 : -1);
                            const db = cache.source_section === 'attribute' ? cache.attrdb : cache.defectdb;
                            db[query[cache.source_section]][query.index].points = query.points;
                            db[query[cache.source_section]][query.index].level = query.level;
                            set_values[`${cache.source_path}_points`] = query.points;
                            set_values[`${cache.source_path}_${
                                cache.source_section === 'attribute' ? 'level' : 'rank'
                            }`] = `${query.level}${
                                cache.source_section === 'attribute' ? ' (' + query.elevel + ')' : ''
                            }`;
                            if (
                                cache.source_section === 'attribute' &&
                                cache.groupdb[cache.static_group_visible_id].group_type === 'power variation' &&
                                !cache.groupdb[cache.static_group_visible_id].locked
                            ) {
                                const index = cache.attrdb[query.attribute][query.index].config.findIndex(c => c.name === 'base points');
                                cache.attrdb[query.attribute][query.index].config[index].rank = query.points;
                            } else if (query.last === 'repeating_defect_rank') {
                                if (query.defect === 'shortcoming') {
                                    const aspect_type_index = query.db.config.findIndex(c => c.name === 'aspect_type');
                                    if (query.db.config[aspect_type_index].rank === 'all') {
                                        await setShortcomingAspectTypeAll(cache, set_values, query);
                                    }
                                }
                            }
                            set_values[`${cache.source_path}_configuration`] = query.type === 'attribute' ?
                                await setConfiguration(cache, set_values, query) :
                                await setDefectConfiguration(cache, set_values, query);
                            const defect_values = [
                                'inept attack',
                                'inept defense',
                                'reduced damage',
                                'demure',
                                'fragile',
                                'unsettled'
                            ];
                            if (defect_values.findIndex(d => d === query.defect) !== -1) {
                                await setDerivedValues(cache, set_values);
                            }
                        }
                        if (cache.groupdb[cache.static_group_visible_id].group_type === 'power flux') {
                            setPowerFluxPoolPoints(cache, set_values);
                        } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'power variation') {
                            setPowerVariationGroupPoints(cache, set_values);
                            setPowerVariationPoolPoints(cache, set_values);
                        } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'dynamic powers') {
                            setDynamicPowersPoolLevels(cache, set_values);
                            setGroupCharacterPoints(cache, set_values);
                        } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'gear') {
                            setGearPoolLevels(cache, set_values);
                            setGroupCharacterPoints(cache, set_values);
                        } else {
                            setGroupCharacterPoints(cache, set_values);
                        }
                        cache.statsdb.cp.spent =
                            getSpentCharacterPoints(cache);
                        set_values.static_character_points_spent = cache.statsdb.cp.spent;
                        set_values.static_character_points_remaining =
                            cache.statsdb.cp.base +
                            cache.statsdb.cp.gained +
                            cache.statsdb.cp.temp -
                            cache.statsdb.cp.spent;
                    break;
                    case 'write_stat':
                        if (query.type === 'group') {
                            cache.groupdb[cache.static_group_visible_id].stat = query.stat;
                            set_values.static_attribute_group_stat = query.stat.capitalize();
                        } else {
                            cache.attrdb[query.attribute][query.index].stat = query.stat;
                            set_values[`${cache.source_path}_stat`] = query.stat.capitalize();
                        }
                    break;
                    case 'write_customizations':
                        if (query.type === 'group') {
                            if (query.customization[2] === -1 && query.rank !== 0) {
                                cache.groupdb[cache.static_group_visible_id][cache.source_attribute].push({
                                    name: query.customization[0],
                                    rank: query.rank
                                });
                            } else if (query.customization[2] !== -1 && query.rank !== 0) {
                                cache.groupdb[cache.static_group_visible_id][cache.source_attribute][query.customization[2]].rank = 
                                    query.rank;
                            } else if (query.customization[2] !== -1 && query.rank === 0) {
                                cache.groupdb[cache.static_group_visible_id][cache.source_attribute].splice(query.customization[2], 1);
                            } else {
                                return;
                            }
                            const enhancement_ranks =
                                cache.groupdb[cache.static_group_visible_id].enhancements.map(c => c.rank).reduce((a, b) => a + b, 0);
                            const limiter_ranks =
                                cache.groupdb[cache.static_group_visible_id].limiters.map(c => c.rank).reduce((a, b) => a + b, 0);
                            cache.groupdb[cache.static_group_visible_id].elevel = 
                                cache.groupdb[cache.static_group_visible_id].level + limiter_ranks - enhancement_ranks;
                            set_values.static_attribute_group_level = 
                                `${cache.groupdb[cache.static_group_visible_id].level} ` +
                                `(${cache.groupdb[cache.static_group_visible_id].elevel})`;
                            set_values[cache.source] = 
                                cache.groupdb[cache.static_group_visible_id][cache.source_attribute].map(c => 
                                    `${c.name.capitalize()} (${c.rank})`
                                ).sort().join("\n");
                            if (cache.groupdb[cache.static_group_visible_id].group_type === 'power flux') {
                                setPowerFluxPoolPoints(cache, set_values);
                            } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'power variation') {
                                setPowerVariationGroupPoints(cache, set_values);
                                setPowerVariationPoolPoints(cache, set_values);
                            } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'dynamic powers') {
                                setDynamicPowersPoolLevels(cache, set_values);
                            }
                        } else {//=> setup Attribute customizations here.
                            if (query.customization[2] === -1) {//=> add customization
                                cache.attrdb[query.attribute][query.index][cache.source_attribute].push({
                                    name: query.customization[0],
                                    rank: !query.has_rank ? customization_ranks[`${query.attribute}`][`${query.customization[0]}`].rank : query.rank,
                                });
                                const configuration = getConfigurationByCustomization(cache, query);
                                if (configuration) {
                                    cache.attrdb[query.attribute][query.index].config.push({
                                        name: configuration,
                                        rank:
                                            query.attribute === 'capacity' ? 'carry' :
                                            configuration === 'complete_resilience' ? [] :
                                            ''
                                        ,
                                    });
                                }
                                if (query.attribute === 'unaffected') {
                                    query.config_index = query.db.config.findIndex(c => c.name === 'unaffected');
                                    const has_weapon = query.db.config[query.config_index].rank.findIndex(a => a.name === 'weapon' || a.name === 'all weapons');
                                    if (query.customization[0] === 'all attributes') {
                                        const attributes = [];
                                        if (has_weapon !== -1) {
                                            attributes.push(query.db.config[query.config_index].rank[has_weapon]);
                                        }
                                        attributes.push({name:'all attributes'});
                                        query.db.config[query.config_index].rank = [...attributes];
                                    }
                                    if (query.customization[0] === 'all weapons') {
                                        if (has_weapon !== -1) {
                                            query.db.config[query.config_index].rank.splice(has_weapon, 1);
                                        }
                                        query.db.config[query.config_index].rank.push({name:'all weapons'});
                                    }
                                }
                            } else {//=> remove customization or update rank
                                query.rank = query.has_rank ? query.rank : 0;
                                if (query.rank === 0) {
                                    const configuration = getConfigurationByCustomization(cache, query);
                                    if (configuration) {
                                        const config_index = 
                                            cache.attrdb[query.attribute][query.index].config.findIndex(c => c.name === configuration);
                                        cache.attrdb[query.attribute][query.index].config.splice(config_index, 1);
                                    }
                                    cache.attrdb[query.attribute][query.index][cache.source_attribute].splice(query.customization[2], 1);
                                } else {
                                    cache.attrdb[query.attribute][query.index][cache.source_attribute][query.customization[2]].rank = query.rank;
                                }
                                if (query.attribute === 'unaffected') {
                                    query.config_index = query.db.config.findIndex(c => c.name === 'unaffected');
                                    const has_weapon = query.db.config[query.config_index].rank.findIndex(a => a.name === 'weapon');
                                    if (query.customization[0] === 'all attributes') {
                                        const attributes_index = query.db.config[query.config_index].rank.findIndex(u => u.name === 'all attributes');
                                        query.db.config[query.config_index].rank.splice(attributes_index, 1);
                                    }
                                    if (query.customization[0] === 'all weapons') {
                                        const weapons_index = query.db.config[query.config_index].rank.findIndex(u => u.name === 'all weapons');
                                        query.db.config[query.config_index].rank.splice(weapons_index, 1);
                                    }
                                }
                            }
                            const enhancement_ranks =
                                cache.attrdb[query.attribute][query.index].enhancements.map(c => c.rank).reduce((a, b) => a + b, 0);
                            const limiter_ranks =
                                cache.attrdb[query.attribute][query.index].limiters.map(c => c.rank).reduce((a, b) => a + b, 0);
                            cache.attrdb[query.attribute][query.index].elevel = 
                                cache.attrdb[query.attribute][query.index].level + limiter_ranks - enhancement_ranks;
                            set_values[`${cache.source_path}_level`] = 
                                `${cache.attrdb[query.attribute][query.index].level} ` +
                                `(${cache.attrdb[query.attribute][query.index].elevel})`;
                            set_values[cache.source] = 
                                cache.attrdb[query.attribute][query.index][cache.source_attribute].map(c => 
                                    `${c.name.capitalize()} (${c.rank})`
                                ).sort().join("\n");
                            query.elevel = cache.attrdb[query.attribute][query.index].elevel;
                            set_values[`${cache.source_path}_configuration`] = await setConfiguration(cache, set_values, query);
                        }
                    break;
                    case 'write_movement':
                        if (query.has_movement === -1 && query.rank !== 0) {
                            cache.attrdb[query.attribute][query.index].config[query.movement_index].rank.push(
                                {
                                    name: query.movement,
                                    rank: query.rank
                                }
                            );
                        } else if (
                            query.has_movement !== -1 &&
                            ((query.has_rank && query.rank === 0) || !query.has_rank)
                        ) {
                            cache.attrdb[query.attribute][query.index].config[query.movement_index].rank.splice(query.has_movement, 1);
                        } else if (query.has_movement !== -1 && query.has_rank && query.rank !== 0) {
                            cache.attrdb[query.attribute][query.index].config[query.movement_index].rank[query.has_movement].rank = query.rank;
                        } else {
                            return;
                        }
                        const config_movements = cache.attrdb[query.attribute][query.index].config[query.movement_index].rank.map(m => `${m.name.capitalize()} (${m.rank})`).sort().join(", ");
                        set_values[cache.source] = `${query.load[0].capitalize()} (${config_movements})`;
                    break;
                    case 'write_technique':
                        if (query.has_technique === -1 && query.rank !== 0) {
                            cache.attrdb[query.attribute][query.index].config[query.technique_index].rank.push(
                                {
                                    name: query.technique,
                                    rank: query.rank
                                }
                            );
                        } else if (
                            query.has_technique !== -1 &&
                            ((query.has_rank && query.rank === 0) || !query.has_rank)
                        ) {
                            cache.attrdb[query.attribute][query.index].config[query.technique_index].rank.splice(query.has_technique, 1);
                        } else if (query.has_technique !== -1 && query.has_rank && query.rank !== 0) {
                            cache.attrdb[query.attribute][query.index].config[query.technique_index].rank[query.has_technique].rank = query.rank;
                        } else {
                            return;
                        }
                        const config_techniques = cache.attrdb[query.attribute][query.index].config[query.technique_index].rank.map(t => `${t.name.capitalize()} (${t.rank})`).sort().join(", ");
                        set_values[cache.source] = `${query.load[0].capitalize()} (${config_techniques})`;
                    break;
                    case 'write_newgroup':
                        const groupdb_entry = Object.assign({}, new_group_template);
                        groupdb_entry.group_id = cache.groupdb.length;
                        groupdb_entry.name = `${getTranslationByKey("group")} ${groupdb_entry.group_id}`;
                        cache.groupdb.push(groupdb_entry);
                        cache.static_group_visible_id = groupdb_entry.group_id;
                        showDynamicGroupFields(cache, set_values);
                        setAttributeGroupVisibility(cache, set_values);
                        set_values.static_group_visible_id = groupdb_entry.group_id;
                    break;
                    case 'removed_group':
                        cache.static_group_visible_id = 0;
                        showDynamicGroupFields(cache, set_values);
                        setAttributeGroupVisibility(cache, set_values);
                        if (cache.groupdb[cache.static_group_visible_id].group_type === 'power flux') {
                            cache.statsdb.cp.spent = cache.groupdb.map((g, i) => 
                                i !== cache.static_group_visible_id ? g.group_points : 0
                            ).reduce((m, n) => m + n, 0);
                        }
                        set_values.static_group_visible_id = cache.static_group_visible_id;
                    break;
                }
            }
        }
    }

    async function journalMenu(cache, set_values) {
        const query = {} ;
        clog(cache, query, 'journalMenu()');
        query.next = cache.source;//'select_task';
        cache.static_journal_visible_id = int(cache.static_journal_visible_id);
        query.commit = false;
        while (!query.commit) {
            switch (query.next) {
                // Journal Menu Options
                case 'select_task':
                    query.length = cache.journaldb.length;
                    query.title = `${getTranslationByKey("choose-task")}`;
                    query.options = 
                        `|${getTranslationByKey("add")},add` +
                        `|${getTranslationByKey("edit")},edit`;
                    query.options += query.length !== 1 ? 
                        `|${getTranslationByKey("remove")},remove` : '';
                    query.last = query.next;
                break;
                case 'select_type':
                case 'static_journal_add_button':
                case 'static_journal_delete_button':
                    query.title = cache.source_id === 'add' ? 
                        `${getTranslationByKey("add")}` : `${getTranslationByKey("remove")}`;
                    query.options = 
                        `|${getTranslationByKey("journal")},journal` +
                        `|${getTranslationByKey("page")},page` +
                        `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'edit_journal':
                    query.title = 'Select Journal to Rename';
                    query.options = '';
                    for (i = 0, n = cache.journaldb.length; i < n; i++) {
                        query.options += `|${cache.journaldb[i].name},${i}`;
                    }
                    query.options += `|${getTranslationByKey("go-back")},select_task`;
                    query.last = query.next;
                break;
                case 'remove_confirm':
                    query.title = getTranslationByKey(`confirm-remove-${query.selection}`);
                    query.options = 
                        `|${getTranslationByKey("no")},exit` +
                        `|${getTranslationByKey("yes")},${cache.source_id}_${query.selection}`;
                    query.last = query.next;
                break;
                case 'rename_journal':
                case 'static_journal_title_name':
                    query.title = `${getTranslationByKey("enter-new-title")}`;
                    query.options = '';
                    query.last = query.next;
                break;
                default:
                    query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.last) {
                    case 'select_task':
                        query.task = query.selection;
                        query.next = query.selection === 'edit' ?
                            'edit_journal' : 'select_type';
                    break;
                    case 'select_type':
                    case 'static_journal_add_button':
                    case 'static_journal_delete_button':
                        if (query.selection === 'exit') {
                            query.next = 'exit';
                            query.commit = true;
                        } else {
                            query.task = `${cache.source_id}_${query.selection}`;
                            query.next = cache.source_id === 'delete' ?
                                'remove_confirm' : `${cache.source_id}_${query.selection}`;
                        }
                    break;
                    case 'edit_journal':
                        query.journal_id = query.selection;
                        query.next = 'rename_journal';
                    break;
                    case 'remove_confirm':
                        query.next = query.selection;
                    break;
                    case 'rename_journal':
                    case 'static_journal_title_name':
                        cache.journaldb[cache.static_journal_visible_id].name = query.selection;
                        set_values.static_journal_title_name = query.selection;
                        query.commit = true;
                    break;
                }
            } else {
                switch(query.next) {
                    case 'add_journal':
                        const new_journal = {
                            entries: [''],
                            last_index: 0,
                            name: '',
                            removed: false,
                        };
                        query.index = cache.journaldb.push(new_journal) - 1;
                        cache.journaldb[query.index].name = `Journal Entry ${cache.journaldb.length}`;
                        set_values.static_journal_visible_id = query.index;
                        set_values.static_journal_page_entry = '';
                        set_values.static_journal_page_number = '1';
                        set_values.static_journal_title_name = cache.journaldb[query.index].name;
                    break;
                    case 'add_page':
                        const save = await getAttrsAsync([
                            'static_journal_page_entry',
                            'static_journal_page_number'
                        ]);
                        // Get the current page number (-1 to get index)
                        const current_page = int(save.static_journal_page_number);
                        
                        // Save the current journal entry to the correct index
                        cache.journaldb[cache.static_journal_visible_id].entries[current_page - 1] = 
                            save.static_journal_page_entry;
                        // Create new journal entry
                        cache.journaldb[cache.static_journal_visible_id].entries.push('');
                        set_values.static_journal_page_number =
                            cache.journaldb[cache.static_journal_visible_id].entries.length;
                        set_values.static_journal_page_entry = '';
                    break;
                    case 'delete_journal':
                        if (cache.journaldb[cache.static_journal_visible_id].length === 0) {
                            clog(cache, 'Cannot remove the last journal.', 'ERROR');
                            return;
                        } else {
                            // Remove the current journal
                            cache.journaldb.splice(cache.static_journal_visible_id, 1);
                            query.new_journal_index = cache.journaldb.length - 1;
                            query.new_entry_index = cache.journaldb[query.new_journal_index].last_index;
                            set_values.static_journal_title_name = cache.journaldb[query.new_journal_index].name;
                            set_values.static_journal_page_entry = cache.journaldb[query.new_journal_index].entries[query.new_entry_index];
                            set_values.static_journal_page_number = query.new_entry_index + 1;
                            set_values.static_journal_visible_id = query.new_journal_index;
                        }
                    break;
                    case 'delete_page':
                        if (cache.journaldb[cache.static_journal_visible_id].entries.length === 0) {
                            clog(cache, 'Cannot remove last page in a journal. Remove the journal instead.', 'ERROR');
                            return;
                        } else {
                            // Remove the current page of the journal
                            cache.journaldb[cache.static_journal_visible_id].entries.splice(cache.static_journal_page_number - 1, 1);
                            cache.journaldb[cache.static_journal_visible_id].last_index = cache.journaldb[cache.static_journal_visible_id].entries.length - 1;
                            set_values.static_journal_page_number = cache.journaldb[cache.static_journal_visible_id].entries.length;
                            set_values.static_journal_page_entry = cache.journaldb[cache.static_journal_visible_id].entries[cache.journaldb[cache.static_journal_visible_id].entries.length - 1] || "";
                        }
                    break;
                }
            }
        }            
    }

    async function journalSavePage(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'journalSavePage()');
        temp.journal_index = int(cache.static_journal_visible_id);
        temp.page_index = int(cache.static_journal_page_number) - 1;
        cache.journaldb[temp.journal_index].entries[temp.page_index] =
            cache.static_journal_page_entry;
        set_values.journaldb = cache.journaldb;
    }

    async function journalSelectMenu(cache, set_values) {
        cache.static_journal_visible_id = int(cache.static_journal_visible_id);
        cache.static_journal_page_number = int(cache.static_journal_page_number);
        const query = {};
        clog(cache, query, 'journalSelectMenu()');
        query.next = cache.source;//'select_menu';
        query.commit = false;
        query.db_length = cache.journaldb.length;
        while (!query.commit) {
            switch (query.next) {
                case 'select_menu':
                    query.title = getTranslationByKey("choose");
                    query.options = 
                        `|> Next Page,next_page` +
                        `|< Previous Page,previous_page` +
                        `|>> Next Journal,next_journal` +
                        `|<< Previous Journal,previous_journal` +
                        `|Jump to Journal,jump_journal` +
                        `|Jump to Page,jump_page`;
                    query.last = query.next;
                break;
                case 'select_journal':
                case 'static_journal_select_button':
                    query.title = getTranslationByKey("journal");
                    query.options = '';
                    const options = [];
                    for (let i = 0; i < query.db_length; i++) {
                        options.push(`${cache.journaldb[i].name},${i}`);
                    }
                    query.options = "|" + options.sort().join("|") + `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'select_page':
                case 'static_journal_page_number':
                    query.title = getTranslationByKey("page");
                    query.options = '';
                    for (let i = 0; i < cache.journaldb[cache.static_journal_visible_id].entries.length; i++) {
                        query.options += `|${i + 1},${i}`;
                    }
                    query.options += `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                default: query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.next) {
                    case 'select_menu':
                        const selection = query.selection.split('_');
                        query.task = selection[0];// next, previous, jump
                        query.type = selection[1];// journal, page
                        query.next = 
                            `${query.task === 'jump' ? 'select' : 'set'}_${query.type}`;
                    break;
                    case 'select_journal':
                    case 'select_page':
                    case 'static_journal_page_number':
                    case 'static_journal_select_button':
                        if (query.selection === 'exit') {
                            query.next = 'exit';
                            return;
                        }
                        query.id = query.selection;
                        query.next = cache.source === 'static_journal_page_number' ?
                            'set_page': 'set_journal';
                    break;
                }
            } else {
                switch (query.next) {
                    case 'set_journal':
                        query.new_journal = cache.journaldb[query.id];
                        query.save_index = cache.static_journal_page_number - 1;
                        query.save_journal = cache.journaldb[cache.static_journal_visible_id];
                        query.save_journal.entries[query.save_index] = cache.static_journal_page_entry;
                        query.save_journal.last_index = query.save_index;
                        set_values.static_journal_title_name = query.new_journal.name;
                        set_values.static_journal_page_entry = query.new_journal.entries[query.new_journal.last_index];
                        set_values.static_journal_page_number = query.new_journal.last_index + 1;
                        set_values.static_journal_visible_id = query.id;
                    break;
                    case 'set_page':
                        query.new_page_number = query.id + 1;
                        query.save_index = cache.static_journal_page_number - 1;
                        query.journal = cache.journaldb[cache.static_journal_visible_id];
                        query.journal.entries[query.save_index] = cache.static_journal_page_entry;
                        query.journal.last_index = query.save_index;
                        set_values.static_journal_page_entry = query.journal.entries[query.id];
                        set_values.static_journal_page_number = query.new_page_number;
                    break;
                }
            }
        }
    }

    async function groupSelectMenu(cache, set_values) {
        const query = {};
        clog(cache, query, 'groupSelectMenu()');
        query.next = 'select_group';
        query.commit = false;
        if (cache.groupdb[cache.static_group_visible_id].group_type !== 'standard') {
            cache.groupdb[cache.static_group_visible_id].description =
            cache.static_attribute_group_configuration;
        }
        while (!query.commit) {
            switch (query.next) {
                case 'select_group':
                    query.group_names = cache.groupdb.map((g, i) => {
                        const name = g.name || `Group ${i}`;
                        return name;
                    });
                    query.title = getTranslationByKey("switch-to-group");
                    const options = [];
                    for (let i = 0, n = query.group_names.length; i < n; i++) {
                        if (!cache.groupdb[i].removed) {
                            options.push(`${query.group_names[i]},${i}`);
                        }
                    }
                    query.options = '|' + options.sort().join("|") + '|Exit,done';
                    query.last = query.next;
                break;
                // Break out of while loop when there is no query.next step
                default:
                    query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.next) {
                    case 'select_group':
                        cache.static_group_visible_id = int(query.selection);    
                        showDynamicGroupFields(cache, set_values);
                        setAttributeGroupVisibility(cache, set_values);
                        query.next = 'done';
                    break;
                }
            }
        }
        set_values.static_group_visible_id = cache.static_group_visible_id;
    }

    async function skillsUiSelectMenu(cache, set_values) {
        const query = {};
        clog(cache, query, 'skillsUiSelectMenu()');
        query.next = 'select_skillsui';
        query.commit = false;
        while (!query.commit) {
            switch (query.next) {
                case 'select_skillsui':
                    query.skillsui_names = cache.attrdb.skills.map((s, i) => s.name || `Group ${i}`);
                    query.title = getTranslationByKey("switch-to-group");
                    query.options = query.skillsui_names.map(((n, i) => `|${n},${i}`)).join('');
                    query.options += '|Exit,done';
                    query.last = query.next;
                break;
                // Break out of while loop when there is no query.next step
                default:
                    query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.next) {
                    case 'select_skillsui':
                        cache.static_skills_visible_id = int(query.selection);
                        setSkillUiVisibility(cache, set_values);
                        query.next = 'done';
                    break;
                }
            }
        }
        set_values.static_skills_visible_id = cache.static_skills_visible_id;
    }

    async function groupToggleMenu(cache, set_values) {
        const query = {};
        clog(cache, query, 'groupToggleMenu()');
        query.next = 'select_operation';
        query.commit = false;
        while (!query.commit) {
            switch (query.next) {
                case 'select_operation':
                    query.title = 'Select Operation';
                    query.options = 
                        '|Enable All,enable' +
                        '|Disable All,disable';
                break;
                default:
                    query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.next) {
                    case 'select_operation':
                        query.state = query.selection === 'enable' ? true : false;
                        const index = cache.static_group_visible_id;
                        cache.attribute = [];
                        for (let i = 0; i < cache.groupdb[index].attribute_ids.length; i++) {
                            const row_id = cache.groupdb[index].attribute_ids[i];
                            for (let j = 0; j < all_attributes.length; j++) {
                                for (let h = 0; h < cache.attrdb[all_attributes[j]].length; h++) {
                                    const check_id = cache.attrdb[all_attributes[j]][h].row_id;
                                    if (check_id === row_id) {
                                        cache.attrdb[all_attributes[j]][h].active = query.state;
                                        cache.attribute.push(all_attributes[j]);
                                        set_values[`repeating_attribute_${row_id.toLowerCase()}_active`] =
                                            query.state === true ? 1 : 0;
                                    }
                                }
                            }
                        }
                        cache.defect = [];
                        for (let i = 0; i < cache.groupdb[index].defect_ids.length; i++) {
                            const row_id = cache.groupdb[index].defect_ids[i];
                            for (let j = 0; j < all_defects.length; j++) {
                                for (let h = 0; h < cache.defectdb[all_defects[j]].length; h++) {
                                    const check_id = cache.defectdb[all_defects[j]][h].row_id;
                                    if (check_id === row_id) {
                                        cache.defectdb[all_defects[j]][h].active = query.state;
                                        cache.defect.push(all_defects[j]);
                                        set_values[`repeating_defect_${row_id.toLowerCase()}_active`] =
                                            query.state === true ? 1 : 0;
                                    }
                                }
                            }
                        }
                        query.next = 'done';
                    break;
                }
            }
        }
    }

    async function skillsUiToggleMenu(cache, set_values) {
        const query = {};
        clog(cache, query, 'skillsUiToggleMenu()');
        query.next = 'select_operation';
        query.commit = false;
        while (!query.commit) {
            switch (query.next) {
                case 'select_operation':
                    query.title = 'Select Operation';
                    query.options = 
                        '|Enable All,enable' +
                        '|Disable All,disable';
                break;
                default:
                    query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.next) {
                    case 'select_operation':
                        query.state = query.selection === 'enable' ? true : false;
                        for (let i = 0; i < cache.attrdb.skills[cache.static_skills_visible_id].individual.length; i++) {
                            const row_id = cache.attrdb.skills[cache.static_skills_visible_id].individual[i].row_id;
                            cache.attrdb.skills[cache.static_skills_visible_id].individual[i].active = query.state;
                            set_values[`repeating_skill_${row_id.toLowerCase()}_active`] = query.state === true ? 1 : 0;
                        }
                        query.next = 'done';
                    break;
                }
            }
        }
    }

    async function setStat(cache, query, set_values) {
        // external variables required in query object:
        // .stat = body, mind, or soul,
        // .point_type = base, temp, or damage,
        // .point_method = add, remove, or set,
        // .answer = a positive integer.
        const stats = ['body', 'mind', 'soul'];
        const stats_points = ['base', 'temp', 'damage'];
        const temp = {};
        clog(cache, temp, 'setStat()');
        // Set external values from query to temp.
        Object.assign(temp, query);
        if (temp.stat === undefined) {
            temp.stat = query.load[2];
        }
        // Load values from statsdb to temp.
        for (let i = 0; i < stats.length; i++) {
            temp[stats_points[i]] = int(cache.statsdb[`${temp.stat}`][stats_points[i]]);
        }
        // Adjust Character Points if stat base changes
        temp.answer = int(temp.answer);
        for (let i = 0; i < stats_points.length; i++) {
            cache.statsdb[temp.stat][stats_points[i]] =
                stats_points[i] === cache.source_attribute ?
                temp.answer : temp[stats_points[i]];
        }
        cache.statsdb.cp.spent = getSpentCharacterPoints(cache);
        
        if (temp.point_method === 'add') {
            temp[temp.point_type] += temp.answer;
        } else if (temp.point_method === 'remove') {
            temp[temp.point_type] -= temp.answer;
        } else { // temp.point_method === 'set'
            temp[temp.point_type] = temp.answer;
        }
        temp[temp.point_type] = Math.max(temp[temp.point_type], 0);
        set_values[`static_character_${temp.stat}_remaining`] =
            temp.base + (cache.statsdb[temp.stat].augmented || 0) + temp.temp - temp.damage - 
            (cache.statsdb[temp.stat].shortcoming || 0);
        if (temp.point_type === 'base') {
            temp.cp_spent =
                getSpentCharacterPoints(cache);
            set_values.static_character_points_spent = temp.cp_spent;
            set_values.static_character_points_remaining =
                cache.statsdb.cp.base +
                cache.statsdb.cp.gained +
                cache.statsdb.cp.temp -
                temp.cp_spent;
        }
        for (let i = 0; i < 9; i++) {
            let stat_index = Math.floor(i / 3);
            let point_index = i % 3;
            set_values[`static_character_${stats[stat_index]}_${stats_points[point_index]}`] = (
                stat_index === stats.indexOf(temp.stat) &&
                point_index === stats_points.indexOf(temp.point_type)
            ) ?
                temp[temp.point_type] :
                int(cache.statsdb[stats[stat_index]][stats_points[point_index]]);
        }
        set_values = _.compact(set_values);
        cache.stat = temp.stat;
        cache.point_type = temp.point_type;
    }

    async function setDerivedValues(cache, set_values) {
        const derived_values = [
            'acv',
            'dcv',
            'scv',
            'shockvalue',
        ];
        const derived_values_points = [
            'energy',
            'health',
            'sanity',
            'society',
        ];
        const derived_attributes = {
            'acv':'attack mastery',
            'dcv':'defense mastery',
            'scv':'social mastery',
            'shockvalue':'hardboiled',
            'energy':'energized',
            'health':'tough',
            'sanity':'unassailable',
        };
        const defects = {
            'acv':'inept attack',
            'dcv':'inept defense',
            'dm':'reduced damage',
            'scv':'demure',
            'health':'fragile',
            'sanity':'unsettled'
        };
        for (let i = 0; i < derived_values_points.length; i++) {
            derived_values.push(derived_values_points[i]);
        }
        clog(cache, '', `setDerivedValues()`);
        if (cache.rulesdb === undefined) {
            const rulesdb = await crpGet(cache, 'rulesdb');
            cache.rulesdb = JSON.parse(rulesdb);
        }
        for (let i = 0; i < all_stats.length; i++) {
            cache[all_stats[i]] = 
            cache.statsdb[all_stats[i]].base +
            (cache.statsdb[all_stats[i]].augmented || 0) +
            cache.statsdb[all_stats[i]].temp -
            cache.statsdb[all_stats[i]].damage -
            (cache.statsdb[all_stats[i]].shortcoming || 0);
        }
        cache.energy = (cache.mind + cache.soul) * 5;
        cache.health = ((cache.body + cache.soul) * 5);
        cache.sanity = (cache.mind + cache.soul) * int(cache.rulesdb.rules_optional_sanity_status);
        cache.society = Math.round((cache.mind + cache.soul) / 2) * int(cache.rulesdb.rules_optional_society_status);
        cache.shockvalue = (cache.body + cache.soul) * int(cache.rulesdb.rules_optional_shockvalue_status);
        // Calculate base combat values
        cache.acv = Math.round((cache.body + cache.mind + cache.soul) / 3);
        cache.dcv = Math.round((cache.body + cache.mind + cache.soul) / 3);
        cache.scv = Math.round((cache.mind + cache.soul) / 2) * int(cache.rulesdb.rules_optional_society_status);
        cache.dm = 5;
        cache.actions = 1;
        cache.defenses = 0;
        cache.hardboiled = 0;
        // Apply defects
        // Apply attributes to combat values
        await setActiveAttribute(cache, set_values);
        // Record new values
        cache.elevel = cache.attribute === undefined || cache.attribute !== 'swarm' ? 0 :
            cache.attrdb[cache.attribute][cache.attrdb[cache.attribute].findIndex(s => s.row_id.toLowerCase() === cache.source_id)].elevel;
        for (let i = 0; i < derived_values.length; i++) {
            if (derived_values_points.indexOf(derived_values[i]) !== -1) {
                cache.swarm_multiplier = 1;
                if (cache.attribute === 'swarm' && derived_values[i] === 'health') {
                    cache.swarm_multiplier = cache.active ? cache.elevel : 1;
                    if (cache.active) {
                        cache.statsdb[derived_values[i]].damage *= cache.elevel;
                    } else {
                        Math.ceil(cache.statsdb[derived_values[i]].damage /= cache.elevel);
                    }
                    
                }
                cache.statsdb[derived_values[i]].base = cache[derived_values[i]] * (derived_values[i] === 'health' ? cache.swarm_multiplier : 1);
                set_values[`static_character_${derived_values[i]}_base`] = cache.statsdb[derived_values[i]].base;
                const point_max = 
                    cache.statsdb[derived_values[i]].base +
                    (cache.statsdb[derived_values[i]].augmented || 0) +
                    cache.statsdb[derived_values[i]].temp -
                    (cache.statsdb[derived_values[i]].shortcoming || 0);
                const point_loss = 
                    cache.statsdb[derived_values[i]].damage +
                    (cache.statsdb[derived_values[i]].stun || 0);
                setStatusStateDescription(cache, set_values, derived_values[i], point_max, point_loss);
            } else {
                if (cache.attribute === 'swarm' && cache.active) {
                    switch (derived_values[i]) {
                        case 'acv': cache[derived_values[i]] = 4 + cache.elevel; break;
                        default: cache[derived_values[i]] = 0;
                    }
                }
                cache.statsdb[derived_values[i]].base = cache[derived_values[i]];
                set_values[`static_character_${derived_values[i]}_base`] = cache[derived_values[i]];
            }
        }
        // Set Movement and Strength Capabilities
        const movements = [
            'walk',
            'jog',
            'run',
            'sprint',
            'swim',
            'sprintswim',
            'jump',
            'leap',
            'runningleap'
        ];
        const movement_ratios = {
            'walk': 1,
            'jog': 1.5,
            'run': 2,
            'sprint': 4,
            'swim': 0.5,
            'sprintswim': 1,
            'jump': 0.125,
            'leap': 0.25,
            'runningleap': 1
        };
        const strengths = [
            'carry',
            'lift'
        ];
        const strength_ratios = {
            'carry': 12.5,
            'lift': 25
        };
        for (let i = 0; i < movements.length; i++) {
            const unit = i > 5 ? 'm' : 'kph';
            const distance = cache.body * movement_ratios[movements[i]];
            const result = distance % 1 === 0 ? distance : Number(distance).toFixed(1);
            set_values[`static_character_capabilities_${movements[i]}`] = 
                `${result} ${unit}`;
        }
        for (let i = 0; i < strengths.length; i++) {
            set_values[`static_character_capabilities_${strengths[i]}`] = 
                `${Math.round(cache.body * strength_ratios[strengths[i]])} kg`;
        }
    }

    function setStatusStateDescription(cache, set_values, point_section, point_max, point_loss) {
        const temp = {};
        clog(cache, temp, `setStatusStateDescription(${point_section})`);
        temp.point_max = point_max;
        temp.point_loss = point_loss;
        temp.status_math = Math.floor((int(point_loss)*10)/int(point_max)) || 0;
        temp.status = temp.status_math > 10 ? 10 : temp.status_math;
        temp.remaining = point_max - point_loss;
        cache.statsdb[point_section].remaining = temp.remaining;
        set_values[`static_character_${point_section}_remaining`] = temp.remaining;
        set_values[`static_character_${point_section}_status`] = 
            getStatusDescription(cache, point_section, temp.status);
        set_values[`static_sheet_${point_section}_state`] = temp.status;
    }

    function setNewAttributeConfiguration(cache, set_values, query) {
        clog(cache, query, 'setNewAttributeConfiguration()');
        if (
            query.attribute === 'absorption' ||
            query.attribute === 'armor' ||
            query.attribute === 'conversion' ||
            query.attribute === 'force field'
        ) {
            if (query.type === 'add') {
                query.config.push({
                    name: `${
                        query.attribute === 'absorption' ? 'absorb' :
                        query.attribute === 'conversion' ? 'convert' :
                            'armor rating'
                    }`,
                    rank: int(`${query.elevel * (
                        query.attribute === 'absorption' ||
                        query.attribute === 'armor' ? 
                            5 :
                        query.attribute === 'conversion' ||
                        query.attribute === 'force field' ? 
                            10 : 0
                    )}`)
                });
            } else if (query.type === 'edit') {
                query.armor_rating = int(`${query.elevel * (
                    query.attribute === 'absorption' ||
                    query.attribute === 'armor' ? 
                        5 :
                    query.attribute === 'conversion' ||
                    query.attribute === 'force field' ? 
                        10 : 0
                )}`);
            }
            
            const ar_index = query.config.findIndex(
                c => c.name === 'armor rating' || c.name === 'absorb' || c.name === 'convert'
            );
            if (ar_index !== -1) {
                query.config[ar_index].rank = query.armor_rating;
            } else {
                query.config.push({
                    name: `${
                        query.attribute === 'absorption' ? 'absorb' :
                        query.attribute === 'conversion' ? 'convert' :
                            'armor rating'
                    }`,
                    rank: query.armor_rating
                });
            }

            if (
                query.attribute === 'absorption' &&
                query.config.findIndex(c => c.name === 'transform') === -1
            ) {
                query.config.push({
                    name: 'transform',
                    rank: query.transform
                });
            }

        } else if (query.attribute === 'ranged defense') {
            query.config.push({
                name: 'defense type',
                rank: query.attribute_type
            })
        } else if (query.attribute === 'skills' && query.type === 'add') {
            query.config.push({
                name: 'skill points',
                rank: query.elevel * 10
            });
        }

        if (
            cache.groupdb[cache.static_group_visible_id].group_type === 'power variation' &&
            cache.groupdb[cache.static_group_visible_id].locked === false
        ) {
            const base_index = query.config.findIndex(c => c.name === 'base points');
            if (base_index === -1) {
                query.config.push({
                    name: 'base points',
                    rank: query.cost * query.level
                });
            } else {
                query.config[base_index].rank = query.cost * query.level;
            }
        }
        if (query.config.length !== 0) {
            query.config.sort();
            for (let i = 0; i < query.config.length; i++) {
                if (query.config[i].name === 'flare') {
                    value += `Flare\n`;
                    for (let j = 0; j < senses.length; j++) {
                        value += query.config[i].senses[j].rank ?
                            `   ${query.config[i].senses[j].name.capitalize()} (` +
                            `${query.config[i].senses[j].rank === 1 ?
                                'minor' : 'major'} obstacle)\n` : '';
                    }
                } else if (query.config[i].name === 'skill points') {
                    query.config[i].rank = query.elevel * 10;
                } else {
                    value += `${query.config[i].name.capitalize()}`;
                    value += `${
                        query.config[i].name === 'absorb' ? ' up to ' :
                        query.config[i].name === 'convert' ? 
                            query.elevel !== 1 ? ' 10 to ' : ' ' :
                        ' ('
                    }`;
                    value += `${
                        isNaN(query.config[i].rank) ?
                        query.config[i].rank.capitalize() : 
                        int(query.config[i].rank)
                    }`;
                    value += `${
                        query.config[i].name === 'absorb' ? ' damage' :
                        query.config[i].name === 'convert' ? ' damage into character points' :
                        ')'
                    }`;
                    value += '\n';
                }
            }
        }
    }

    function updateAttributeConfiguration(cache, query) {
        clog(cache, query, 'setNewAttributeConfiguration()');
        if (
            query.attribute === 'absorption' ||
            query.attribute === 'armor' ||
            query.attribute === 'conversion' ||
            query.attribute === 'force field'
        ) {
            query.armor_rating = int(`${query.elevel * (
                query.attribute === 'absorption' ||
                query.attribute === 'armor' ? 
                    5 :
                query.attribute === 'conversion' ||
                query.attribute === 'force field' ? 
                    10 : 0
            )}`);
            const ar_index = query.config.findIndex(c => {
                return c.name === 'armor rating' || c.name === 'absorb' || c.name === 'convert';
            });
            if (ar_index !== -1) {
                query.config[ar_index].rank = query.armor_rating;
            } else {
                query.config.push({
                    name: `${
                        query.attribute === 'absorption' ? 'absorb' :
                        query.attribute === 'conversion' ? 'convert' :
                            'armor rating'
                    }`,
                    rank: query.armor_rating
                });
            }
            if (
                query.attribute === 'absorption' &&
                query.config.findIndex(c => {
                    return c.name === 'transform'
                }) === -1
            ) {
                query.config.push({
                    name: 'transform',
                    rank: query.transform
                });
            }
        } else if (query.attribute === 'ranged defense') {
            query.config.push({
                name: 'defense type',
                rank: query.attribute_type
            })
        }
        if (
            cache.groupdb[cache.static_group_visible_id].group_type === 'power variation' &&
            cache.groupdb[cache.static_group_visible_id].locked === false
        ) {
            const base_index = query.config.findIndex(c => c.name === 'base points');
            if (base_index === -1) {
                query.config.push({
                    name: 'base points',
                    rank: query.cost * query.level
                });
            } else {
                query.config[base_index].rank = query.cost * query.level;
            }
        }
        if (query.config.length !== 0) {
            query.config.sort();
            for (let i = 0; i < query.config.length; i++) {
                if (query.config[i].name === 'flare') {
                    value += `Flare\n`;
                    for (let j = 0; j < senses.length; j++) {
                        value += query.config[i].senses[j].rank ?
                            `   ${query.config[i].senses[j].name.capitalize()} (` +
                            `${query.config[i].senses[j].rank === 1 ?
                                'minor' : 'major'} obstacle)\n` : '';
                    }
                } else if (query.config[i].name === 'skill points') {
                    query.config[i].rank = query.elevel * 10;
                } else {
                    value += `${query.config[i].name.capitalize()}`;
                    value += `${
                        query.config[i].name === 'absorb' ? ' up to ' :
                        query.config[i].name === 'convert' ? 
                            query.elevel !== 1 ? ' 10 to ' : ' ' :
                        ' ('
                    }`;
                    value += `${
                        isNaN(query.config[i].rank) ?
                        query.config[i].rank.capitalize() : 
                        int(query.config[i].rank)
                    }`;
                    value += `${
                        query.config[i].name === 'absorb' ? ' damage' :
                        query.config[i].name === 'convert' ? ' damage into character points' :
                        ')'
                    }`;
                    value += '\n';
                }
            }
        }
    }

    /* Regsiter event listeners */
    function getEvents() {
        const temp = {};
        clog({},temp,'getEvents()','event');
        // Input names
        temp.change_events = [
            'repeating_attribute:active',
            'repeating_defect:active',
            'repeating_skill:active',
            'rules_optional_criticalfailures_status',
            'rules_optional_criticalhits_status',
            'rules_optional_dice_status',
            'rules_optional_genre_status',
            'rules_optional_variable_status',
            'static_rules_base_default',
            'static_sheet_settings_theme',
        ];
        temp.event_string = `change:${temp.change_events.join(" change:")}`;
        // Button names
        temp.button_events = [
            'react_button_roll_defense',
            'react_button_roll_skill',
            'react_button_roll_stat',
            'repeating_attribute:accordion',
            'repeating_attribute:attribute',
            'repeating_attribute:configuration',
            'repeating_attribute:enhancements',
            'repeating_attribute:level',
            'repeating_attribute:limiters',
            'repeating_attribute:stat',
            'repeating_condition:delete',
            'repeating_defect:accordion',
            'repeating_defect:configuration',
            'repeating_defect:defect',
            'repeating_defect:rank',
            'repeating_roll:accordion',
            'repeating_roll:attribute',
            'repeating_roll:enemy',
            'repeating_roll:maneuver',
            'repeating_roll:modifier',
            'repeating_roll:name',
            'repeating_roll:rollmacro',
            'repeating_roll:stat',
            'repeating_roll:target',
            'repeating_roll:type',
            'repeating_skill:accordion',
            'repeating_skill:rank',
            'repeating_skill:specializations',
            'repeating_skill:stat',
            'rules_attribute_deathdodge_button',
            'rules_attribute_debilitate_button',
            'rules_attribute_eknockback_button',
            'rules_attribute_expertise_button',
            'rules_attribute_extradefenses_button',
            'rules_attribute_flankdefense_button',
            'rules_attribute_hardboiled_button',
            'rules_attribute_miniobject_button',
            'rules_attribute_speedburst_button',
            'rules_attribute_taunt_button',
            'rules_attribute_tournament_button',
            'rules_defect_nohealing_button',
            'rules_enhancement_absorption_button',
            'rules_enhancement_absorption_button',
            'rules_enhancement_cognition_button',
            'rules_enhancement_conversion_button',
            'rules_enhancement_conversion_button',
            'rules_enhancement_forcefield_button',
            'rules_enhancement_powerflux_button',
            'rules_enhancement_sixthsense_button',
            'rules_enhancement_sizechange_button',
            'rules_enhancement_summoncreatures_button',
            'rules_enhancement_teleport_button',
            'rules_enhancement_transfer_button',
            'rules_enhancement_weapon_button',
            'rules_homebrew_ammotracking_button',
            'rules_homebrew_depletereserve_button',
            'rules_homebrew_disperse_button',
            'rules_homebrew_donotconfirm_button',
            'rules_homebrew_specificlimiter_button',
            'rules_limiter_absorption_button',
            'rules_limiter_merge_button',
            'rules_limiter_plantcontrol_button',
            'rules_limiter_powerflux_button',
            'rules_limiter_teleport_button',
            'rules_limiter_timed_button',
            'rules_limiter_transmute_button',
            'rules_optional_enhancedrecovery_button',
            'rules_optional_extradamage_button',
            'rules_optional_individual_button',
            'rules_optional_knockback_button',
            'rules_optional_knockout_button',
            'rules_optional_maneuvers_button',
            'rules_optional_mos_button',
            'rules_optional_movementpenalties_button',
            'rules_optional_rangepenalties_button',
            'rules_optional_sanity_button',
            'rules_optional_seriousinjury_button',
            'rules_optional_shield_button',
            'rules_optional_shockvalue_button',
            'rules_optional_society_button',
            'rules_optional_spreadinitiative_button',
            'static_attribute_group_configuration',
            'static_attribute_group_enhancements',
            'static_attribute_group_item',
            'static_attribute_group_level',
            'static_attribute_group_limiters',
            'static_attribute_group_name',
            'static_attribute_group_source',
            'static_attribute_group_stat',
            'static_attribute_group_type',
            'static_attributes_accordions_button',
            'static_attributes_add_button',
            'static_attributes_delete_button',
            'static_attributes_groupselect_button',
            'static_attributes_grouptoggle_button',
            'static_attributes_lock_button',
            'static_capabilities_accordion_button',
            'static_character_body_base',
            'static_character_body_damage',
            'static_character_body_temp',
            'static_character_details_class',
            'static_character_details_height',
            'static_character_details_pronoun',
            'static_character_details_race',
            'static_character_details_size',
            'static_character_details_weight',
            'static_character_energy_damage',
            'static_character_energy_temp',
            'static_character_health_damage',
            'static_character_health_stun',
            'static_character_health_temp',
            'static_character_mind_base',
            'static_character_mind_damage',
            'static_character_mind_temp',
            'static_character_points_base',
            'static_character_points_gained',
            'static_character_points_temp',
            'static_character_sanity_damage',
            'static_character_sanity_temp',
            'static_character_society_damage',
            'static_character_society_temp',
            'static_character_soul_base',
            'static_character_soul_damage',
            'static_character_soul_temp',
            'static_gmscreen_edit_button',
            'static_journal_accordion_button',
            'static_journal_add_button',
            'static_journal_delete_button',
            'static_journal_page_number',
            'static_journal_save_button',
            'static_journal_select_button',
            'static_journal_title_name',
            'static_roll_2d6_button',
            'static_roll_accordions_button',
            'static_roll_add_button',
            'static_roll_attack_button',
            'static_roll_attribute_button',
            'static_roll_delete_button',
            'static_roll_initiative_button',
            'static_roll_skill_button',
            'static_roll_stat_button',
            'static_rules_accordion_button',
            'static_screen_accordion_button',
            'static_screen_edit_button',
            'static_screen_help_button',
            'static_screen_rolls_button',
            'static_sheet_settings_gm',
            'static_sheet_settings_player',
            'static_sheet_settings_theme',
            'static_sheet_settings_type',
            'static_skills_accordions_button',
            'static_skills_add_button',
            'static_skills_delete_button',
            'static_skills_uiselect_button',
            'static_skills_uitoggle_button',
            'static_stats_accordion_button',
            'static_stats_edit_button',
            'static_status_accordion_button',
            'static_status_add_button',
            'static_status_delete_button',
            'static_status_update_button',
        ];
        temp.event_string += ` clicked:${temp.button_events.join(" clicked:")}`;
        // Repeating sections
        temp.removed_events = [
            'repeating_attr',
            'repeating_defect',
            'repeating_roll'
        ];
        temp.event_string += ` remove:${temp.removed_events.join(" remove:")}`;
        return temp.event_string;
    }

    /* Event Listeners */
    on("sheet:opened", async (eventInfo) => {
        const cache = {}; // contains all sheet values, is updated on value changes.
        const set_values = {}; // contains changes to sheet values for setAttr().
        let getAttrsArray = [
            "character_default_value_points",
            "character_name",
            "groupdb",
            "static_group_visible_id",
            "static_sheet_settings_debug",// read each time sheetworker runs
            "static_sheet_settings_gm",// need static_rules_base_default
            "static_sheet_settings_initialized",// read on open only
            "static_sheet_settings_player",// need
            "static_sheet_settings_rules",// read each time sheetworker runs
            "static_sheet_settings_theme",// need
            "static_sheet_settings_type",
            "static_sheet_settings_version",// only needed on open
            "static_rules_base_default"
        ];
        const status_sections = ['energy','health','sanity','society'];
        for (let i = 0, n = status_sections.length; i < n; i++) {
            getAttrsArray = getAttrsArray.concat([
                `static_character_${status_sections[i]}_remaining`,
                `static_character_${status_sections[i]}_base`
            ]);
        }
        setTimer(cache);
        clog(cache, '', 'Sheet Open', 'start');
        clog(cache, cache, 'cache');
        clog(cache, eventInfo, 'eventInfo');
        cache.is_sheetopened = true;
        const values = await getAttrsAsync(getAttrsArray);
        Object.assign(cache, values);
        // Setup sheet theme and rules base logo
        initializeTheme(cache);
        initializeStatusBars(cache, status_sections);
        await setSheetLogo(cache);
        if (
            cache.static_sheet_settings_type !== 'GM' && 
            cache.static_sheet_settings_gm !== ''
        ) {
            cache.rulebook = await crpGet(cache, 'static_rules_base_default') || 'besm';
            cache.rulesdb = await crpGet(cache, 'rulesdb');
            if (cache.rulesdb === `${cache.static_sheet_settings_gm}|rulesdb`) {
                clog(cache, 'GM missing! Please create GM sheet.','ERROR');
            } else {
                cache.rulesdb = JSON.parse(cache.rulesdb);
                updateSheetRulesSummary(cache, set_values);
                set_values.static_skills_show_state = 
                    cache.rulesdb.rules_optional_individual_status === 1 ? 1 : 0;
            }
        }
        if (cache.static_sheet_settings_initialized !== 1) {
            // Create databases
            // Attributes database
            const attrdb = createDatabase(cache, all_attributes);
            set_values.attrdb = JSON.stringify(attrdb);
            // Conditions database
            const conditiondb = createDatabase(cache, all_conditions);
            set_values.conditiondb = JSON.stringify(conditiondb);
            // Defects database
            const defectdb = createDatabase(cache, all_defects);
            set_values.defectdb = JSON.stringify(defectdb);
            // Groups database
            const groupdb = [];
            groupdb.push(new_group_template);
            const journaldb = [
                {
                    entries: [],
                    journal_id: 0,
                    last_index: 0,
                    name: 'Default Journal Entry',
                    removed: false,
                },
            ];
            const statsdb = {actions:{base:1,extra:0},acv:{base:0,mastery:0},body:{base:0,damage:0,temp:0,augmented:0},dcv:{base:0,mastery:0},defenses:{base:0,extra:0},dm:{base:5,massive:0},mind:{base:0,damage:0,temp:0,augmented:0},scv:{base:0,mastery:0},shockvalue:{base:0,hardboiled:0},soul:{base:0,damage:0,temp:0,augmented:0},energy:{base:0,damage:0,temp:0,energized:0},health:{base:0,damage:0,stun:0,temp:0,tough:0},sanity:{base:0,damage:0,temp:0,unassailable:0},society:{base:0,damage:0,temp:0,mastery:0},cp:{base:int(cache.character_default_value_points, 0),gained:0,spent:0,temp:0}};
            /*{
                actions:{
                    base:1,
                    extra:0
                },
                acv:{
                    base:0,
                    mastery:0
                },
                body:{
                    base:0,
                    damage:0,
                    temp:0,
                    augmented:0
                },
                dcv:{
                    base:0,
                    mastery:0
                },
                defenses:{
                    base:0,
                    extra:0
                },
                dm:{
                    base:5,
                    massive:0
                },
                mind:{
                    base:0,
                    damage:0,
                    temp:0,
                    augmented:0
                },
                scv:{
                    base:0,
                    mastery:0
                },
                shockvalue:{
                    base:0,
                    hardboiled:0
                },
                soul:{
                    base:0,
                    damage:0,
                    temp:0,
                    augmented:0
                },
                energy:{
                    base:0,
                    damage:0,
                    temp:0,
                    energized:0
                },
                health:{
                    base:0,
                    damage:0,
                    stun:0,
                    temp:0,
                    tough:0
                },
                sanity:{
                    base:0,
                    damage:0,
                    temp:0,
                    unassailable:0
                },
                society:{
                    base:0,
                    damage:0,
                    temp:0,
                    mastery:0
                },
                cp:{
                    base: int(cache.character_default_value_points, 0),
                    gained:0,
                    spent:0,
                    temp:0
                }
            };*/
            const rolldb = [];

            cache.static_group_visible_id = 0;
            cache.groupdb = groupdb;
            cache.journaldb = journaldb;
            cache.statsdb = statsdb;
            cache.rolldb = rolldb;
            showDynamicGroupFields(cache, set_values);
            setAttributeGroupVisibility(cache, set_values);
            set_values.character_default_value_points = int(cache.character_default_value_points, 0);
            set_values.static_character_points_total = cache.character_default_value_points || 0;
            set_values.static_character_points_base = cache.character_default_value_points || 0;
            set_values.static_character_points_remaining = cache.character_default_value_points || 0;
            set_values.static_group_visible_id = 0;
            set_values.groupdb = JSON.stringify(groupdb);
            set_values.static_journal_page_number = 1;
            set_values.static_journal_title_name = 'Default Journal Entry';
            set_values.journaldb = JSON.stringify(journaldb);
            set_values.static_sheet_settings_initialized = 1;
            set_values.statsdb = JSON.stringify(statsdb);
        } else if (cache.static_sheet_settings_type !== 'GM') {
            cache.groupdb = JSON.parse(cache.groupdb);
            await upgradeSheetVersion(cache, set_values);
            showDynamicGroupFields(cache, set_values);
            cache.static_group_visible_id = cache.static_group_visible_id || 0;
            setAttributeGroupVisibility(cache, set_values);
            //set_values.static_roll_skill_state = cache.rulesdb.rules_optional_individual_status;
        }
        set_values.static_character_details_name = cache.character_name;
        setAttrsAsync(set_values,{silent:true});
        clog(cache, set_values, 'setAttrs()');
        clog(cache, '', 'End Script', 'end');
    });

    on(getEvents(), async (event_info) => {
        if (event_info.sourceType === 'sheetworker') { return; }
        const set_values = {}; // all value changes to be written
        const cache = {}; // cache of all databases and values required by event
        setTimer(cache);
        clog(cache, cache, 'cache', 'info');
        // Set event values to align with standard formatting
        doEventTasks(cache, event_info);
        clog(cache, event_info, 'doEventTasks()', 'info');
        getSourceAttributes(cache, event_info.sourceAttribute);
        const attrs_keys = getAttrKeys(cache, event_info);
        const rules_index = attrs_keys.indexOf('rulesdb');
        if (rules_index !== -1) {
            attrs_keys.splice(rules_index, 1);
        }
        const values = await getAttrsAsync(attrs_keys);
        clog(cache, values, 'getAttrs()', 'info');
        Object.assign(cache, values, event_info);
        for (let i = 0; i < dbs.length; i++) {
            if (cache[dbs[i]] !== undefined) {
                cache[dbs[i]] = JSON.parse(cache[dbs[i]]);
            }
        }
        if (rules_index !== -1) {
            cache.rulesdb = await crpGet(cache, 'rulesdb');
            cache.rulesdb = JSON.parse(cache.rulesdb);
            set_values.static_skills_show_state = 
                cache.rulesdb.rules_optional_individual_status === 1 ? 1 : 0;
        }
        cache.rulebook = !cache.static_sheet_settings_gm ? 'besm' : await crpGet(cache, 'static_rules_base_default');
        updateSheetRulesSummary(cache, set_values);
        cache.silent = true;
        switch (cache.source_type) {
            case 'repeating':
                switch (cache.source_section) {
                    case 'attribute':
                    case 'defect':
                        switch (cache.source_attribute) {
                            case 'accordion':
                                setAccordion(cache, set_values);
                            break;
                            case 'active':
                                const attr_to_value = {
                                    'attack mastery':'acv',
                                    'defense mastery':'dcv',
                                    'energized':'energy',
                                    'extra actions':'actions',
                                    'extra defenses':'defenses',
                                    'hardboiled':'shockvalue',
                                    'massive damage':'dm',
                                    'social mastery':'scv',
                                    'tough':'health',
                                    'unassailable':'sanity',
                                };
                                const db = cache.source_section === 'attribute' ? 'attrdb' : 'defectdb';
                                cache.attribute = 
                                    cache[`${cache.source_path}_${cache.source_section}`].toLowerCase();
                                cache.index =
                                    cache[db][cache.attribute].findIndex(a => {
                                        return a.row_id.toLowerCase() === cache.source_id;
                                    });
                                cache.active = cache.newValue === 1 ? true : false;
                                cache[db][cache.attribute][cache.index].active = cache.active;
                                if (cache.attribute === 'augmented') {
                                    cache.aug_index = cache.attrdb.augmented[cache.index].config.findIndex(c => c.name === 'augmented_stat');
                                    cache.augmented_stat = cache.attrdb.augmented[cache.index].config[cache.aug_index].rank;
                                    cache.augmented_rank = 0;
                                    for (let i = 0; i < cache.attrdb.augmented.length; i++) {
                                        const index = cache.attrdb.augmented[i].config.findIndex(c => c.name === 'augmented_stat');
                                        if (cache.attrdb.augmented[i].config[index].rank === cache.augmented_stat) {
                                            cache.augmented_rank += cache.attrdb.augmented[i].elevel * (
                                                cache.attrdb.augmented[i].row_id.toLowerCase() === cache.source_id ? cache.newValue : 1
                                            );
                                        }
                                    }
                                    cache.statsdb[cache.augmented_stat].augmented = cache.augmented_rank;
                                    set_values[`static_character_${cache.augmented_stat}_remaining`] = 
                                        cache.statsdb[cache.augmented_stat].base +
                                        cache.statsdb[cache.augmented_stat].augmented +
                                        cache.statsdb[cache.augmented_stat].temp -
                                        cache.statsdb[cache.augmented_stat].damage -
                                        (cache.statsdb[cache.augmented_stat].shortcoming || 0);
                                } else if (cache.attribute === 'shortcoming') {
                                    const shortcomings = {
                                        body:0,
                                        mind:0,
                                        soul:0,
                                    };
                                    for (let i = 0; i < cache.defectdb.shortcoming.length; i++) {
                                        const name_index = cache.defectdb.shortcoming[i].config.findIndex(c => c.name === 'aspect_name');
                                        const stat_index = cache.defectdb.shortcoming[i].config.findIndex(c => c.name === 'aspect_stat');
                                        const type_index = cache.defectdb.shortcoming[i].config.findIndex(c => c.name === 'aspect_type');
                                        if (
                                            cache.defectdb.shortcoming[i].config[type_index].rank === 'all' && 
                                            cache.defectdb.shortcoming[i].active
                                        ) {
                                            shortcomings[cache.defectdb.shortcoming[i].config[stat_index].rank] += 
                                                cache.defectdb.shortcoming[i].level;
                                        }
                                    }
                                    for (let i = 0; i < all_stats.length; i++) {
                                        cache.statsdb[all_stats[i]].shortcoming = shortcomings[all_stats[i]];
                                        set_values[`static_character_${all_stats[i]}_remaining`] = 
                                        cache.statsdb[all_stats[i]].base +
                                        (cache.statsdb[all_stats[i]].augmented || 0) +
                                        cache.statsdb[all_stats[i]].temp -
                                        cache.statsdb[all_stats[i]].damage -
                                        cache.statsdb[all_stats[i]].shortcoming;
                                    }
                                } else if (cache.attribute === 'swarm') {
                                    const db = cache.attrdb.swarm[cache.attrdb.swarm.findIndex(s => s.row_id.toLowerCase() === cache.source_id)];
                                    if (cache.newValue) {
                                        db.active_map = {};
                                        for (let i = 0; i < all_attributes.length; i++) {
                                            db.active_map[all_attributes[i]] = [];
                                            cache.attrdb[all_attributes[i]].forEach(a => {
                                                if (a.row_id.toLowerCase() !== cache.source_id) {
                                                    db.active_map[all_attributes[i]].push({
                                                        row_id: a.row_id,
                                                        active: a.active,
                                                    });
                                                    a.active = false;
                                                    set_values[`repeating_attribute_${a.row_id.toLowerCase()}_active`] = 0;
                                                }
                                            });
                                        }
                                    } else {
                                        for (let i = 0; i < all_attributes.length; i++) {
                                            db.active_map[all_attributes[i]].forEach(a => {
                                                const restore_index = cache.attrdb[all_attributes[i]].findIndex(r => r.row_id.toLowerCase() === a.row_id.toLowerCase());
                                                cache.attrdb[all_attributes[i]][restore_index].active = a.active;
                                                set_values[`repeating_attribute_${a.row_id.toLowerCase()}_active`] = a.active ? 1 : 0;
                                            });

                                        }
                                    }
                                }
                                await setDerivedValues(cache, set_values);
                                if (cache.groupdb[cache.static_group_visible_id].group_type === 'power flux') {
                                    setPowerFluxPoolPoints(cache, set_values);
                                } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'dynamic powers') {
                                    setDynamicPowersPoolLevels(cache, set_values);
                                }
                            break;
                            case 'attribute':
                            case 'configuration':
                            case 'defect':
                            case 'enhancements':
                            case 'level':
                            case 'limiters':
                            case 'rank':
                            case 'stat':
                                await attributesMenu(cache, set_values);
                            break;
                        }
                    break;
                    case 'condition':
                        await openMenu(cache, set_values);
                    break;
                    case 'roll':
                        switch (cache.source_attribute) {
                            case 'accordion':
                                setAccordion(cache, set_values);
                            break;
                            case 'attribute':
                            case 'enemy':
                            case 'maneuver':
                            case 'modifier':
                            case 'name':
                            case 'stat':
                            case 'target':
                            case 'type':
                                await rollMenu(cache, set_values);
                            break;
                            case 'rollmacro':
                                await actionRoll(cache, set_values);
                            break;
                        }
                    break;
                    case 'skill':
                        switch (cache.source_attribute) {
                            case 'accordion':
                                setAccordion(cache, set_values);
                            break;
                            case 'rank':
                            case 'specializations':
                            case 'stat':
                                await skillsMenu(cache, set_values);
                            break;
                        }
                    break;
                }
            break;
            case 'react':
                await actionRoll(cache, set_values);
            break;
            case 'rules':
                await toggleRuleSetting(cache, set_values);
            break;
            case 'static':
                switch (cache.source_section) {
                    case 'attribute':
                        await attributesMenu(cache, set_values);
                    break;
                    case 'attributes':
                        switch (cache.source_attribute) {
                            case 'button':
                                switch (cache.source_id) {
                                    case 'accordion':
                                        setAccordion(cache, set_values);
                                    break;
                                    case 'accordions':
                                        cache.attribute_ids = await getSectionIDsAsync('attribute');
                                        cache.defect_ids = await getSectionIDsAsync('defect');
                                        setAttributeAccordions(cache, set_values);
                                    break;
                                    case 'add':
                                    case 'delete':
                                    case 'edit':
                                        await attributesMenu(cache, set_values);
                                    break;
                                    case 'groupselect':
                                        await groupSelectMenu(cache, set_values);
                                    break;
                                    case 'grouptoggle':
                                        await groupToggleMenu(cache, set_values);
                                    break;
                                    case 'lock':
                                        const query = {};
                                        const toggle_lock = cache.groupdb[cache.static_group_visible_id].locked ? false : true;
                                        cache.groupdb[cache.static_group_visible_id].locked = toggle_lock;
                                        set_values.static_attributes_lock_icon = toggle_lock ? "lock" : "lock_open";
                                        if (!toggle_lock) {
                                            for (let i = 0; i < all_attributes.length; i++) {
                                                query.attribute = all_attributes[i];
                                                for (let j = 0; j < cache.attrdb[query.attribute].length; j++) {
                                                    const attribute = cache.attrdb[query.attribute][j];
                                                    query.index = j;
                                                    if (cache.groupdb[cache.static_group_visible_id].attribute_ids.findIndex(id => id === attribute.row_id) !== -1) {
                                                        attribute.points = attribute.config[attribute.config.findIndex(c => c.name === 'base points')].rank;
                                                        attribute.level = attribute.points / attribute_costs[query.attribute];
                                                        const enhancement_ranks =
                                                            attribute.enhancements.map(c => c.rank).reduce((a, b) => a + b, 0);
                                                        const limiter_ranks =
                                                            attribute.limiters.map(c => c.rank).reduce((a, b) => a + b, 0);
                                                        attribute.elevel = 
                                                            attribute.level + limiter_ranks - enhancement_ranks;
                                                        query.elevel = attribute.elevel;
                                                        set_values[`repeating_attribute_${attribute.row_id}_level`] = 
                                                            `${attribute.level} (${attribute.elevel})`;
                                                        set_values[`repeating_attribute_${attribute.row_id}_points`] = 
                                                            attribute.points;
                                                        setLevelDependantConfigurations(cache, set_values, query);
                                                    }
                                                }
                                            }
                                            setPowerVariationPoolPoints(cache, set_values);
                                        }
                                    break;
                                }
                            break;
                        }
                    break;
                    case 'screen':
                    case 'status':
                    case 'stats':
                    case 'gmscreen':
                    case 'capabilities':
                        switch (cache.source_attribute) {
                            case 'button':
                                switch (cache.source_id) {
                                    case 'accordion':
                                        setAccordion(cache, set_values);
                                    break;
                                    case 'add':
                                    case 'delete':
                                    case 'edit':
                                    case 'update':
                                        await openMenu(cache, set_values);
                                    break;
                                    case 'help':
                                        await displayHelp(cache);
                                    break;
                                    case 'rolls':
                                        await actionRoll(cache, set_values);
                                    break;
                                }
                            break;
                        }
                    break;
                    case 'character':
                        await openMenu(cache, set_values);
                    break;
                    case 'roll':
                        switch (cache.source_id) {
                            case '2d6':
                            case 'attack':
                            case 'attribute':
                            case 'initiative':
                            case 'skill':
                            case 'stat':
                                await actionRoll(cache, set_values);
                            break;
                            case 'accordions':
                                cache.roll_ids = await getSectionIDsAsync('roll');
                                setRollAccordions(cache, set_values);
                            break;
                            case 'add':
                            case 'delete':
                                await rollMenu(cache, set_values);
                            break;
                        }
                    break;
                    case 'sheet':
                        switch (cache.source_id) {
                            case 'settings':
                                switch (cache.source_attribute) {
                                    case 'theme':
                                        if (cache.htmlAttributes === undefined) {
                                            setTheme(cache);
                                            cache.silent = false;
                                        } else {
                                            await openMenu(cache, set_values);
                                        }
                                    break;
                                    case 'gm':
                                    case 'player':
                                    case 'type':
                                        await openMenu(cache, set_values);
                                    break;
                                }
                            break;
                        }
                    break;
                    case 'skills':
                        switch (cache.source_id) {
                            case 'accordions':
                                cache.skill_ids = await getSectionIDsAsync('skill');
                                setSkillAccordions(cache, set_values);
                            break;
                            case 'edit':
                            case 'add':
                            case 'delete':
                                await skillsMenu(cache, set_values);
                            break;
                            case 'uiselect':
                                await skillsUiSelectMenu(cache, set_values);
                            break;
                            case 'uitoggle':
                                await skillsUiToggleMenu(cache, set_values);
                            break;
                        }
                    break;
                    case 'journal':
                        switch (cache.source_id) {
                            case 'accordion':
                                setAccordion(cache, set_values);
                            break;
                            case 'add':
                            case 'delete':
                            case 'edit':
                            case 'title':
                                await journalMenu(cache, set_values);
                            break;
                            case 'save':
                                await journalSavePage(cache, set_values);
                            break;
                            case 'page':
                            case 'select':
                                await journalSelectMenu(cache, set_values);
                            break;
                        }
                    break;
                    case 'rules':
                        switch (cache.source_id) {
                            case 'accordion':
                                setAccordion(cache, set_values);
                            break;
                            case 'base':
                                await changeSheetLogo(cache);
                                await setBaseRules(cache, set_values);
                            break;
                            default:
                                await toggleRuleSetting(cache, set_values);
                        }
                    break;
                }
            break;
        }
        for (let i = 0; i < dbs.length; i++) {
            if (cache[dbs[i]] !== undefined) {
                set_values[dbs[i]] = JSON.stringify(cache[dbs[i]]);
            }
        }
        setAttrsAsync(set_values,cache.silent);
        clog(cache, set_values, 'set_values()', 'info');
        clog(cache, '', 'Sheet Worker End', 'end');
    });
</script>