<!-- Character Sheet -->
<div>
<input name="attr_static_sheet_state_type" class="charactersheet-type" type="hidden" value="player" />
<!--// PLAYER SHEET //-->
    <div class="charactersheet-player">
        <div>
            <!-- Screen Title -->
            <input name="attr_static_screen_accordion_state" class="accordion-screen" type="checkbox" value="1" />
            <div class="grid-container-title-bar theme-border">
                <div class="grid-minor-title-buttons-left">
                    <!--
                    <button name="act_static_screen_rolls_button" class="grid-minor-input-rolls styling-big-pill-input styling-dice-roll-background theme-input-major" type="action">
                        &nbsp
                    </button>
                    -->
                    <button name="act_static_screen_rolls_button" class="styling-section-button wide-button button-click-animation theme-button" type="action">
                        <span class="d6font">C D</span>
                    </button>
                </div>
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="character-screen">Character Screen</span>
                </div>
                <!-- Title Buttons -->
                <div class="grid-minor-title-buttons-right">
                    <button name="act_static_screen_help_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">help</span>
                    </button>
                    <button name="act_static_screen_edit_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">edit</span>
                    </button>
                    <button name="act_static_screen_accordion_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                </div>
            </div>
            <div class="styling-border theme-border">
                <div class="styling-background theme-background">
                    <div class="grid-major-screen-top">
                        <!-- Screen Top-Left -->
                        <div class="grid-minor-screen-name styling-pill theme-major">
                            <span data-i18n="name">Name</span>
                        </div>
                        <input name="attr_static_character_details_name" class="grid-minor-input-name styling-pill-input theme-input-major" type="text" value="" readonly />
                        <div class="grid-minor-screen-race styling-pill theme-major">
                            <span data-i18n="race">Race</span>
                        </div>
                        <input name="attr_static_character_details_race" class="grid-minor-input-race styling-pill-input theme-input-major" type="text" value="" readonly />
                        <div class="grid-minor-screen-class styling-pill theme-major">
                            <span data-i18n="class">Class</span>
                        </div>
                        <input name="attr_static_character_details_class" class="grid-minor-input-class styling-pill-input theme-input-major" type="text" value="" readonly />
                        <!-- Screen Top-Center -->
                        <div class="grid-minor-screen-logo"></div>
                        <!-- Screen Top-Right -->
                        <div class="grid-minor-screen-height styling-pill theme-major">
                            <span data-i18n="height">Height</span>
                        </div>
                        <input name="attr_static_character_details_height" class="grid-minor-input-height styling-pill-input theme-input-major" type="text" value="" readonly />
                        <div class="grid-minor-screen-weight styling-pill theme-major">
                            <span data-i18n="weight">Weight</span>
                        </div>
                        <input name="attr_static_character_details_weight" class="grid-minor-input-weight styling-pill-input theme-input-major" type="text" value="" readonly />
                        <div class="grid-minor-screen-totalcp styling-pill theme-major">
                            <span data-i18n="points">Points</span>
                        </div>
                        <input name="attr_static_character_points_total" class="grid-minor-input-totalcp styling-pill-input theme-input-major" type="text" value=0 readonly />
                        <!-- Screen Middle 1st Tier -->
                        <div class="grid-minor-screen-dm styling-big-pill theme-major">
                            <span data-i18n="damage-multiplier-u">DM</span>
                            <input name="attr_static_character_dm_base" class="grid-minor-input-dm styling-big-pill-input theme-input-major" type="text" value=5 readonly />
                        </div>
                        <div class="grid-minor-screen-acv styling-big-pill theme-major">
                            <span data-i18n="attack-combat-value-u">ACV</span>
                            <input name="attr_static_character_acv_base" class="grid-minor-input-acv styling-big-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <div class="grid-minor-screen-dcv styling-big-pill theme-major">
                            <span data-i18n="defense-combat-value-u">DCV</span>
                            <input name="attr_static_character_dcv_base" class="grid-minor-input-dcv styling-big-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <div class="grid-minor-screen-scv styling-big-pill theme-major">
                            <span data-i18n="social-combat-value-u">SCV</span>
                            <input name="attr_static_character_scv_base" class="grid-minor-input-scv styling-big-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <!-- Screen Middle 2nd Tier -->
                        <div class="grid-minor-screen-initiative styling-big-pill theme-major">
                            <span data-i18n="initiative">Initiative</span>
                            <input name="attr_static_character_initiative_base" class="grid-minor-input-initiative styling-big-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <div class="grid-minor-screen-actions styling-big-pill theme-major">
                            <span data-i18n="actions">Actions</span>
                            <input name="attr_static_character_actions_base" class="grid-minor-input-actions styling-big-pill-input theme-input-major" type="text" value=1 readonly />
                        </div>
                        <div class="grid-minor-screen-defenses styling-big-pill theme-major">
                            <span data-i18n="defenses">Defenses</span>
                            <input name="attr_static_character_defenses_base" class="grid-minor-input-defenses styling-big-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <div class="grid-minor-screen-shockvalue styling-big-pill theme-major">
                            <span data-i18n="shock-value">Shock Value</span>
                            <input name="attr_static_character_shockvalue_base" class="grid-minor-input-shockvalue styling-big-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                    </div>
                    <input name="attr_static_screen_accordion_state" class="accordion-screen" type="checkbox" value="1" />
                    <div class="grid-major-screen-bottom accordion-screen">
                        <!-- Sheet Details -->
                        <div class="grid-minor-details-header styling-pill-title theme-major">
                            <span data-i18n="details">Details</span>
                        </div>
                        <div class="grid-minor-screen-debug styling-pill theme-minor">
                            <span data-i18n="debug-level">Debug Level</span>
                        </div>
                        <input name="attr_static_sheet_settings_debug" class="grid-minor-input-debug styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-screen-player styling-pill theme-minor">
                            <span data-i18n="player-name">Player Name</span>
                        </div>
                        <input name="attr_static_sheet_settings_player" class="grid-minor-input-player styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-screen-pronoun styling-pill theme-minor">
                            <span data-i18n="pronoun">Pronoun</span>
                        </div>
                        <input name="attr_static_character_details_pronoun" class="grid-minor-input-pronoun styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-screen-type styling-pill theme-minor">
                            <span data-i18n="sheet-type">Sheet Type</span>
                        </div>
                        <input name="attr_static_sheet_settings_type" class="grid-minor-input-type styling-pill-input theme-input" type="text" value="Player" readonly />
                        <div class="grid-minor-screen-version styling-pill theme-minor">
                            <span data-i18n="sheet-version">Sheet Version</span>
                        </div>
                        <input name="attr_static_sheet_settings_version" class="grid-minor-input-version styling-pill-input theme-input" type="text" value="0.1" readonly />
                        <div class="grid-minor-screen-size styling-pill theme-minor">
                            <span data-i18n="size">Size</span>
                        </div>
                        <input name="attr_static_character_details_size" class="grid-minor-input-size styling-pill-input theme-input" type="text" value="Medium" readonly />
                        <div class="grid-minor-screen-theme styling-pill theme-minor">
                            <span data-i18n="theme">Theme</span>
                        </div>
                        <input name="attr_static_sheet_settings_theme" class="grid-minor-input-theme styling-pill-input theme-input" type="text" value="Tri Stat Core" readonly />
                        <div class="grid-minor-game-settings-header styling-pill-title theme-major">
                            <span data-i18n="game-settings">Game Settings</span>
                        </div>
                        <div class="grid-minor-screen-gmname styling-pill theme-minor">
                            <span data-i18n="game-master-name">GM Name</span>
                        </div>
                        <input name="attr_static_sheet_settings_gm" class="grid-minor-input-gmname styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-screen-rules styling-big-pill theme-minor">
                            <span data-i18n="rules-enabled">Rules Enabled</span>
                            <textarea name="attr_static_sheet_settings_rules" class="styling-big-pill-textarea theme-input" wrap="soft" placeholder="Core Rulebook (default)" readonly></textarea>
                        </div>
                        <div class="grid-minor-character-points-header styling-pill-title theme-major">
                            <span data-i18n="character-points">Character Points</span>
                        </div>
                        <div class="grid-minor-screen-basecp styling-pill theme-minor">
                            <span data-i18n="base">Base</span>
                        </div>
                        <input name="attr_static_character_points_base" class="grid-minor-input-basecp styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-screen-gainedcp styling-pill theme-minor">
                            <span data-i18n="gained">Gained</span>
                        </div>
                        <input name="attr_static_character_points_gained" class="grid-minor-input-gainedcp styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-screen-spentcp styling-pill theme-minor">
                            <span data-i18n="spent">Spent</span>
                        </div>
                        <input name="attr_static_character_points_spent" class="grid-minor-input-spentcp styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-screen-temporarycp styling-pill theme-minor">
                            <span data-i18n="temporary">Temporary</span>
                        </div>
                        <input name="attr_static_character_points_temp" class="grid-minor-input-temporarycp styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-screen-remainingcp styling-pill theme-minor">
                            <span data-i18n="remaining">Remaining</span>
                        </div>
                        <input name="attr_static_character_points_remaining" class="grid-minor-input-remainingcp styling-pill-input theme-input" type="text" value=0 readonly />
                    </div>
                </div>
            </div>
        </div>
        <div class="section-break"></div>
        <div>
            <!-- Status Title -->
            <input name="attr_static_status_accordion_state" class="accordion-status" type="checkbox" value="1" />
            <div class="grid-container-title-bar theme-border">
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="status">Status</span>
                </div>
                <!-- Title Buttons -->
                <div class="grid-minor-title-buttons-right">
                    <button name="act_static_status_update_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">update</span>
                    </button>
                    <button name="act_static_status_edit_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">edit</span>
                    </button>
                    <button name="act_static_status_accordion_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                </div>
            </div>
            <div class="styling-border theme-border">
                <div class="container-status styling-background theme-background">
                    <fieldset class="repeating_condition">
                        <div class="grid-major-status-conditions">
                            <input name="attr_name" type="hidden" value="" />
                            <div class="grid-minor-status-condition styling-pill theme-major">
                                <span name="attr_name"></span>
                            </div>
                            <input name="attr_description" class="grid-minor-input-condition styling-pill-input theme-input-major" type="text" value="" readonly />
                        </div>
                    </fieldset>
                    <div class="grid-major-status-top">
                        <div class="grid-minor-status-energy styling-big-pill theme-major">
                            <span data-i18n="energy-points">Energy Points</span>
                            <input name="attr_static_sheet_energy_state" class="status-bar-energy" type="hidden" value=0 readonly />
                            <input name="attr_static_character_energy_status" class="grid-minor-input-energystatus styling-big-pill-input status-bar theme-input-major" type="text" value="Rested" readonly />
                        </div>
                        <div class="grid-minor-status-health styling-big-pill theme-major">
                            <span data-i18n="health-points">Health Points</span>
                            <input name="attr_static_sheet_health_state" class="status-bar-health" type="hidden" value=0 readonly />
                            <input name="attr_static_character_health_status" class="grid-minor-input-healthstatus styling-big-pill-input status-bar theme-input-major" type="text" value="Healthy" readonly />
                        </div>
                        <div class="grid-minor-status-sanity styling-big-pill theme-major">
                            <span data-i18n="sanity-points">Sanity Points</span>
                            <input name="attr_static_sheet_sanity_state" class="status-bar-sanity" type="hidden" value=0 readonly />
                            <input name="attr_static_character_sanity_status" class="grid-minor-input-sanitystatus styling-big-pill-input status-bar theme-input-major" type="text" value="Well" readonly />
                        </div>
                        <div class="grid-minor-status-society styling-big-pill theme-major">
                            <span data-i18n="society-points">Society Points</span>
                            <input name="attr_static_sheet_society_state" class="status-bar-society" type="hidden" value=0 readonly />
                            <input name="attr_static_character_society_status" class="grid-minor-input-societystatus styling-big-pill-input status-bar theme-input-major" type="text" value="Confident" readonly />
                        </div>
                    </div>
                    <input name="attr_static_status_accordion_state" class="accordion-status" type="checkbox" value="1" />
                    <div class="grid-major-status-bottom accordion-status">
                        <div class="grid-minor-remaining-energy styling-pill theme-minor">
                            <span data-i18n="remaining">Remaining</span>
                        </div>
                        <input name="attr_static_character_energy_remaining" class="grid-minor-input-remainingenergy styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-base-energy styling-pill theme-minor">
                            <span data-i18n="base">Base</span>
                        </div>
                        <input name="attr_static_character_energy_base" class="grid-minor-input-baseenergy styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-temp-energy styling-pill theme-minor">
                            <span data-i18n="temp">Temp</span>
                        </div>
                        <input name="attr_static_character_energy_temp" class="grid-minor-input-tempenergy styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-damage-energy styling-pill theme-minor">
                            <span data-i18n="damage">Damage</span>
                        </div>
                        <input name="attr_static_character_energy_damage" class="grid-minor-input-damageenergy styling-pill-input theme-input" type="text" value=0 readonly />

                        <div class="grid-minor-remaining-health styling-pill theme-minor">
                            <span data-i18n="remaining">Remaining</span>
                        </div>
                        <input name="attr_static_character_health_remaining" class="grid-minor-input-remaininghealth styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-base-health styling-pill theme-minor">
                            <span data-i18n="base">Base</span>
                        </div>
                        <input name="attr_static_character_health_base" class="grid-minor-input-basehealth styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-temp-health styling-pill theme-minor">
                            <span data-i18n="temp">Temp</span>
                        </div>
                        <input name="attr_static_character_health_temp" class="grid-minor-input-temphealth styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-damage-health styling-pill theme-minor">
                            <span data-i18n="damage">Damage</span>
                        </div>
                        <input name="attr_static_character_health_damage" class="grid-minor-input-damagehealth styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-stun-health styling-pill theme-minor">
                            <span data-i18n="stun">Stun</span>
                        </div>
                        <input name="attr_static_character_health_stun" class="grid-minor-input-stunhealth styling-pill-input theme-input" type="text" value=0 readonly />

                        <div class="grid-minor-remaining-sanity styling-pill theme-minor">
                            <span data-i18n="remaining">Remaining</span>
                        </div>
                        <input name="attr_static_character_sanity_remaining" class="grid-minor-input-remainingsanity styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-base-sanity styling-pill theme-minor">
                            <span data-i18n="base">Base</span>
                        </div>
                        <input name="attr_static_character_sanity_base" class="grid-minor-input-basesanity styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-temp-sanity styling-pill theme-minor">
                            <span data-i18n="temp">Temp</span>
                        </div>
                        <input name="attr_static_character_sanity_temp" class="grid-minor-input-tempsanity styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-damage-sanity styling-pill theme-minor">
                            <span data-i18n="damage">Damage</span>
                        </div>
                        <input name="attr_static_character_sanity_damage" class="grid-minor-input-damagesanity styling-pill-input theme-input" type="text" value=0 readonly />
                        
                        <div class="grid-minor-remaining-society styling-pill theme-minor">
                            <span data-i18n="remaining">Remaining</span>
                        </div>
                        <input name="attr_static_character_society_remaining" class="grid-minor-input-remainingsociety styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-base-society styling-pill theme-minor">
                            <span data-i18n="base">Base</span>
                        </div>
                        <input name="attr_static_character_society_base" class="grid-minor-input-basesociety styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-temp-society styling-pill theme-minor">
                            <span data-i18n="temp">Temp</span>
                        </div>
                        <input name="attr_static_character_society_temp" class="grid-minor-input-tempsociety styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-damage-society styling-pill theme-minor">
                            <span data-i18n="damage">Damage</span>
                        </div>
                        <input name="attr_static_character_society_damage" class="grid-minor-input-damagesociety styling-pill-input theme-input" type="text" value=0 readonly />
                    </div>
                </div>
            </div>
        </div>
        <div class="section-break"></div>
        <div>
            <!-- Stats Title -->
            <input name="attr_static_stats_accordion_state" class="accordion-stats" type="checkbox" value="1" />
            <div class="grid-container-title-bar theme-border">
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="stats">Stats</span>
                </div>
                <!-- Title Buttons -->
                <div class="grid-minor-title-buttons-right">
                    <button name="act_static_stats_edit_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">edit</span>
                    </button>
                    <button name="act_static_stats_accordion_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                </div>
            </div>
            <div class="styling-border theme-border">
                <div class="styling-background theme-background">
                    <div class="grid-major-stats-top">
                        <div class="grid-minor-stats-body styling-big-pill theme-major">
                            <span data-i18n="body">Body</span>
                            <input name="attr_static_character_body_remaining" class="grid-minor-input-body styling-long-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <div class="grid-minor-stats-mind styling-big-pill theme-major">
                            <span data-i18n="mind">Mind</span>
                            <input name="attr_static_character_mind_remaining" class="grid-minor-input-mind styling-long-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                        <div class="grid-minor-stats-soul styling-big-pill theme-major">
                            <span data-i18n="soul">Soul</span>
                            <input name="attr_static_character_soul_remaining" class="grid-minor-input-soul styling-long-pill-input theme-input-major" type="text" value=0 readonly />
                        </div>
                    </div>
                    <input name="attr_static_stats_accordion_state" class="accordion-stats" type="checkbox" value="1" />
                    <div class="grid-major-stats-bottom accordion-stats">
                        <div class="grid-minor-base-body styling-pill theme-minor">
                            <span data-i18n="base">Base</span>
                        </div>
                        <input name="attr_static_character_body_base" class="grid-minor-input-basebody styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-temp-body styling-pill theme-minor">
                            <span data-i18n="temp">Temp</span>
                        </div>
                        <input name="attr_static_character_body_temp" class="grid-minor-input-tempbody styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-damage-body styling-pill theme-minor">
                            <span data-i18n="damage">Damage</span>
                        </div>
                        <input name="attr_static_character_body_damage" class="grid-minor-input-damagebody styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-base-mind styling-pill theme-minor">
                            <span data-i18n="base">Base</span>
                        </div>
                        <input name="attr_static_character_mind_base" class="grid-minor-input-basemind styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-temp-mind styling-pill theme-minor">
                            <span data-i18n="temp">Temp</span>
                        </div>
                        <input name="attr_static_character_mind_temp" class="grid-minor-input-tempmind styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-damage-mind styling-pill theme-minor">
                            <span data-i18n="damage">Damage</span>
                        </div>
                        <input name="attr_static_character_mind_damage" class="grid-minor-input-damagemind styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-base-soul styling-pill theme-minor">
                            <span data-i18n="base">Base</span>
                        </div>
                        <input name="attr_static_character_soul_base" class="grid-minor-input-basesoul styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-temp-soul styling-pill theme-minor">
                            <span data-i18n="temp">Temp</span>
                        </div>
                        <input name="attr_static_character_soul_temp" class="grid-minor-input-tempsoul styling-pill-input theme-input" type="text" value=0 readonly />
                        <div class="grid-minor-damage-soul styling-pill theme-minor">
                            <span data-i18n="damage">Damage</span>
                        </div>
                        <input name="attr_static_character_soul_damage" class="grid-minor-input-damagesoul styling-pill-input theme-input" type="text" value=0 readonly />
                    </div>
                </div>
            </div>
        </div>
        <div class="section-break"></div>
        <div>
            <!-- Capabilities Title -->
            <input name="attr_static_capabilities_accordion_state" class="accordion-capabilities" type="checkbox" value="1" />
            <div class="grid-container-collapsible-title-bar theme-border">
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="capabilities">Capabilities</span>
                </div>
                <!-- Title Buttons -->
                <div class="grid-minor-title-buttons-right">
                    <button name="act_static_capabilities_accordion_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                </div>
            </div>
            <div class="styling-border theme-border accordion-capabilities">
                <div class="styling-background theme-background">
                    <div class="grid-major-capabilities">
                        <div class="grid-minor-senses-header styling-pill-title theme-major">
                            <span data-i18n="senses">Senses</span>
                        </div>
                        <div class="grid-minor-senses-hearing styling-pill theme-minor">
                            <span data-i18n="hearing">Hearing</span>
                        </div>
                        <input name="attr_static_character_capabilities_hearing" class="grid-minor-input-hearing styling-pill-input theme-input" type="text" value="Normal" readonly />
                        <div class="grid-minor-senses-sight styling-pill theme-minor">
                            <span data-i18n="sight">Sight</span>
                        </div>
                        <input name="attr_static_character_capabilities_sight" class="grid-minor-input-sight styling-pill-input theme-input" type="text" value="Normal" readonly />
                        <div class="grid-minor-senses-smell styling-pill theme-minor">
                            <span data-i18n="smell">Smell</span>
                        </div>
                        <input name="attr_static_character_capabilities_smell" class="grid-minor-input-smell styling-pill-input theme-input" type="text" value="Normal" readonly />
                        <div class="grid-minor-senses-taste styling-pill theme-minor">
                            <span data-i18n="taste">Taste</span>
                        </div>
                        <input name="attr_static_character_capabilities_taste" class="grid-minor-input-taste styling-pill-input theme-input" type="text" value="Normal" readonly />
                        <div class="grid-minor-senses-touch styling-pill theme-minor">
                            <span data-i18n="touch">Touch</span>
                        </div>
                        <input name="attr_static_character_capabilities_touch" class="grid-minor-input-touch styling-pill-input theme-input" type="text" value="Normal" readonly />
                        <div class="grid-minor-senses-sixthsense styling-pill theme-minor">
                            <span data-i18n="sixthsense">Sixth Sense</span>
                        </div>
                        <input name="attr_static_character_capabilities_sixthsense" class="grid-minor-input-sixthsense styling-pill-input theme-input" type="text" value="None" readonly />
                        <div class="grid-minor-movement-header styling-pill-title theme-major">
                            <span data-i18n="movement">Movement</span>
                        </div>
                        <div class="grid-minor-movement-walk styling-pill theme-minor">
                            <span data-i18n="walk">Walk</span>
                        </div>
                        <input name="attr_static_character_capabilities_walk" class="grid-minor-input-walk styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-jog styling-pill theme-minor">
                            <span data-i18n="jog">Jog</span>
                        </div>
                        <input name="attr_static_character_capabilities_jog" class="grid-minor-input-jog styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-run styling-pill theme-minor">
                            <span data-i18n="run">Run</span>
                        </div>
                        <input name="attr_static_character_capabilities_run" class="grid-minor-input-run styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-sprint styling-pill theme-minor">
                            <span data-i18n="sprint">Sprint</span>
                        </div>
                        <input name="attr_static_character_capabilities_sprint" class="grid-minor-input-sprint styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-swim styling-pill theme-minor">
                            <span data-i18n="swim">Swim</span>
                        </div>
                        <input name="attr_static_character_capabilities_swim" class="grid-minor-input-swim styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-sprintswim styling-pill theme-minor">
                            <span data-i18n="sprint-swim">Sprint Swim</span>
                        </div>
                        <input name="attr_static_character_capabilities_sprintswim" class="grid-minor-input-sprintswim styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-jump styling-pill theme-minor">
                            <span data-i18n="jump">jump</span>
                        </div>
                        <input name="attr_static_character_capabilities_jump" class="grid-minor-input-jump styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-leap styling-pill theme-minor">
                            <span data-i18n="leap">Leap</span>
                        </div>
                        <input name="attr_static_character_capabilities_leap" class="grid-minor-input-leap styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-movement-runningleap styling-pill theme-minor">
                            <span data-i18n="running-leap">Running Leap</span>
                        </div>
                        <input name="attr_static_character_capabilities_runningleap" class="grid-minor-input-runningleap styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-strength-header styling-pill-title theme-major">
                            <span data-i18n="strength">Strength</span>
                        </div>
                        <div class="grid-minor-strength-carry styling-pill theme-minor">
                            <span data-i18n="carry">Carry</span>
                        </div>
                        <input name="attr_static_character_capabilities_carry" class="grid-minor-input-carry styling-pill-input theme-input" type="text" value="" readonly />
                        <div class="grid-minor-strength-lift styling-pill theme-minor">
                            <span data-i18n="lift">Lift</span>
                        </div>
                        <input name="attr_static_character_capabilities_lift" class="grid-minor-input-lift styling-pill-input theme-input" type="text" value="" readonly />
                    </div>
                </div>
            </div>
        </div>
        <div class="section-break"></div>
        <div>
            <!-- Attributes Title -->
            <input name="attr_static_attributes_accordions_state" class="accordion-attributes" type="checkbox" value="1" />
            <div class="grid-container-title-bar theme-border">
                <!-- Title Buttons on Left -->
                <div class="grid-minor-title-buttons-left">
                    <button name="act_static_attributes_grouptoggle_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">checklist</span>
                    </button>
                </div>
                <!-- Title -->
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="attributes-and-defects">Attributes and Defects</span>
                </div>
                <!-- Title Buttons on Right -->
                <div class="grid-minor-title-buttons-right">
                    <button name="act_static_attributes_groupselect_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">auto_stories</span>
                    </button>
                    <button name="act_static_attributes_edit_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">edit</span>
                    </button>
                    <button name="act_static_attributes_accordions_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                    <input name="attr_static_attributes_accordions_state" type="hidden" value="1" />
                </div>
            </div>
            <div class="styling-border theme-border">
                <div class="container-attributes styling-background theme-background">
                    <div class="grid-major-attributes-grouphud">
                        <div class="grid-minor-attributes-groupname styling-pill theme-major">
                            <span data-i18n="group-name">Group Name</span>
                        </div>
                        <input name="attr_static_attributes_group_name" class="grid-minor-input-groupname styling-long-pill-input theme-input-major" type="text" value="" readonly />
                        <div class="grid-minor-attributes-grouppoints styling-pill theme-major">
                            <span data-i18n="group-points">Group Points</span>
                        </div>
                        <input name="attr_static_attributes_group_points" class="grid-minor-input-grouppoints styling-pill-input theme-input-major" type="text" value="" readonly />
                        <div class="grid-minor-attributes-grouptype styling-pill theme-major">
                            <span data-i18n="type">Type</span>
                        </div>
                        <input name="attr_static_attributes_group_type" class="grid-minor-input-grouptype styling-pill-input theme-input-major" type="text" value="" readonly />
                        <div class="grid-minor-attributes-groupsource styling-pill theme-major">
                            <span data-i18n="source">Source</span>
                        </div>
                        <input name="attr_static_attributes_group_source" class="grid-minor-input-groupsource styling-pill-input theme-input-major" type="text" value="" readonly />
                        <div class="grid-minor-attributes-grouporigin styling-pill theme-major">
                            <span data-i18n="origin">Item</span>
                        </div>
                        <input name="attr_static_attributes_group_origin" class="grid-minor-input-grouporigin styling-pill-input theme-input-major" type="text" value="" readonly />
                    </div>
                    <!--<input name="attr_static_group_type_state" class="nonstandard-group" type="checkbox" value="1" checked />-->
                    <div class="group-type-visibility">
                        <div class="grid-major-attributes-nonstandardgrouphud">
                            <div class="grid-minor-pointpool styling-pill theme-minor">
                                <input name="attr_static_group_pointpool_name" type="hidden" value="" readonly />
                                <span name="attr_static_group_pointpool_name"></span>
                            </div>
                            <input name="attr_static_group_pointpool_points" class="grid-minor-input-pointpool styling-pill-input theme-input" type="text" value="" readonly />

                            <div class="grid-minor-grouplevel styling-pill theme-minor">
                                <span data-i18n="level">Level</span>
                            </div>
                            <input name="attr_static_group_type_level" class="grid-minor-input-grouplevel styling-pill-input theme-input" type="text" value="" readonly />
                            
                            <div class="grid-minor-groupstat styling-pill theme-minor">
                                <span data-i18n="stat">Stat</span>
                            </div>
                            <input name="attr_static_group_type_stat" class="grid-minor-input-groupstat styling-pill-input theme-input" type="text" value="" readonly />

                            <div class="grid-minor-groupcost styling-pill theme-minor">
                                <span data-i18n="cost">Cost</span>
                            </div>
                            <input name="attr_static_group_type_cost" class="grid-minor-input-groupcost styling-pill-input theme-input" type="text" value="" readonly />

                            <div class="grid-minor-grouptypepoints styling-pill theme-minor">
                                <span data-i18n="points">Points</span>
                            </div>
                            <input name="attr_static_group_type_points" class="grid-minor-input-grouptypepoints styling-pill-input theme-input" type="text" value="" readonly />

                            <div class="grid-minor-groupdescription styling-big-pill theme-minor">
                                <span data-i18n="configuration">Configuration</span>
                                <textarea name="attr_static_group_type_description" class="grid-minor-input-groupdescription styling-big-pill-textarea-attribute theme-input" wrap="soft" placeholder="No special configuration" readonly></textarea>
                                <!--<span data-i18n="description">Description</span>
                                <textarea name="attr_static_group_type_description" class="grid-minor-input-groupdescription styling-big-pill-textarea-attribute theme-input" wrap="soft"></textarea>-->
                            </div>

                            <div class="grid-minor-groupenhancements styling-big-pill theme-minor">
                                <span data-i18n="enhancements">Enhancements</span>
                                <textarea name="attr_static_group_type_enhancements" class="grid-minor-input-groupenhancements styling-big-pill-textarea-attribute theme-input" wrap="soft" placeholder="No enhancements defined" readonly></textarea>
                            </div>

                            <div class="grid-minor-grouplimiters styling-big-pill theme-minor">
                                <span data-i18n="limiters">Limiters</span>
                                <textarea name="attr_static_group_type_limiters" class="grid-minor-input-grouplimiters styling-big-pill-textarea-attribute theme-input" wrap="soft" placeholder="No limiters defined" readonly></textarea>
                            </div>
                        </div>
                    </div>
                    <div class="section-break"></div>
                    <input name="attr_static_group_visible_id" type="hidden" value="0" readonly />
                    <fieldset class="repeating_attribute">
                        <input name="attr_visibility" class="attribute-visibility" type="hidden" value="1" readonly />
                        <div class="attribute-visibility-show">
                            <input name="attr_state" class="accordion-attribute" type="checkbox" value="1" />
                            <div class="grid-container-collapsible-title-bar theme-border">
                                <div class="grid-minor-title-buttons-left">
                                    <label class="attribute-active-switch">
                                        <input name="attr_active" class="attribute-active-status" type="checkbox" value="1" />
                                        <span class="attribute-active-slider theme-slider"></span>
                                    </label>
                                </div>
                                <div class="grid-minor-section-title theme-title">
                                    <span name="attr_name"></span>
                                    <input name="attr_name" type="hidden" value="Attribute Name" />
                                </div>
                                <div class="grid-minor-title-buttons-right">
                                    <button name="act_accordion" class="styling-section-button button-click-animation theme-button" type="action">
                                        <span class="material-icons expand">expand_less</span>
                                    </button>
                                </div>
                            </div>
                            <div class="styling-border theme-border accordion-attribute">
                                <div class="styling-background theme-background">
                                    <div class="grid-major-attribute">
                                        <div class="grid-minor-attribute styling-pill theme-minor">
                                            <span data-i18n="attribute">Attrtibute</span>
                                        </div>
                                        <input name="attr_attribute" class="grid-minor-input-attribute styling-pill-input theme-input" type="text" value="" readonly />

                                        <div class="grid-minor-level styling-pill theme-minor">
                                            <span data-i18n="level">Level</span>
                                        </div>
                                        <input name="attr_level" class="grid-minor-input-level styling-pill-input theme-input" type="text" value="" readonly />
                                        
                                        <div class="grid-minor-stat styling-pill theme-minor">
                                            <span data-i18n="stat">Stat</span>
                                        </div>
                                        <input name="attr_stat" class="grid-minor-input-stat styling-pill-input theme-input" type="text" value="" readonly />

                                        <div class="grid-minor-cost styling-pill theme-minor">
                                            <span data-i18n="cost">Cost</span>
                                        </div>
                                        <input name="attr_cost" class="grid-minor-input-cost styling-pill-input theme-input" type="text" value="" readonly />

                                        <div class="grid-minor-points styling-pill theme-minor">
                                            <span data-i18n="points">Points</span>
                                        </div>
                                        <input name="attr_points" class="grid-minor-input-points styling-pill-input theme-input" type="text" value="" readonly />

                                        <div class="grid-minor-description styling-big-pill theme-minor">
                                            <span data-i18n="configuration">Configuration</span>
                                            <textarea name="attr_configuration" class="grid-minor-input-description styling-big-pill-textarea-attribute theme-input" wrap="soft" placeholder="No special configuration" readonly></textarea>
                                        </div>

                                        <div class="grid-minor-enhancements styling-big-pill theme-minor">
                                            <span data-i18n="enhancements">Enhancements</span>
                                            <textarea name="attr_enhancements" class="grid-minor-input-enhancements styling-big-pill-textarea-attribute theme-input" wrap="soft" placeholder="No enhancements defined" readonly></textarea>
                                        </div>

                                        <div class="grid-minor-limiters styling-big-pill theme-minor">
                                            <span data-i18n="limiters">Limiters</span>
                                            <textarea name="attr_limiters" class="grid-minor-input-limiters styling-big-pill-textarea-attribute theme-input" wrap="soft" placeholder="No limiters defined" readonly></textarea>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="attribute-visibility-hide section-break"></div>
                    </fieldset>
                    <fieldset class="repeating_defect">
                        <input name="attr_visibility" class="defect-visibility" type="hidden" value="1" readonly />
                        <div class="defect-visibility-show">
                            <input name="attr_state" class="accordion-defect" type="checkbox" value="1" />
                            <div class="grid-container-collapsible-title-bar theme-border">
                                <div class="grid-minor-title-buttons-left">
                                    <label class="attribute-active-switch">
                                        <input name="attr_active" class="attribute-active-status" type="checkbox" value="1" />
                                        <span class="attribute-active-slider theme-slider"></span>
                                    </label>
                                </div>
                                <div class="grid-minor-section-title theme-title">
                                    <span name="attr_name"></span>
                                    <input name="attr_name" type="hidden" value="Defect Name" />
                                </div>
                                <div class="grid-minor-title-buttons-right">
                                    <button name="act_accordion" class="styling-section-button button-click-animation theme-button" type="action">
                                        <span class="material-icons expand">expand_less</span>
                                    </button>
                                </div>
                            </div>
                            <div class="styling-border theme-border accordion-defect">
                                <div class="styling-background theme-background">
                                    <div class="grid-major-defect">
                                        <div class="grid-minor-defect styling-pill theme-minor">
                                            <span data-i18n="defect">Defect</span>
                                        </div>
                                        <input name="attr_defect" class="grid-minor-input-defect styling-pill-input theme-input" type="text" value="" readonly />
                                        <div class="grid-minor-rank styling-pill theme-minor">
                                            <span data-i18n="rank">Rank</span>
                                        </div>
                                        <input name="attr_rank" class="grid-minor-input-rank styling-pill-input theme-input" type="text" value="" readonly />
                                        <div class="grid-minor-points styling-pill theme-minor">
                                            <span data-i18n="points">Points</span>
                                        </div>
                                        <input name="attr_points" class="grid-minor-input-defectpoints styling-pill-input theme-input" type="text" value="" readonly />
                                        <div class="grid-minor-description styling-big-pill theme-minor">
                                            <span data-i18n="configuration">Configuration</span>
                                            <textarea name="attr_configuration" class="grid-minor-input-description styling-big-pill-textarea-attribute theme-input" wrap="soft" placeholder="No special configuration" readonly></textarea>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="defect-visibility-hide section-break"></div>
                    </fieldset>
                </div>
            </div>
        </div>

        
        <input name="attr_static_skills_show_state" class="show-skills" type="hidden" value="1" />
        <div class="skills-visibility-show">
            <div class="section-break"></div>
            <!-- Skills Title -->
            <input name="attr_static_skills_accordions_state" class="accordion-skills" type="checkbox" value="1" />
            <div class="grid-container-title-bar theme-border">
                <!-- Title Buttons on Left -->
                <div class="grid-minor-title-buttons-left">
                    <button name="act_static_skills_uitoggle_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">checklist</span>
                    </button>
                </div>
                <!-- Title -->
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="skills">Skills</span>
                </div>
                <!-- Title Buttons on Right -->
                <div class="grid-minor-title-buttons-right">
                    <button name="act_static_skills_uiselect_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">auto_stories</span>
                    </button>
                    <button name="act_static_skills_edit_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">edit</span>
                    </button>
                    <button name="act_static_skills_accordions_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                    <input name="attr_static_skills_accordions_state" type="hidden" value="1" />
                </div>
            </div>
            <div class="styling-border theme-border">
                <div class="container-skills styling-background theme-background">
                    <div class="grid-major-skills-uihud">
                        <div class="grid-minor-skills-attribute styling-pill theme-major">
                            <span data-i18n="skills-attribute">Skills Attribute</span>
                        </div>
                        <input name="attr_static_skills_attribute_name" class="grid-minor-input-skillsattribute styling-long-pill-input theme-input-major" type="text" value="" readonly />
                        
                        <div class="grid-minor-skills-totalpoints styling-pill theme-major">
                            <span data-i18n="total-points">Total Points</span>
                        </div>
                        <input name="attr_static_skills_points_total" class="grid-minor-input-totalpoints styling-pill-input theme-input-major" type="text" value="" readonly />
                        
                        <div class="grid-minor-skills-remainingpoints styling-pill theme-major">
                            <span data-i18n="remaining">Remaining</span>
                        </div>
                        <input name="attr_static_skills_points_remaining" class="grid-minor-input-remainingpoints styling-pill-input theme-input-major" type="text" value="" readonly />
                    </div>
                    <div class="section-break"></div>
                    <input name="attr_static_skills_visible_id" type="hidden" value="0" readonly />
                    <fieldset class="repeating_skill">
                        <input name="attr_visibility" class="attribute-visibility" type="hidden" value="1" readonly />
                        <div class="attribute-visibility-show">
                            <input name="attr_state" class="accordion-attribute" type="checkbox" value="1" />
                            <div class="grid-container-collapsible-title-bar theme-border">
                                <div class="grid-minor-title-buttons-left">
                                    <label class="skills-active-switch">
                                        <input name="attr_active" class="skills-active-status" type="checkbox" value="1" />
                                        <span class="skills-active-slider theme-slider"></span>
                                    </label>
                                </div>
                                <div class="grid-minor-section-title theme-title">
                                    <span name="attr_skill"></span>
                                    <input name="attr_skill" type="hidden" value="Skill Name" />
                                </div>
                                <div class="grid-minor-title-buttons-right">
                                    <button name="act_accordion" class="styling-section-button button-click-animation theme-button" type="action">
                                        <span class="material-icons expand">expand_less</span>
                                    </button>
                                </div>
                            </div>
                            <div class="styling-border theme-border accordion-attribute">
                                <div class="styling-background theme-background">
                                    <div class="grid-major-skill">
                                        <!--
                                        <div class="grid-minor-skill styling-pill theme-minor">
                                            <span data-i18n="skill">Skill</span>
                                        </div>
                                        <input name="attr_skill" class="grid-minor-input-skill styling-pill-input theme-input" type="text" value="" readonly />
                                        -->
                                        <div class="grid-minor-rank styling-pill theme-minor">
                                            <span data-i18n="rank">Rank</span>
                                        </div>
                                        <input name="attr_rank" class="grid-minor-input-skillrank styling-pill-input theme-input" type="text" value="" readonly />
                                        
                                        <div class="grid-minor-skillstat styling-pill theme-minor">
                                            <span data-i18n="stat">Stat</span>
                                        </div>
                                        <input name="attr_stat" class="grid-minor-input-skillstat styling-pill-input theme-input" type="text" value="" readonly />

                                        <div class="grid-minor-skillcost styling-pill theme-minor">
                                            <span data-i18n="cost">Cost</span>
                                        </div>
                                        <input name="attr_cost" class="grid-minor-input-skillcost styling-pill-input theme-input" type="text" value="" readonly />

                                        <div class="grid-minor-skillpoints styling-pill theme-minor">
                                            <span data-i18n="points">Points</span>
                                        </div>
                                        <input name="attr_points" class="grid-minor-input-skillpoints styling-pill-input theme-input" type="text" value="" readonly />

                                        <div class="grid-minor-specializations styling-big-pill theme-minor">
                                            <span data-i18n="specializations">specializations</span>
                                            <textarea name="attr_specializations" class="grid-minor-input-specializations styling-big-pill-textarea-specializations theme-input" wrap="soft" placeholder="No special configuration" readonly></textarea>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="skills-visibility-hide section-break"></div>
                    </fieldset>
                </div>
            </div>
        </div>
        <div class="section-break"></div>
        <div>
            <!-- Journal Title -->
            <input name="attr_static_journal_accordion_state" class="accordion-journal" type="checkbox" value="1" />
            <div class="grid-container-collapsible-title-bar theme-border">
                <!-- Title Buttons on Left -->
                <!-- Title -->
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="journal">Journal</span>
                </div>
                <!-- Title Buttons on Right -->
                <div class="grid-minor-title-buttons-right">
                    <button name="act_static_journal_save_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">save</span>
                    </button>
                    <button name="act_static_journal_select_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">auto_stories</span>
                    </button>
                    <button name="act_static_journal_edit_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">edit</span>
                    </button>
                    <button name="act_static_journal_accordion_button" class="styling-section-button accordion-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                    <input name="static_journal_accordion_state" type="hidden" value="1" />
                </div>
            </div>
            <div class="styling-border theme-border accordion-journal">
                <div class="container-journal styling-background theme-background">
                    <input name="attr_static_journal_visible_id" type="hidden" value="0" readonly />
                    <div class="grid-major-journal">
                        <div class="grid-minor-journal-page styling-pill theme-major">
                            <span data-i18n="page">Page</span>
                        </div>
                        <input name="attr_static_journal_page_number" class="grid-minor-input-page styling-pill-input theme-input-major" type="text" value="1" readonly />
                        <div class="grid-minor-journal-title styling-pill theme-major">
                            <span data-i18n="title">Title</span>
                        </div>
                        <input name="attr_static_journal_title_name" class="grid-minor-input-title styling-long-pill-input theme-input-major" type="text" value="Default Journal Entry" readonly />
                        <textarea name="attr_static_journal_page_entry" class="grid-minor-input-entry styling-big-pill-textarea-journal theme-input-major" placeholder="Enter text here" wrap="soft"></textarea>
                    </div>
                </div>
            </div>
        </div>
    </div>
<!--// GM SHEET //-->
    <div class="charactersheet-gm">
        <div>
            <!-- GM Title -->
            <input name="attr_static_rules_accordion_state" class="accordion-rules" type="checkbox" value="1" />
            <div class="grid-container-title-bar theme-border">
                <div class="grid-minor-section-title theme-title">
                    <span data-i18n="rules">Rules</span>
                </div>
                <!-- Title Buttons -->
                <div class="grid-minor-title-buttons-right">
                    <!--
                    <button name="act_static_gmscreen_edit_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons">edit</span>
                    </button>
                    -->
                    <button name="act_static_rules_accordion_button" class="styling-section-button button-click-animation theme-button" type="action">
                        <span class="material-icons expand">expand_less</span>
                    </button>
                </div>
            </div>
            <div class="styling-border theme-border">
                <div class="styling-background theme-background">
                    <div class="grid-major-rules-top">
                        <!-- Screen Top-Left -->
                        <div class="grid-minor-pill-spacer-1 gm-logo-spacer styling-pill">
                            <span>&nbsp;</span>
                        </div>
                        <div class="grid-minor-pill-spacer-2 gm-logo-spacer styling-pill">
                            <span>&nbsp;</span>
                        </div>
                        <div class="grid-minor-pill-spacer-3 gm-logo-spacer styling-pill">
                            <span>&nbsp;</span>
                        </div>
                        <!-- Screen Top-Center -->
                        <div class="grid-minor-rules-rulebook styling-big-pill theme-major">
                            <span data-i18n="rulebook">Rule Book</span>
                            <select name="attr_static_rules_base_default" class="grid-minor-input-rulebook styling-big-pill-select theme-input-major">
                                <option value="besm">BESM</option>
                                <option value="besmx">BESM Extras</option>
                                <option value="absolutepower">Absolute Power</option>
                                <option value="tristatcore">Tri-Stat Core</option>
                            </select>
                        </div>
                        
                        <div class="grid-minor-screen-logo">&nbsp;</div>
                        <!-- Screen Top-Right -->
                        <div class="grid-minor-pill-spacer-4 gm-logo-spacer styling-pill">
                            <span>&nbsp;</span>
                        </div>
                        <div class="grid-minor-pill-spacer-5 gm-logo-spacer styling-pill">
                            <span>&nbsp;</span>
                        </div>
                        <div class="grid-minor-pill-spacer-6 gm-logo-spacer styling-pill">
                            <span>&nbsp;</span>
                        </div>
                    </div>
                    <input name="attr_static_rules_accordion_state" class="accordion-screen" type="checkbox" value="1" />
                    <div class="grid-major-rules-bottom accordion-screen">
                        <div class="grid-minor-optionalrules-title styling-pill-title theme-major">
                            <span data-i18n="optional-rules">Optional Rules</span>
                        </div>
                        
                        <div class="grid-minor-damage-header styling-pill-title theme-major">
                            <span data-i18n="damage">Damage</span>
                        </div>
                        <div class="grid-minor-rules-shockvalue styling-pill theme-minor">
                            <span data-i18n="shock-value">Shock Value</span>
                        </div>
                        <div class="grid-minor-shockvalue-state grid-minor-justify-end">
                            <input name="attr_rules_optional_shockvalue_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_shockvalue_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_shockvalue_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_shockvalue_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-knockout styling-pill theme-minor">
                            <span data-i18n="knockout">Knockout</span>
                        </div>
                        <div class="grid-minor-knockout-state grid-minor-justify-end">
                            <input name="attr_rules_optional_knockout_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_knockout_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_knockout_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_knockout_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-seriousinjury styling-pill theme-minor">
                            <span data-i18n="serious-injury">Serious Injury</span>
                        </div>
                        <div class="grid-minor-seriousinjury-state grid-minor-justify-end">
                            <input name="attr_rules_optional_seriousinjury_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_seriousinjury_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_seriousinjury_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_seriousinjury_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-variable styling-pill theme-minor">
                            <span data-i18n="variable">Variable</span>
                        </div>
                        <div class="grid-minor-input-variable grid-minor-justify-end">
                            <select name="attr_rules_optional_variable_status" class="styling-pill-select theme-input-minor">
                                <option value="fixed">Fixed Value</option>
                                <option disabled class="option-group">Damange Multiplier</option>
                                <option value="mos-dm">Margin of Success</option>
                                <option value="attackroll-dm">Attack Roll</option>
                                <option value="damageroll-dm">Damage Roll</option>
                                <option disabled class="option-group">Total Damange</option>
                                <option value="mos-td">Margin of Success</option>
                                <option value="attackroll-td">Attack Roll</option>
                                <option value="damageroll-td">Damage Roll</option>
                            </select>
                        </div>

                        <div class="grid-minor-critical-header styling-pill-title theme-major">
                            <span data-i18n="critical">Critical</span>
                        </div>
                        <div class="grid-minor-rules-criticalhits styling-pill theme-minor">
                            <span data-i18n="hits">Hits</span>
                        </div>
                        <div class="grid-minor-input-criticalhits grid-minor-justify-end">
                            <select name="attr_rules_optional_criticalhits_status" class="styling-pill-select theme-input-minor">
                                <option value="none">None</option>
                                <option value="mos">Margin of Success</option>
                                <option value="natural12">Natural 12</option>
                            </select>
                        </div>
                        <div class="grid-minor-rules-criticalfailures styling-pill theme-minor">
                            <span data-i18n="failures">Failures</span>
                        </div>
                        <div class="grid-minor-input-criticalfailures grid-minor-justify-end">
                            <select name="attr_rules_optional_criticalfailures_status" class="styling-pill-select theme-input-minor">
                                <option value="none">None</option>
                                <option value="mos">Margin of Success</option>
                                <option value="natural2">Natural 2</option>
                            </select>
                        </div>

                        <div class="grid-minor-rolls-header styling-pill-title theme-major">
                            <span data-i18n="rolls">Rolls</span>
                        </div>
                        <div class="grid-minor-rules-dice styling-pill theme-minor">
                            <span data-i18n="dice">Dice</span>
                        </div>
                        <div class="grid-minor-input-dice grid-minor-justify-end">
                            <select name="attr_rules_optional_dice_status" class="styling-pill-select theme-input-minor">
                                <option value="normal">Normal</option>
                                <option value="spillover">Spillover</option>
                                <option value="rerolls">Rerolls</option>
                                <option value="exceed">Exceed Two Dice</option>
                            </select>
                        </div>
                        <div class="grid-minor-rules-mos styling-pill theme-minor">
                            <span data-i18n="show-margin-of-success">Show Margin of Success</span>
                        </div>
                        <div class="grid-minor-mos-state grid-minor-justify-end">
                            <input name="attr_rules_optional_mos_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_mos_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_mos_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_mos_icon" type="hidden" value="_" />
                            </button>
                        </div>

                        <div class="grid-minor-combat-header styling-pill-title theme-major">
                            <span data-i18n="combat">Combat</span>
                        </div>
                        <div class="grid-minor-rules-maneuvers styling-pill theme-minor">
                            <span data-i18n="combat-maneuvers">Combat Maneuvers</span>
                        </div>
                        <div class="grid-minor-maneuvers-state grid-minor-justify-end">
                            <input name="attr_rules_optional_maneuvers_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_maneuvers_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_maneuvers_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_maneuvers_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-extradamage styling-pill theme-minor">
                            <span data-i18n="extra-ranged-damage">Extra Ranged Damage</span>
                        </div>
                        <div class="grid-minor-extradamage-state grid-minor-justify-end">
                            <input name="attr_rules_optional_extradamage_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_extradamage_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_extradamage_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_extradamage_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-knockback styling-pill theme-minor">
                            <span data-i18n="knockback">Knockback</span>
                        </div>
                        <div class="grid-minor-knockback-state grid-minor-justify-end">
                            <input name="attr_rules_optional_knockback_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_knockback_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_knockback_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_knockback_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-movementpenalties styling-pill theme-minor">
                            <span data-i18n="movement-penalties">Movement Penalties</span>
                        </div>
                        <div class="grid-minor-movementpenalties-state grid-minor-justify-end">
                            <input name="attr_rules_optional_movementpenalties_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_movementpenalties_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_movementpenalties_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_movementpenalties_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-rangepenalties styling-pill theme-minor">
                            <span data-i18n="range-penalties">Range Penalties</span>
                        </div>
                        <div class="grid-minor-rangepenalties-state grid-minor-justify-end">
                            <input name="attr_rules_optional_rangepenalties_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_rangepenalties_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_rangepenalties_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_rangepenalties_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-spreadinitiative styling-pill theme-minor">
                            <span data-i18n="spread-initiative">Dynamic Initiative</span>
                        </div>
                        <div class="grid-minor-spreadinitiative-state grid-minor-justify-end">
                            <input name="attr_rules_optional_spreadinitiative_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_spreadinitiative_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_spreadinitiative_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_spreadinitiative_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-shield styling-pill theme-minor">
                            <span data-i18n="strike-shield">Striking a Shield</span>
                        </div>
                        <div class="grid-minor-shield-state grid-minor-justify-end">
                            <input name="attr_rules_optional_shield_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_shield_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_shield_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_shield_icon" type="hidden" value="_" />
                            </button>
                        </div>

                        <div class="grid-minor-skills-header styling-pill-title theme-major">
                            <span data-i18n="skills">Skills</span>
                        </div>
                        <div class="grid-minor-rules-individual styling-pill theme-minor">
                            <span data-i18n="individual-skills">Individual Skills</span>
                        </div>
                        <div class="grid-minor-individual-state grid-minor-justify-end">
                            <input name="attr_rules_optional_individual_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_individual_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_individual_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_individual_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-genre styling-pill theme-minor">
                            <span data-i18n="skill-genre">Skill Genre</span>
                        </div>
                        <div class="grid-minor-input-genre grid-minor-justify-end">
                            <select name="attr_rules_optional_genre_status" class="styling-pill-select theme-input-minor">
                                <option value="0">Multi-Genre</option>
                                <option value="1">Action Adventure</option>
                                <option value="2">Animal Adventures</option>
                                <option value="3">Classic Horror</option>
                                <option value="4">Detective</option>
                                <option value="5">Loony Cartoons</option>
                                <option value="6">Romantic Comedy</option>
                                <option value="7">Slice of Life</option>
                                <option value="8">Spy Thriller</option>
                                <option value="9">Supernatural Occult</option>
                                <option value="10">Eco Fantasy</option>
                                <option value="11">High Fantasy</option>
                                <option value="12">Low Fantasy</option>
                                <option value="13">Urban Fantasy</option>
                                <option value="14">Cyberpunk/Realitypunk</option>
                                <option value="15">Hard SF</option>
                                <option value="16">Mecha Drama</option>
                                <option value="17">Post-Apocalyptic</option>
                                <option value="18">Soft SF</option>
                                <option value="19">Space Opera</option>
                                <option value="20">20th Century War</option>
                                <option value="21">Age of Discovery</option>
                                <option value="22">Age of Pirates</option>
                                <option value="23">Age of Samurai</option>
                                <option value="24">Ancient Mediterranean</option>
                                <option value="25">Industrial Age</option>
                                <option value="26">Middle Ages</option>
                                <option value="27">Steampunk</option>
                                <option value="28">Stone Age</option>
                                <option value="29">Wild West</option>
                            </select>
                        </div>
                        
                        <div class="grid-minor-other-header styling-pill-title theme-major">
                            <span data-i18n="other">Other</span>
                        </div>
                        <div class="grid-minor-rules-enhancedrecovery styling-pill theme-minor">
                            <span data-i18n="enhanced-recovery">Enhanced Recovery</span>
                        </div>
                        <div class="grid-minor-enhancedrecovery-state grid-minor-justify-end">
                            <input name="attr_rules_optional_enhancedrecovery_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_enhancedrecovery_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_enhancedrecovery_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_enhancedrecovery_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-sanity styling-pill theme-minor">
                            <span data-i18n="sanity">Sanity</span>
                        </div>
                        <div class="grid-minor-sanity-state grid-minor-justify-end">
                            <input name="attr_rules_optional_sanity_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_sanity_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_sanity_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_sanity_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-society styling-pill theme-minor">
                            <span data-i18n="society">Society</span>
                        </div>
                        <div class="grid-minor-society-state grid-minor-justify-end">
                            <input name="attr_rules_optional_society_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_optional_society_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_optional_society_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_optional_society_icon" type="hidden" value="_" />
                            </button>
                        </div>

                        <div class="grid-minor-normalize-title styling-pill-title theme-major">
                            <span data-i18n="normalize-rulebooks">Normalize Rulebooks</span>
                        </div>
                        <div class="grid-minor-attributes-header styling-pill-title theme-major">
                            <span data-i18n="attributes">Attributes</span>
                        </div>
                        <div class="grid-minor-rules-expertise styling-pill theme-minor">
                            <span data-i18n="expertise">Expertise</span>
                        </div>
                        <div class="grid-minor-expertise-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_expertise_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_expertise_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_expertise_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_expertise_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-extradefenses styling-pill theme-minor">
                            <span data-i18n="extra-defenses">Extra Defenses</span>
                        </div>
                        <div class="grid-minor-extradefenses-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_extradefenses_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_extradefenses_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_extradefenses_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_extradefenses_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-miniobject styling-pill theme-minor">
                            <span data-i18n="mini-object">Mini Object</span>
                        </div>
                        <div class="grid-minor-miniobject-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_miniobject_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_miniobject_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_miniobject_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_miniobject_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-taunt styling-pill theme-minor">
                            <span data-i18n="taunt">Taunt</span>
                        </div>
                        <div class="grid-minor-taunt-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_taunt_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_taunt_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_taunt_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_taunt_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-combattechnique styling-pill-title theme-minor">
                            <span data-i18n="combat-technique">Combat Technique</span>
                        </div>
                        <div class="grid-minor-rules-deathdodge styling-pill theme-minor">
                            <span data-i18n="death-dodge">Death Dodge</span>
                        </div>
                        <div class="grid-minor-deathdodge-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_deathdodge_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_deathdodge_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_deathdodge_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_deathdodge_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-debilitate styling-pill theme-minor">
                            <span data-i18n="debilitate">Debilitate</span>
                        </div>
                        <div class="grid-minor-debilitate-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_debilitate_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_debilitate_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_debilitate_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_debilitate_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-eknockback styling-pill theme-minor">
                            <span data-i18n="enhanced-knockback">Enhanced Knockback</span>
                        </div>
                        <div class="grid-minor-eknockback-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_eknockback_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_eknockback_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_eknockback_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_eknockback_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-flankdefense styling-pill theme-minor">
                            <span data-i18n="flanking-defense">Flanking Defense</span>
                        </div>
                        <div class="grid-minor-flankdefense-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_flankdefense_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_flankdefense_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_flankdefense_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_flankdefense_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-hardboiled styling-pill theme-minor">
                            <span data-i18n="hardboiled">Hardboiled</span>
                        </div>
                        <div class="grid-minor-hardboiled-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_hardboiled_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_hardboiled_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_hardboiled_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_hardboiled_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-tournament styling-pill theme-minor">
                            <span data-i18n="tournament-encyclopedia">Tournament Encyclopedia</span>
                        </div>
                        <div class="grid-minor-tournament-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_tournament_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_tournament_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_tournament_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_tournament_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-specialmovement styling-pill-title theme-minor">
                            <span data-i18n="special-movement">Special Movement</span>
                        </div>
                        <div class="grid-minor-rules-speedburst styling-pill theme-minor">
                            <span data-i18n="speedburst">Speedburst</span>
                        </div>
                        <div class="grid-minor-speedburst-state grid-minor-justify-end">
                            <input name="attr_rules_attribute_speedburst_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_attribute_speedburst_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_attribute_speedburst_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_attribute_speedburst_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        
                        <div class="grid-minor-enhancements-header styling-pill-title theme-major">
                            <span data-i18n="enhancements">Enhancements</span>
                        </div>
                        <div class="grid-minor-rules-cognition styling-pill theme-minor">
                            <span data-i18n="cognition-p-area">Cognition.Area</span>
                        </div>
                        <div class="grid-minor-cognition-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_cognition_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_cognition_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_cognition_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_cognition_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-sixthsense styling-pill theme-minor">
                            <span data-i18n="sixthsense-p-range">Sixth Sense.Range</span>
                        </div>
                        <div class="grid-minor-sixthsense-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_sixthsense_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_sixthsense_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_sixthsense_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_sixthsense_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-summoncreature styling-pill theme-minor">
                            <span data-i18n="summon-creatures-p-area">Summon Creatures.Area</span>
                        </div>
                        <div class="grid-minor-summoncreature-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_summoncreatures_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_summoncreatures_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_summoncreatures_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_summoncreatures_icon" type="hidden" value="_" />
                            </button>
                        </div>

                        <div class="grid-minor-rules-transfer styling-pill theme-minor">
                            <span data-i18n="transfer-p-area-p-targets">Transfer.Area.Targets</span>
                        </div>
                        <div class="grid-minor-transfer-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_transfer_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_transfer_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_transfer_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_transfer_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-custenhancements-header styling-pill-title theme-major">
                            <span data-i18n="custom-enhancements">Custom Enhancements</span>
                        </div>
                        <div class="grid-minor-rules-absorption styling-pill theme-minor">
                            <span data-i18n="absorption-p-synergistic">Absorption.Synergistic</span>
                        </div>
                        <div class="grid-minor-absorption-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_absorption_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_absorption_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_absorption_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_absorption_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-conversion styling-pill theme-minor">
                            <span data-i18n="conversion-p-escalate">Conversion.Escalate</span>
                        </div>
                        <div class="grid-minor-conversion-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_conversion_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_conversion_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_conversion_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_conversion_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-forcefield styling-pill theme-minor">
                            <span data-i18n="forcefield-p-airtight">Forcefield.Air-tight</span>
                        </div>
                        <div class="grid-minor-forcefield-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_forcefield_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_forcefield_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_forcefield_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_forcefield_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-powerflux styling-pill theme-minor">
                            <span data-i18n="power-flux-p-debuff">Power Flux.Debuff</span>
                        </div>
                        <div class="grid-minor-powerflux-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_powerflux_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_powerflux_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_powerflux_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_powerflux_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-sizechange styling-pill theme-minor">
                            <span data-i18n="size-change-p-modified-shrinking">Size Change.Mod Shrinking</span>
                        </div>
                        <div class="grid-minor-sizechange-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_sizechange_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_sizechange_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_sizechange_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_sizechange_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-teleport styling-pill theme-minor">
                            <span data-i18n="teleport-p-blind">Teleport.Blind</span>
                        </div>
                        <div class="grid-minor-teleport-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_teleport_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_teleport_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_teleport_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_teleport_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-weaponenhancements-header styling-pill-title theme-major">
                            <span data-i18n="weapon-enhancements">Weapon Enhancements</span>
                        </div>
                        <div class="grid-minor-rules-weapon styling-pill theme-minor">
                            <span data-i18n="anemic-c-demoralize-c-lethargy">Anemic, Demoralize, Lethargy</span>
                        </div>
                        <div class="grid-minor-weapon-state grid-minor-justify-end">
                            <input name="attr_rules_enhancement_weapon_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_enhancement_weapon_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_enhancement_weapon_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_enhancement_weapon_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-limiters-header styling-pill-title theme-major">
                            <span data-i18n="limiters">Limiters</span>
                        </div>
                        <div class="grid-minor-rules-timed styling-pill theme-minor">
                            <span data-i18n="timed">Timed</span>
                        </div>
                        <div class="grid-minor-timed-state grid-minor-justify-end">
                            <input name="attr_rules_limiter_timed_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_limiter_timed_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_limiter_timed_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_limiter_timed_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-custlimiters-header styling-pill-title theme-major">
                            <span data-i18n="custom-limiters">Custom Limiters</span>
                        </div>
                        <div class="grid-minor-rules-capped styling-pill theme-minor">
                            <span data-i18n="absorption-p-capped">Absorption.Capped</span>
                        </div>
                        <div class="grid-minor-capped-state grid-minor-justify-end">
                            <input name="attr_rules_limiter_absorption_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_limiter_absorption_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_limiter_absorption_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_limiter_absorption_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-proportionaldamage styling-pill theme-minor">
                            <span data-i18n="merge-p-proportionaldamage">Merge.Proportional Damage</span>
                        </div>
                        <div class="grid-minor-proportionaldamage-state grid-minor-justify-end">
                            <input name="attr_rules_limiter_merge_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_limiter_merge_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_limiter_merge_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_limiter_merge_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-plantcontrol styling-pill theme-minor">
                            <span data-i18n="plantcontrol-p-group-c-species">Plant Control.Group, Species</span>
                        </div>
                        <div class="grid-minor-plantcontrol-state grid-minor-justify-end">
                            <input name="attr_rules_limiter_plantcontrol_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_limiter_plantcontrol_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_limiter_plantcontrol_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_limiter_plantcontrol_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-skillflux styling-pill theme-minor">
                            <span data-i18n="powerflux-p-skillflux">Power Flux.Skill Flux</span>
                        </div>
                        <div class="grid-minor-skillflux-state grid-minor-justify-end">
                            <input name="attr_rules_limiter_powerflux_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_limiter_powerflux_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_limiter_powerflux_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_limiter_powerflux_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-transmute styling-pill theme-minor">
                            <span data-i18n="transmute-p-material-category">Transmute.Material Category</span>
                        </div>
                        <div class="grid-minor-transmute-state grid-minor-justify-end">
                            <input name="attr_rules_limiter_transmute_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_limiter_transmute_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_limiter_transmute_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_limiter_transmute_icon" type="hidden" value="_" />
                            </button>
                        </div>

                        <div class="grid-minor-defects-header styling-pill-title theme-major">
                            <span data-i18n="defects">Defects</span>
                        </div>
                        <div class="grid-minor-rules-nohealing styling-pill theme-minor">
                            <span data-i18n="no-healing">No Healing</span>
                        </div>
                        <div class="grid-minor-nohealing-state grid-minor-justify-end">
                            <input name="attr_rules_defect_nohealing_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_defect_nohealing_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_defect_nohealing_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_defect_nohealing_icon" type="hidden" value="_" />
                            </button>
                        </div>
<!--
                        <div class="grid-minor-homebrew-title styling-pill-title theme-major">
                            <span data-i18n="homebrewa-and-alternate-rules">Homebrew and Alternate Rules</span>
                        </div>
                        <div class="grid-minor-altrules-header styling-pill-title theme-major">
                            <span data-i18n="alternate-rules">Alternate Rules</span>
                        </div>
                        <div class="grid-minor-rules-ammotracking styling-pill theme-minor">
                            <span data-i18n="ammo-tracking">Ammo Tracking</span>
                        </div>
                        <div class="grid-minor-ammotracking-state grid-minor-justify-end">
                            <input name="attr_rules_homebrew_ammotracking_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_homebrew_ammotracking_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_homebrew_ammotracking_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_homebrew_ammotracking_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-depletereserve styling-pill theme-minor">
                            <span data-i18n="easy-deplete">Easy Deplete</span>
                        </div>
                        <div class="grid-minor-depletereserve-state grid-minor-justify-end">
                            <input name="attr_rules_homebrew_depletereserve_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_homebrew_depletereserve_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_homebrew_depletereserve_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_homebrew_depletereserve_icon" type="hidden" value="_" />
                            </button>
                        </div>

                        <div class="grid-minor-altlimiters-header styling-pill-title theme-major">
                            <span data-i18n="homebrew-limiters">Homebrew Limiters</span>
                        </div>
                        <div class="grid-minor-rules-disperse styling-pill theme-minor">
                            <span data-i18n="armor-p-disperse">Armor.Disperse</span>
                        </div>
                        <div class="grid-minor-disperse-state grid-minor-justify-end">
                            <input name="attr_rules_homebrew_disperse_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_homebrew_disperse_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_homebrew_disperse_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_homebrew_disperse_icon" type="hidden" value="_" />
                            </button>
                        </div>
                        <div class="grid-minor-rules-specificlimiter styling-pill theme-minor">
                            <span data-i18n="forccefield-p-specific">Forcefield.Specific</span>
                        </div>
                        <div class="grid-minor-specificlimiter-state grid-minor-justify-end">
                            <input name="attr_rules_homebrew_specificlimiter_status" class="styling-rule-checkbox" type="checkbox" value="1" />
                            <button name="act_rules_homebrew_specificlimiter_button" class="styling-rule-button" type="action">
                                <span name="attr_rules_homebrew_specificlimiter_icon" class="styling-rule-icon font-pictos"></span>
                                <input name="attr_rules_homebrew_specificlimiter_icon" type="hidden" value="_" />
                            </button>
                        </div>
-->
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<!---->
<div style="display:none; visibility: hidden">
    <!-- React Buttons -->
    <button type="action" name="act_react_button_roll_defense"></button>
    <button type="action" name="act_react_button_roll_skill"></button>
    <button type="action" name="act_react_button_roll_stat"></button>
    <!-- Default Values -->
    <input type="hidden" name="attr_character_default_value_points" value="" />
</div>
<!-- Roll Templates -->
<rolltemplate class="sheet-rolltemplate-rolls">
    <div class="sheet-rt-outer {{color}}">
        <div class="sheet-rt-header">
            <div class="sheet-rt-title {{color}}"><span>{{title}}</span></div>
            {{#emote}}
            <div class="sheet-rt-emote">
                <span>{{emote}}</span>
            </div>
            {{/emote}}
        </div>
        <!-- BODY -->
        <div class="sheet-rt-body">
            {{#twodsix}}
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Dice Rolled</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll sheet-rt-d6font">
                    {{computed::dice0}}
                    {{computed::dice1}}
                    {{computed::dice2}}
                    {{computed::dice3}}
                    {{computed::dice4}}
                    {{computed::dice5}}
                    {{computed::dice6}}
                    {{computed::dice7}}
                    {{computed::dice8}}
                    {{computed::dice9}}
                    {{computed::dice10}}
                    {{computed::dice11}}
                </div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Total</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{computed::total}}</div>
            </div>
            {{/twodsix}} {{#attack}}
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Dice Rolled</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll sheet-rt-d6font">
                    {{computed::dice0}}
                    {{computed::dice1}}
                    {{computed::dice2}}
                    {{computed::dice3}}
                    {{computed::dice4}}
                    {{computed::dice5}}
                    {{computed::dice6}}
                    {{computed::dice7}}
                    {{computed::dice8}}
                    {{computed::dice9}}
                    {{computed::dice10}}
                    {{computed::dice11}}
                </div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Base</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{base}}</div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Total</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{computed::total}}</div>
            </div>
            {{/attack}} {{#initiative}}
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Dice Rolled</div>
                <!--<div class="sheet-rt-value sheet-sheet-mouseover-hideroll sheet-rt-d6font">{{computed::dice0}}{{computed::dice1}}{{computed::dice2}}{{computed::dice3}}</div>-->
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll sheet-rt-d6font">
                    {{computed::dice0}}
                    {{computed::dice1}}
                    {{computed::dice2}}
                    {{computed::dice3}}
                    {{computed::dice4}}
                    {{computed::dice5}}
                    {{computed::dice6}}
                    {{computed::dice7}}
                    {{computed::dice8}}
                    {{computed::dice9}}
                    {{computed::dice10}}
                    {{computed::dice11}}
                </div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Base</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{base}}</div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Total</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{computed::total}}</div>
            </div>
            {{/initiative}} {{#stat}}
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Dice Rolled</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll sheet-rt-d6font">
                    {{computed::dice0}}
                    {{computed::dice1}}
                    {{computed::dice2}}
                    {{computed::dice3}}
                    {{computed::dice4}}
                    {{computed::dice5}}
                    {{computed::dice6}}
                    {{computed::dice7}}
                    {{computed::dice8}}
                    {{computed::dice9}}
                    {{computed::dice10}}
                    {{computed::dice11}}
                </div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Base</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{base}}</div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Total</div>
                <div class="sheet-rt-value sheet-sheet-mouseover-hideroll">{{computed::total}}</div>
            </div>
            {{/stat}}
        </div>
    </div>
    {{#react}}
    <div class="sheet-rt-react-outer {{color-react}}">
        <div class="sheet-rt-react-header">
            <span>{{reactheader}}</span>
        </div>
        <div class="sheet-rt-row">
            <div class="sheet-rt-react-title">
                {{reacttitle}}
            </div>
            {{#react-button}}
            <div class="sheet-rt-react-button {{color-react}}">
                [{{reactlabel}}](~selected|{{reactlink}}||{{computed::reactdata}})
            </div>
            {{/react-button}} {{^react-button}}
            <div class="sheet-rt-react-tn {{color-react}}">
                {{react-tn}}
            </div>
            {{/react-button}}
        </div>
    </div>
    {{/react}}
</rolltemplate>

<rolltemplate class="sheet-rolltemplate-rolls-result">
    <div class="sheet-rt-result-outer {{result-spacer}} {{color}}">
        {{^resume}}
        <div class="sheet-header-spacer"></div>
        <div class="sheet-rt-header">
            <div class="sheet-rt-title {{color}}">
                {{result-header}}
            </div>
            {{#emote}}
            <div class="sheet-rt-emote">
                <span>{{emote}}</span>
            </div>
            {{/emote}}
        </div>
        {{/resume}}
        <div class="sheet-rt-body">
            {{#autofire}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Autofire Hits</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{autofire}}</div>
            </div>
            {{/autofire}} {{^defended}} {{#damage}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{stun}}Damage{{#autofire}} per Hit{{/autofire}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">+{{damage}}</div>
            </div>
            {{/damage}} {{#penetrating}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Penetrating (armor)</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{penetrating}}</div>
            </div>
            {{/penetrating}} {{#piercing}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Piercing (forcefield)</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{piercing}}</div>
            </div>
            {{/piercing}} {{/defended}} {{#forcefield0key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{forcefield0key}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{forcefield0value}}</div>
            </div>
            {{/forcefield0key}} {{#shield}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{shieldname}} Stopped</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{shield}}</div>
            </div>
            {{/shield}} {{#armor0key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{armor0key}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{armor0value}}</div>
            </div>
            {{/armor0key}} {{#armor1key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{armor1key}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{armor1value}}</div>
            </div>
            {{/armor1key}} {{#armor2key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{armor2key}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{armor2value}}</div>
            </div>
            {{/armor2key}} {{#mindshield}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{mindshieldname}} Stopped</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{mindshield}}</div>
            </div>
            {{/mindshield}} {{#absorption0key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{absorption0key}} Absorbed</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{absorption0value}}</div>
            </div>
            {{/absorption0key}} {{#absorption1key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{absorption1key}} Absorbed</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{absorption1value}}</div>
            </div>
            {{/absorption1key}} {{#absorption2key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{absorption2key}} Absorbed</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{absorption2value}}</div>
            </div>
            {{/absorption2key}} {{#absorption3key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{absorption3key}} Absorbed</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">-{{absorption3value}}</div>
            </div>
            {{/absorption3key}} {{#conversion0key}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{conversion0key}} Converted</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{conversion0value}}</div>
            </div>
            {{/conversion0key}} {{#continuing}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Continuing Damage (+{{continuing}})</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{continuingrounds}} Rounds</div>
            </div>
            {{/continuing}} {{#blight}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Blight!</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">TN {{blight}}</div>
            </div>
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Blight Applies To</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{blightappliesto}}</div>
            </div>
            {{/blight}} {{#statroll}}
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Stat Roll Base</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{rollbase}}</div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Stat Roll</div>
                <div class="sheet-rt-value">{{statroll}}</div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Stat Roll Total</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{rolltotal}}</div>
            </div>
            <div class="sheet-rt-grid">
                <div class="sheet-rt-key">Stat Roll Result</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{#^rollLess() rolltotal target}}Success{{/^rollLess() rolltotal target}}{{#rollLess() rolltotal target}}Failed{{/rollLess() rolltotal target}}</div>
            </div>
            {{/statroll}} {{^blight}} {{#seriouswound}}
            <div class="sheet-result-fail sheet-rt-grid center">
                <span>Seriously Wounded!!!</span>
            </div>
            {{/seriouswound}} {{#damagetaken}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Damage Taken</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{damagetaken}}</div>
            </div>
            {{#catastrophictn}} 
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">Catastrophic Damage!!!</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">TN {{catastrophictn}}</div>
            </div>
            {{/catastrophictn}} {{/damagetaken}} {{#shocktn}}
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">System Shock</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">TN {{shocktn}}</div>
            </div>
            {{/shocktn}} {{/blight}} {{#shock}} 
            <div class="sheet-result-fail sheet-rt-grid">
                <div class="sheet-rt-key">{{shockoutcome}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{shockrounds}}</div>
            </div>
            {{/shock}} {{#catastrophic}} 
            <div class="besm-emote">
                <span>{{catastrophicoutcome}}</span>
            </div>
            {{/catastrophic}} {{#reactvalue1}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey1}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue1}}</div>
            </div>
            {{/reactvalue1}} {{#reactvalue2}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey2}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue2}}</div>
            </div>
            {{/reactvalue2}} {{#reactvalue3}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey3}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue3}}</div>
            </div>
            {{/reactvalue3}} {{#reactvalue4}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey4}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue4}}</div>
            </div>
            {{/reactvalue4}} {{#reactvalue5}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey5}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue5}}</div>
            </div>
            {{/reactvalue5}} {{#reactvalue6}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey6}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue6}}</div>
            </div>
            {{/reactvalue6}} {{#reactvalue7}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey7}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue7}}</div>
            </div>
            {{/reactvalue7}} {{#reactvalue8}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey8}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue8}}</div>
            </div>
            {{/reactvalue8}} {{#reactvalue9}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey9}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue9}}</div>
            </div>
            {{/reactvalue9}} {{#reactvalue10}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey10}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue10}}</div>
            </div>
            {{/reactvalue10}} {{#reactvalue11}}
            <div class="sheet-result-{{#defended}}succeed{{/defended}}{{^defended}}fail{{/defended}} sheet-rt-grid">
                <div class="sheet-rt-key">{{reactkey11}}</div>
                <div class="sheet-rt-value sheet-mouseover-hideroll">{{reactvalue11}}</div>
            </div>
            {{/reactvalue11}}
        </div>
    </div>
    <div class="sheet-footer-spacer"></div>
    {{#react}}
    <div class="sheet-rt-react-outer {{color}}">
        <div class="sheet-rt-react-header">
            <span>Reactive Rolls:</span>
        </div>
        <div class="sheet-rt-row">
            <div class="sheet-rt-react-title">
                {{reacttitle}}
            </div>
            <div class="sheet-rt-react-button">
                [{{reactlabel}}](~selected|{{reactlink}}||{{computed::reactdata}})
            </div>
        </div>
    </div>
    {{/react}}
</rolltemplate>
<rolltemplate class="sheet-rolltemplate-display-help">
    <div>
        [Sheet Documentation](https://wiki.roll20.net/Big_Eyes_Small_Mouth_4E_-_Dyskami_Authorized)
    </div>
</rolltemplate>
<!-- Sheet Workers -->
<script type="text/worker">
    /* Global Variables */
    const all_attributes = ['absorption','alternate form','alternate identity','armor','attack mastery','augmented','capacity','change state','cognition','combat technique','companion','connected','control environment','conversion','data access','defense mastery','dimension walk','dynamic powers','elasticity','enemy attack','enemy defenses','energized','exorcism','expertise','extra actions','extra arms','extra defenses','features','flight','force field','ground speed','healing','heightened awareness','heightened senses','illusion','immovable','immunity','immutable','inspire','jumping','massive damage','melee attack','melee defense','merge','metamorphosis','mimic','mind control','mind shield','minions','mulligan','nullify','plant control','pocket dimension','portal','power flux','power variation','projection','ranged attack','ranged defense','regeneration','reincarnation','resilient','sensory block','sixth sense','size change','skill group','skills','social mastery','spaceflight','special movement','summon creatures','supersense','superspeed','superstrength','swarm','taunt','telekinesis','telepathy','teleport','tough','transfer','transmute','tunneling','unaffected','unassailable','undetectable',/*'unique attribute',*/'unknown power','water speed','wealth','weapon'];
    const all_conditions = ['anemic','blinded','contagious','continuing','dead','demoralized','drained','incapacitated','incurable','irritant','lethargic','prone','serious injury','stunned','tangled','unconscious'];
    const all_defects = ['achilles heel','awkward size','bane','blind fury','conditional ownership','confined','cursed','demure','easily distracted','fragile','hounded','impaired manipulation','impaired speech','inept attack','inept defense','involuntary change','ism','magnet','marked','nemesis','nightmares','no healing','obligated','phobia','physical impairment','red tape','reduced damage','sensory impairment','shortcoming','significant other','skeleton in the closet','social fault','special requirement','unappealing','unique defect','unsettled','vulnerability','wanted','weak point'];
    const all_stats = ['body','mind','soul'];
    const all_optional_rules = ['optional_enhancedrecovery','optional_maneuvers','optional_extradamage','optional_individual','optional_knockback','optional_mos','optional_movementpenalties','optional_rangepenalties','optional_sanity','optional_shield','optional_society','optional_spreadinitiative'];
    const all_normalizations = ['attribute_deathdodge','attribute_debilitate','attribute_expertise','attribute_extradefenses','attribute_flankdefense','attribute_miniobject','attribute_speedburst','attribute_taunt','attribute_tournament','defect_nohealing','enhancement_absorption','enhancement_cognition','enhancement_conversion','enhancement_forcefield','enhancement_powerflux','enhancement_sixthsense','enhancement_sizechange','enhancement_summoncreature','enhancement_teleport','enhancement_transfer','enhancement_weapon','limiter_absorption','limiter_merge','limiter_plantcontrol','limiter_powerflux','limiter_timed','limiter_transmute'];
    const all_homebrew_rules = ['homebrew_ammotracking','homebrew_depletereserve','homebrew_disperse','homebrew_specificlimiter'];
    const base_attributes = ['absorption','alternate form','alternate identity','armor','attack mastery','augmented','capacity','change state','cognition','combat technique','companion','connected','control environment','conversion','data access','defense mastery','dimension walk','elasticity','enemy attack','enemy defense','energized','exorcism','extra actions','extra arms','features','flight','force field','ground speed','healing','heightened awareness','heightened senses','illusion','immunity','immutable','inspire','jumping','massive damage','melee attack','melee defense','merge','metamorphosis','mimic','mind control','mind shield','minions','mulligan','nullify','plant control','pocket dimension','portal','projection','ranged attack','ranged defense','regeneration','reincarnation','resilient','sensory block','sixth sense','size change','skill group','skills','spaceflight','special movement','summon creatures','supersense','superspeed','superstrength','swarm','telekinesis','telepathy','teleport','tough','transfer','transmute','tunneling','unaffected','undetectable',/*'unique attribute',*/'unknown power','water speed','wealth','weapon'];
    const tsc_ap_attributes = ['expertise','taunt'];
    const besmx_attributes = ['extra defenses'];
    const kb_attributes = ['immovable'];
    const dbs = ['attrdb','conditiondb','defectdb','groupdb','journaldb','statsdb'];
    const all_skills = ['acrobatics','animal training','architecture','area knowledge','artisan','biological sciences','boating','burglary','business','civilisation','climbing','computers','controlled breathing','cultural arts','demolitions','disguise','domestic arts','driving','engineering','environmental sciences','electronics','empathy','etiquette','forgery','gaming','interrogation','intimidation','languages','law','leadership','listening','mechanics','medical','military sciences','naturopathy','navigation','occult','occupation','performing arts','persuasion','physical sciences','piloting','poisons','police sciences','power lifting','religion','riding','search','seduction','sleight of hand','social sciences','sports','stealth','street sense','survival','swimming','urban tracking','visual arts','wilderness tracking','writing'];
    const all_skill_groups = ['academic','adventuring','artistic','business','detective','domestic','military','occupation','scientific','social','street','technical'];
    const normalize_attributes = {
        'attribute_expertise':'expertise',
        'attribute_extradefenses':'extra defenses',
        'optional_knockback':'immovable',
        'optional_sanity':'unassailable',
        'optional_society':'social mastery',
        'attribute_taunt':'taunt'
    };
    const standard_enhancements = {
        //'cognition':['area'],
        'control environment':['area','duration','range'],
        'dimension walk':['area'],
        'dynamic powers':['area','duration','range','targets'],
        'exorcism':['area','range','targets'],
        'force field':['area','duration','range'],
        'healing':['area','range','targets'],
        'illusion':['area','duration','range','targets'],
        'merge':['duration'],
        'metamorphosis':['area','duration','range','targets'],
        'mimic':['duration','range'],
        'mind control':['area','duration','range','targets'],
        'nullify':['area','duration','range','targets'],
        'plant control':['duration'],
        'portal':['area','duration','range','targets'],
        'power flux':['area','duration','range','targets'],
        'power variation':['area','duration','range','targets'],
        'projection':['area','duration','range'],
        'sensory block':['area','duration','range'],
        'sixth sense':['area'],//,'range'],
        'size change':['duration'],
        'summon creatures':['duration'],//['area','duration'],
        'telekinesis':['area','range'],
        'telepathy':['area','range','targets'],
        'teleport':['area','range','targets'],
        'transfer':['duration','range'],//['area','duration','range','targets'],
        'transmute':['duration','range','targets'],
        'unique attribute':['area','duration','range','targets'],
        'unknown power':['area','duration','range','targets'],
        'weapon':['area','duration','range'],
        'default':[]
    };
    const base_custom_enhancements = {
        'change state':['quick change'],
        'connected':['significant power','great power'],
        'dynamic powers':['major category','primal category'],
        'force field':['blocks incorporeal','blocks teleport','field-penetrating','offensive','regenerating'],
        'illusion':['extra sense','multiple illusions'],
        'inspire':['galvanize'],
        'metamorphosis':['multiform','any form'],
        'mimic':['all powers'],
        'nullify':['multiple attributes'],
        'power flux':['major category','primal category'],
        'projection':['few projections','several projections'],
        'reincarnation':['difficult to stop'],
        'resilient':['complete'],
        'size change':['both ways'],
        'summon creatures':['supernatural','dimensional'],
        'transfer':['all attributes'],
        'transmute':['resize','gaseous'],
        'unaffected':['all weapons','several attributes','many attributes','all attributes'],
        'weapon':['accurate','aura','autofire','blight','contact','contagious','continuing','drain','enervation','flare','flexible','helper','homing','incapacitating','inconspicuous','incurable','indirect','insidious','irritant','linked','multidimensional','muscle','penetrating','piercing','psychic','quake','reach','selective','spreading','stun','tangle','targeted','trap',/*'unique',*/'vampiric'],
        'default':[]
    };
    const base_weapon_enhancements = ['accurate','aura','autofire','blight','contact','contagious','continuing','drain','enervation','flare','flexible','helper','homing','incapacitating','inconspicuous','incurable','indirect','insidious','irritant','linked','multidimensional','muscle','penetrating','piercing','psychic','quake','reach','selective','spreading','stun','tangle','targeted','trap',/*'unique',*/'vampiric'];
    const tsc_ap_enhancements = {
        'absorption':['synergistic'],
        'conversion':['escalate'],
        'force field':['air-tight'],
        'power flux':['debuff'],
        'size change':['modified shrinking'],
        'teleport':['blind'],
        'default':[]
    };
    const enhancement_ranks = {
        'absorption':{'synergistic':{rank:1}},
        'alternate form':{},
        'alternate identity':{},
        'armor':{},
        'attack mastery':{},
        'augmented':{},
        'capacity':{},
        'change state':{'quick change':{rank:1}},
        'cognition':{},
        'combat technique':{},
        'companion':{},
        'connected':{'significant power':{rank:1},'great power':{rank:2}},
        'control environment':{},
        'conversion':{'escalate':{rank:2}},
        'data access':{},
        'defense mastery':{},
        'dimension walk':{},
        'dynamic powers':{'major category':{rank:1},'primal category':{rank:2}},
        'elasticity':{},
        'enemy attack':{},
        'enemy defense':{},
        'energized':{},
        'exorcism':{},
        'expertise':{},
        'extra actions':{},
        'extra defenses':{},
        'extra arms':{},
        'features':{},
        'flight':{},
        'force field':{'air-tight':{rank:1},'blocks incorporeal':{rank:1},'blocks teleport':{rank:1},'field-penetrating':{rank:1},'offensive':{rank:1},'regenerating':{rank:1}},
        'ground speed':{},
        'healing':{},
        'heightened awareness':{},
        'heightened senses':{},
        'illusion':{},//{'extra sense':{rank:1},'multiple illusions':{rank:1}},
        'immovable':{},
        'immunity':{},
        'immutable':{},
        'inspire':{'galvanize':{rank:2}},
        'jumping':{},
        'massive damage':{},
        'melee attack':{},
        'melee defense':{},
        'merge':{},
        'metamorphosis':{'multiform':{rank:1},'any form':{rank:2}},
        'mimic':{'all powers':{rank:2}},
        'mind control':{},
        'mind shield':{},
        'mini object':{},
        'minions':{},
        'mulligan':{},
        'nullify':{'multiple attributes':{rank:2}},
        'plant control':{},
        'pocket dimension':{},
        'portal':{},
        'power flux':{'debuff':{rank:1},'major category':{rank:1},'primal category':{rank:2}},
        'power variation':{},
        'projection':{'few projections':{rank:1},'several projections':{rank:2}},
        'ranged attack':{},
        'ranged defense':{},
        'regeneration':{},
        'reincarnation':{'difficult to stop':{rank:1}},
        'resilient':{'complete':{rank:1}},
        'sensory block':{},
        'sixth sense':{},
        'size change':{'both ways':{rank:1},'modified shrinking':{rank:1}},
        'skill group':{},
        'social mastery':{},
        'spaceflight':{},
        'special movement':{},
        'summon creatures':{'supernatural':{rank:1},'dimensional':{rank:2}},
        'super sense':{},
        'super speed':{},
        'superstrength':{},
        'swarm':{},
        'taunt':{},
        'telekinesis':{},
        'telepathy':{},
        'teleport':{'blind':{rank:1}},
        'tough':{},
        'transfer':{'all attributes':{rank:2}},
        'transmute':{'resize':{rank:1},'gaseous':{rank:2},'material category':{rank:2}},
        'tunneling':{},
        'unaffected':{'all weapons':{rank:1},'several attributes':{rank:1},'many attributes':{rank:2},'all attributes':{rank:3}},
        'unassailable':{},
        'undetectable':{},
        'unique attribute':{},
        'unknown power':{},
        'water speed':{},
        'wealth':{},
        'weapon':{},
    };
    const base_limiters = ['activation','assisted','backlash','charges','concentration','consumable','delay','dependent','deplete','detectable','emotional','environmental','equipment','imbue','irreversible','localised','maximum','object','permanent','recovery','semi-permanent',/*'unique',*/'unpredictable'];
    const tsc_ap_base_limiters = ['acceleration','haywire','ignore','timed'];
    const base_custom_limiters = {
        'armor':['emphasized','optimized'],
        'flight':['glide','maintain','skim','spread'],
        'force field':['both directions','internal'],
        'ground speed':['road-bound'],
        'massive damage':['focussed damage','targeted damage'],
        'mind control':['broad category','narrow category','specific category','single category'],
        'regeneration':['conditional'],
        'summon creatures':['narrow category','specific category','single category'],
        'telekinesis':['focussed'],
        'telepathy':['broad category','narrow category','specific category','single category'],
        'transfer':['specific attribute'],
        'transmute':['broad category'],
        'undetectable':['nonadjacent'],
        'weapon':['alt-munition','ammo','backblast','exclusive','fieldless','hands','inaccurate','ingest','non-penetrating','stoppable','toxic',/*'unique',*/'unreliable'],
        'default':[]
    };
    const tsc_custom_limiters = {
        'absorption':['capped'],
        'armor':['gap'],
        'force field':['impacting'],
        'plant control':['group','species'],
        'power flux':['skill flux'],
        'transmute':['material category'],
        'default':[]
    };
    const ap_custom_limiters = {
        'absorption':['capped'],
        'armor':['gap'],
        'force field':['impacting'],
        'merge':['proportional damage'],
        'plant control':['group','species'],
        'power flux':['skill flux'],
        'transmute':['material category'],
        'default':[]
    };
    const besmx_custom_limiters = {
        'absorption':['capped'],
        'armor':['gap'],
        'force field':['impacting'],
        'merge':['proportional damage'],
        'plant control':['group','species'],
        'power flux':['skill flux'],
        'default':[]
    };
    const limiter_ranks = {
        'absorption':{'capped':{rank:1}},
        'alternate form':{},
        'alternate identity':{},
        'armor':{'disperse':{rank:1},'emphasized':{rank:1},'gap':{rank:1},'optimized':{rank:2}},
        'attack mastery':{},
        'augmented':{},
        'capacity':{},
        'change state':{},
        'cognition':{},
        'combat technique':{},
        'companion':{},
        'connected':{},
        'control environment':{},
        'conversion':{},
        'data access':{},
        'defense mastery':{},
        'dimension walk':{},
        'dynamic powers':{},
        'elasticity':{},
        'enemy attack':{},
        'enemy defense':{},
        'energized':{},
        'exorcism':{},
        'expertise':{},
        'extra actions':{},
        'extra defenses':{},
        'extra arms':{},
        'features':{},
        'flight':{'glide':{rank:1},'maintain':{rank:1},'skim':{rank:1},'spread':{rank:1}},
        'force field':{'both directions':{rank:1},'specific':{rank:1},'impacting':{rank:1},'internal':{rank:1}},
        'ground speed':{'road-bound':{rank:1}},
        'healing':{},
        'heightened awareness':{},
        'heightened senses':{},
        'illusion':{},
        'immovable':{},
        'immunity':{},
        'immutable':{},
        'inspire':{},
        'jumping':{},
        'massive damage':{'focussed damage':{rank:1},'targeted damage':{rank:1}},
        'melee attack':{},
        'melee defense':{},
        'merge':{'proportional damage':{rank:1}},
        'metamorphosis':{},
        'mimic':{},
        'mind control':{'broad category':{rank:1},'narrow category':{rank:2},'specific category':{rank:3},'single category':{rank:4}},
        'mind shield':{},
        'mini object':{},
        'minions':{},
        'mulligan':{},
        'nullify':{},
        'plant control':{'group':{rank:1},'species':{rank:2}},
        'pocket dimension':{},
        'portal':{},
        'power flux':{'skill flux':{rank:1}},
        'power variation':{},
        'projection':{},
        'ranged attack':{},
        'ranged defense':{},
        'regeneration':{'conditional':{rank:1}},
        'reincarnation':{},
        'resilient':{},
        'sensory block':{},
        'sixth sense':{},
        'size change':{},
        'skill group':{},
        'social mastery':{},
        'spaceflight':{},
        'special movement':{},
        'summon creatures':{'narrow category':{rank:1},'specific category':{rank:2},'single category':{rank:3}},
        'super sense':{},
        'super speed':{},
        'superstrength':{},
        'swarm':{},
        'taunt':{},
        'telekinesis':{'focussed':{rank:1}},
        'telepathy':{'broad category':{rank:1},'narrow category':{rank:2},'specific category':{rank:3},'single category':{rank:4}},
        'teleport':{},
        'tough':{},
        'transfer':{'specific attribute':{rank:2}},
        'transmute':{'broad category':{rank:1},'material category':{rank:2}},
        'tunneling':{},
        'unaffected':{},
        'unassailable':{},
        'undetectable':{'nonadjacent':{rank:1}},
        'unique attribute':{},
        'unknown power':{},
        'water speed':{},
        'wealth':{},
        'weapon':{'alt-munition':{rank:0},'fieldless':{rank:1},'hands':{rank:1},'ingest':{rank:1}}
    };
    const base_defects = ['achilles heel','awkward size','bane','blind fury','conditional ownership','confined','cursed','easily distracted','fragile','hounded','impaired manipulation','impaired speech','inept attack','inept defense','involuntary change','ism','magnet','marked','nemesis','nightmares','obligated','phobia','physical impairment','red tape','reduced damage','sensory impairment','shortcoming','significant other','skeleton in the closet','social fault','special requirement','unappealing',/*'unique defect',*/'vulnerability','wanted','weak point'];
    const all_attributes_stats = {
        'absorption':'body',
        'alternate form':'body',
        'alternate identity':'body',
        'change state':'body',
        'cognition':'mind',
        'connected':'soul',
        'control environment':'soul',
        'conversion':'body',
        'data access':'mind',
        'dimension walk':'soul',
        'dynamic powers':'variable',
        'elasticity':'body',
        'exorcism':'soul',
        'extra defenses':'mind',
        'features':'variable',
        'flight':'body',
        'force field':'body',
        'ground speed':'body',
        'healing':'soul',
        'heightened awareness':'variable',
        'heightened senses':'variable',
        'illusion':'variable',
        'immovable':'body',
        'immunity':'body',
        'immutable':'variable',
        'inspire':'soul',
        'jumping':'body',
        'metamorphosis':'variable',
        'mimic':'mind',
        'mind control':'mind',
        'mind shield':'mind',
        'minions':'soul',
        'mulligan':'soul',
        'nullify':'variable',
        'plant control':'mind',
        'portal':'soul',
        'power flux':'variable',
        'power variation':'variable',
        'projection':'mind',
        'regeneration':'body',
        'reincarnation':'soul',
        'resilient':'body',
        'sensory block':'mind',
        'sixth sense':'soul',
        'size change':'body',
        'skill group':'variable',
        'spaceflight':'body',
        'special movement':'body',
        'summon creatures':'mind',
        'super sense':'mind',
        'super speed':'body',
        'superstrength':'body',
        'swarm':'mind',
        'telekinesis':'mind',
        'telepathy':'mind',
        'teleport':'mind',
        'transfer':'soul',
        'transmute':'variable',
        'tunneling':'body',
        'unaffected':'body',
        'undetectable':'body',
        'unique attribute':'variable',
        'water speed':'body',
        'default':'none'
    };
    const attribute_costs = {
        'absorption':5,
        'alternate form':4,
        'alternate identity':1,
        'armor':2,
        'attack mastery':1,
        'augmented':2,
        'capacity':1,
        'change state':3,
        'cognition':2,
        'combat technique':1,
        'companion':4,
        'connected':1,
        'control environment':1,
        'conversion':3,
        'data access':2,
        'defense mastery':1,
        'dimension walk':5,
        'dynamic powers':10,
        'elasticity':1,
        'enemy attack':1,
        'enemy defenses':1,
        'energised':1,
        'exorcism':1,
        'expertise':1,
        'extra actions':4,
        'extra defenses':2,
        'extra arms':1,
        'features':1,
        'flight':3,
        'force field':4,
        'gear':1,
        'ground speed':1,
        'healing':1,
        'heightened awareness':1,
        'heightened senses':1,
        'illusion':1,
        'immovable':1,
        'immunity':3,
        'immutable':1,
        'inspire':1,
        'jumping':1,
        'massive damage':3,
        'melee attack':1,
        'melee defense':1,
        'merge':4,
        'metamorphosis':2,
        'mimic':2,
        'mind control':5,
        'mind shiled':1,
        'mini object':2,
        'minions':2,
        'mulligan':1,
        'nullify':5,
        'plant control':1,
        'pocket dimension':1,
        'portal':2,
        'power flux':10,
        'power variation':4,
        'projection':3,
        'ranged attack':1,
        'ranged defense':1,
        'regeneration':5,
        'reincarnation':2,
        'resilient':2,
        'sensory block':1,
        'sixth sense':1,
        'size change':10,
        'skill group':0,
        'skills':1,
        'social mastery':1,
        'spaceflight':1,
        'special movement':1,
        'summon creatures':2,
        'supersense':1,
        'superspeed':3,
        'superstrength':4,
        'swarm':2,
        'taunt':1,
        'telekinesis':4,
        'telepathy':3,
        'teleport':3,
        'tough':1,
        'transfer':3,
        'transmute':3,
        'tunneling':1,
        'unaffected':2,
        'unassailable':1,
        'undetectable':2,
        'unique attribute':0,
        'unknown power':0,
        'water speed':1,
        'wealth':3,
        'weapon':2
    };
    const defect_costs = {
        'achilles heel':2,
        'awkward size':2,
        'bane':2,
        'blind fury':2,
        'conditional ownership':1,
        'confined':3,
        'cursed':2,
        'demure':1,
        'easily distracted':1,
        'fragile':1,
        'hounded':2,
        'impaired manipulation':3,
        'impaired speech':3,
        'inept attack':1,
        'inept defense':1,
        'involuntary change':1,
        'ism':2,
        'magnet':1,
        'marked':1,
        'nemesis':1,
        'nightmares':1,
        'no healing':2,
        'obligated':2,
        'phobia':1,
        'physical impairment':3,
        'red tape':1,
        'reduced damage':3,
        'sensory impairment':3,
        'shortcoming':1,
        'significant other':1,
        'skeleton in the closet':2,
        'social fault':1,
        'special requirement':3,
        'unappealing':1,
        'unique defect':0,
        'unsettled':1,
        'vulnerability':2,
        'wanted':2,
        'weak point':2
    };
    const sources_4e = ['high-technology','magic','non-humans','psionics'];
    const sources_3e = ['divine','magical','mutation','natural','psionics','social','skilled','supernatural','technological'];
    const damage_types = ['acid','blunt','cold','disease','electric','heat','penetrating','psychosomatic','radiation','toxin'];
    const melee_types = ['exotic','hafted','hilted','polearm','unarmed'];
    const ranged_types = ['archery','artillery','hand gun','heavy weapon','long gun','special','thrown weapon','weaponry'];
    const senses = ['hearing','sight','smell','taste','touch'];
    const nested_enhancements = {
        'connected':['significant power','great power'],
        'dynamic powers':['major category','primal category'],
        'metamorphosis':['multiform','any form'],
        'power flux':['major category','primal category'],
        'projection':['few projections','several projections'],
        'summon creature':['supernatural','dimensional'],
        'unaffected':['several attributes','many attributes','all attributes'],//'all weapons',
    };
    const nested_limiters = {
        'armor':['emphasized','optimized'],
        'mind control':['broad category','narrow category','specific category','single category'],
        'plant control':['group','species'],
        'summon creature':['narrow category','specific category','single category'],
        'telepathy':['broad category','narrow category','specific category','single category'],
        'transmute':['broad category','material category'],
        
    };
    const shortcomings = [
        {
            aspect:'body',
            stat:'body',
            type:'all'
        },
        {
            aspect:'agility',
            stat:'body',
            type:'major'
        },
        {
            aspect:'endurance',
            stat:'body',
            type:'major'
        },
        {
            aspect:'strength',
            stat:'body',
            type:'major'
        },
        {
            aspect:'immune system',
            stat:'body',
            type:'minor'
        },
        {
            aspect:'manual dexterity',
            stat:'body',
            type:'minor'
        },
        {
            aspect:'running speed',
            stat:'body',
            type:'minor'
        },
        {
            aspect:'mind',
            stat:'mind',
            type:'all'
        },
        {
            aspect:'creativity',
            stat:'mind',
            type:'major'
        },
        {
            aspect:'perception',
            stat:'mind',
            type:'major'
        },
        {
            aspect:'reason',
            stat:'mind',
            type:'major'
        },
        {
            aspect:'common sense',
            stat:'mind',
            type:'minor'
        },
        {
            aspect:'intuition',
            stat:'mind',
            type:'minor'
        },
        {
            aspect:'memory',
            stat:'mind',
            type:'minor'
        },
        {
            aspect:'soul',
            stat:'soul',
            type:'all'
        },
        {
            aspect:'charisma',
            stat:'soul',
            type:'major'
        },{
            aspect:'luck',
            stat:'soul',
            type:'major'
        },{
            aspect:'willpower',
            stat:'soul',
            type:'major'
        },
        {
            aspect:'composure',
            stat:'soul',
            type:'minor'
        },{
            aspect:'empathy',
            stat:'soul',
            type:'minor'
        },{
            aspect:'self-discipline',
            stat:'soul',
            type:'minor'
        },
    ];

    /* Custom Prototypes */
    String.prototype.toSnakeCase = function() {
        return this.replace(new RegExp(/\s+/g), '_');
    };

    Array.prototype.toSnakeCase = function() {
        const snaked = this.map(t => {
            const s = (typeof t === 'string' || t instanceof String) ? 
                t.replace(new RegExp(/\s+/g), '_') : t;
            return s;
        });
        return snaked;
    };

    String.prototype.toKebobCase = function() {
        return this.replace(new RegExp(/\s+/g), '-');
    };

    Array.prototype.toKebobCase = function() {
        const kebobed = this.map(t => {
            const s = (typeof t === 'string' || t instanceof String) ? 
                t.replace(new RegExp(/\s+/g), '-') : t;
            return s;
        });
        return kebobed;
    };

    String.prototype.capitalize = function() {
        const temp = {
            hyphens: /-/g.test(this),
            whitespace: /\s|_/g.test(this),
        };
        const dont_capitalize = /^a$|^an$|^and$|^as$|^at$|^but$|^by$|^for$|^in$|^nor$|^of$|^on$|^or$|^the$|^up$/g;
        temp.str = temp.whitespace ? this.split(/\s|_/g) : [`${this}`];
        for (let i = 0, n = temp.str.length; i < n; i++) {
            temp.str[i] = dont_capitalize.test(temp.str[i]) && (
                i !== 0 || i !== n
            ) ? temp.str[i][0] + temp.str[i].substring(1) : 
                temp.str[i][0].toUpperCase() + temp.str[i].substring(1);
        }
        temp.str = temp.whitespace ? temp.str.join(" ") : temp.str[0];
        if (temp.hyphens) {
            temp.str = temp.hyphens ? temp.str.split("-") : [`${temp.str}`];
            for (let i = 0, n = temp.str.length; i < n; i++) {
                temp.str[i] = temp.str[i][0].toUpperCase() + temp.str[i].substring(1);
            }
            temp.str = temp.hyphens ? temp.str.join("-") : temp.str[0];
        }
        return temp.str;
    }

    Array.prototype.capitalize = function() {
        const result = this.map(r => {
            const temp = {
                hyphens: /-/g.test(r),
                whitespace: /\s/g.test(r),
            };
            temp.str = temp.whitespace ? r.split(" ") : [`${r}`];
            for (let i = 0, n = temp.str.length; i < n; i++) {
                temp.str[i] = temp.str[i][0].toUpperCase() + temp.str[i].substring(1);
            }
            temp.str = temp.whitespace ? temp.str.join(" ") : temp.str[0];
            if (temp.hyphens) {
                temp.str = temp.hyphens ? temp.str.split("-") : [`${temp.str}`];
                for (let i = 0, n = temp.str.length; i < n; i++) {
                    temp.str[i] = temp.str[i][0].toUpperCase() + temp.str[i].substring(1);
                }
                temp.str = temp.hyphens ? temp.str.join("-") : temp.str[0];
            }
            return temp.str;
        });
        return result;
    }

    String.prototype.removeWhiteSpace = function() {
        if (this === undefined) {
            return false;
        } else {
            return this.replace(/\s+/g, '');
        }
    }

    String.prototype.fromSnakeCase = function() {
        return this.replace(/(?:_| |\b)(\w)/g, function($1){return $1.toUpperCase().replace('_',' ');});
    }

    /* Async Functions by OnyxRing and Scott C */
    /*
    const asw = (() => {
        const setActiveCharacterId = function(charId){
            let oldAcid=getActiveCharacterId();
            let ev = new CustomEvent("message");
            ev.data={"id":"0", "type":"setActiveCharacter", "data":charId};
            self.dispatchEvent(ev);
            return oldAcid;
        };
        const promisifyWorker = (worker, parameters) => {
            let acid=getActiveCharacterId(); 
            let prevAcid=null;               
            return new Promise((res,rej)=>{
                prevAcid=setActiveCharacterId(acid);  
                try {if (worker===0) getAttrs(parameters[0]||[],(v)=>res(v));
                    else if (worker===1) setAttrs(parameters[0]||{}, parameters[1]||{},(v)=>res(v));
                    else if (worker===2) getSectionIDs(parameters[0]||'',(v)=>res(v));
                } catch(err) {rej(console.error(err))}
            }).finally(()=>setActiveCharacterId(prevAcid));
        }
        return {
            getAttrs(attrArray) {return promisifyWorker(0, [attrArray])},
            setAttrs(attrObj, options) {return promisifyWorker(1, [attrObj, options])},
            getSectionIDs(section) {return promisifyWorker(2, [section])},
            setActiveCharacterId,
        }
    })();
    */
    function isRunningOnServer(){ return self.dispatchEvent==undefined; }
    function setActiveCharacterId(charId){
        var oldAcid=getActiveCharacterId();
        var msg={"id":"0", "type":"setActiveCharacter", "data":charId};
        
        if(isRunningOnServer()==false){ //if in a browser, use "dispatchEvent" to process the message
            var ev = new CustomEvent("message");
            ev.data=msg; 
            self.dispatchEvent(ev);
        }else{ //otherwise, use the API (server) message processor, "onmessage"
            self.onmessage({data:msg});
        }
        return oldAcid; //return what the value used to be, so calling code can be a little cleaner 
    } 
    var _sIn=setInterval;
    setInterval=function(callback, timeout){
        var acid=getActiveCharacterId();
        _sIn(
            function(){
                var prevAcid=setActiveCharacterId(acid);
                callback();
                setActiveCharacterId(prevAcid);
            }
        ,timeout);
    }
    var _sto=setTimeout
    setTimeout=function(callback, timeout){
        var acid=getActiveCharacterId();
        _sto(
            function(){
                var prevAcid=setActiveCharacterId(acid);
                callback();
                setActiveCharacterId(prevAcid);
            }
        ,timeout);
    }
    function getAttrsAsync(props){
        var acid=getActiveCharacterId(); //save the current activeCharacterID in case it has changed when the promise runs 
        var prevAcid=null;               //local variable defined here, because it needs to be shared across the promise callbacks defined below
        return new Promise((resolve,reject)=>{
                prevAcid=setActiveCharacterId(acid);  //in case the activeCharacterId has changed, restore it to what we were expecting and save the current value to restore later
                try{
                    getAttrs(props,(values)=>{  resolve(values); }); 
                }
                catch{ reject(); }
        }).finally(()=>{
            setActiveCharacterId(prevAcid); //restore activeCharcterId to what it was when the promise first ran
        });
    }
    //use the same pattern for each of the following...
    function setAttrsAsync(propObj, options){
        var acid=getActiveCharacterId(); 
        var prevAcid=null;               
        return new Promise((resolve,reject)=>{
                prevAcid=setActiveCharacterId(acid);  
                try{
                    setAttrs(propObj,options,(values)=>{ resolve(values); });
                }
                catch{ reject(); }
        }).finally(()=>{
            setActiveCharacterId(prevAcid); 
        });
    }

    function getSectionIDsAsync(sectionName){
        var acid=getActiveCharacterId(); 
        var prevAcid=null;               
        return new Promise((resolve,reject)=>{
                prevAcid=setActiveCharacterId(acid);  
                try{
                    getSectionIDs(sectionName,(values)=>{ resolve(values); });
                }
                catch{ reject(); }
        }).finally(()=>{
            setActiveCharacterId(prevAcid); 
        });
    }
    function getSingleAttrAsync(prop){ 
        var acid=getActiveCharacterId(); 
        var prevAcid=null;               
        return new Promise((resolve,reject)=>{
                prevAcid=setActiveCharacterId(acid);  
                try{
                    getAttrs([prop],(values)=>{  resolve(values[prop]); }); 
                }
                catch{ reject(); }
        }).finally(()=>{
            setActiveCharacterId(prevAcid); 
        });
    }

    const rollEscape = {
        chars: {
            '"': '%quot;',
            ',': '%comma;',
            ':': '%colon;',
            '}': '%rcub;',
            '{': '%lcub;',
        },
        escape(str) {
            str = (typeof(str) === 'object') ? JSON.stringify(str) : (typeof(str) === 'string') ? str : null;
            return (str) ? `${str}`.replace(new RegExp(`[${Object.keys(this.chars)}]`, 'g'), (r) => this.chars[r]) : null;
        },
        unescape(str) {
            str = `${str}`.replace(new RegExp(`(${Object.values(this.chars).join('|')})`, 'g'), (r) => Object.entries(this.chars).find(e=>e[1]===r)[0]);
            return JSON.parse(str);
        }
    }

    /* Utility Functions */
    function setTimer(cache) {
        cache.timer = {}
        cache.timer.start = Date.now();
        cache.timer.elapsed = 0;
        cache.timer.cache = 0;
    }

    function getTimestamp(cache) {
        const timeNow = Date.now();
        const timeElapsed = timeNow - cache.timer.start;
        cache.timer.cache = timeElapsed - cache.timer.elapsed;
        cache.timer.elapsed = timeElapsed;
    }

    function int(integer, fallback = 0) {
        return parseInt(integer) || fallback;
    }

    function clog(cache, data, title, type = 'event') {
        //types = 'info', 'event'
        //debug = 0:none, 1:info, 2:event, 3:performance
        const debug = (cache.static_sheet_settings_debug || 'none').toLowerCase();
        const color = 
            type === 'info' ? 'color:#EE82EE' :
            type === 'start' ? 'color:#7CFC00' :
            type === 'end' ? 'color:#D50000' :
            'color:#00FFFF';
        const text = data === '' ? '' :
            _.isString(data) ? 'string:' :
            _.isNumber(data) ? 'number:' :
            _.isArray(data) ? 'array:' : 
            _.isObject(data) ? 'object:' :
            '';
        title = title ? `.[${title}]` : '+';
        title ? console.log(`%c+----.----.----${title}`,color) : false;
        console.log(`%c${text}`,color,data);
        if (debug === 'performance') {
            getTimestamp(cache);
            console.log(
                `%crunTime[${cache.timer.cache}] elapsedTime[${cache.timer.elapsed}]`,
                'color:yellow'
            );
        }
    }

    function isTruthly(value) {
        const is_truthly = 
            value === undefined ? false :
            value === '' ? false :
            int(value) === 0 ? false :
            true;
        return is_truthly;
    }

    function removeWhiteSpace(str){
        if (str === undefined) {
            return false;
        } else {
            return str.replace(/\s+/g, '');
        }
    }

    function isFloat(n) { return !!(n % 1); }

    function arraysAreEqual(arrayA, arrayB) {
        if (arrayA.length !== arrayB.length) { return false; } else {
            return arrayA.sort().join(",") === arrayB.sort().join(",");
        }
    }

    async function crpQuery(cache, query, tag = '') {
        const rxGrab = /^0\[(.*)\]\s*$/;
        clog(cache, query, `crpQuery(${tag})`);
        query.string = `! {{query=[[0[?{${query.title}${query.options}}] ]] }}`;
        query.crp = await startRoll(query.string);
        finishRoll(query.crp.rollId);
        query.match = query.crp.results.query.expression.match(rxGrab)[1];
        query.selection = 
            isNaN(query.match) ? query.match : 
            isFloat(query.match) ? parseFloat(query.match) : int(query.match);
    }

    async function crpRoll(cache, roll_string) {
        const roll = {};
        clog(cache, roll, `crpRoll()`);
        roll.string = roll_string;
        roll.crp = await startRoll(roll.string);
        finishRoll(roll.crp.rollId,{
            dice0: roll.crp.results.roll.dice[0],
            dice1: roll.crp.results.roll.dice[1],
            total: roll.crp.results.total.result,
        });
    }

    async function crpGet(cache, attributes) {
        // attrubutes can be a string or an object.
        // if a string, then the funtion will return a single value.
        // if an object, then the cache object will contain the fetched values
        // by the keys passed from attributes.
        const get = {};
        clog(cache, get, 'crpGet()');
        const rxGrab = /^0\[(.*)\]\s*$/;
        switch (true) {
            case _.isString(attributes):
                get.string = 
                `! {{get=[[0[@{${cache.static_sheet_settings_gm}|${attributes}}] ]]}}`;
                get.crp = await startRoll(get.string);
                get.value = get.crp.results.get.expression.match(rxGrab)[1];
                finishRoll(get.crp.rollId);
                get.value = isNaN(get.value) ? get.value : int(get.value);
                return get.value;
            break;
            case Array.isArray(attributes):
                get.keys = attributes.map(a => {
                    return `rules_${a}_status`;
                });
                get.string = '!';
                get.length = get.keys.length;
                for (let i = 0; i < get.length; i++) {
                    get.string += ` {{${get.keys[i]}=[[0[@{${cache.static_sheet_settings_gm}|${get.keys[i]}}]]]}}`;
                }
                get.crp = await startRoll(get.string);
                for (let i = 0; i < get.length; i++) {
                    const key = `${get.keys[i]}`;
                    get[key] = get.crp.results[key].expression.match(rxGrab)[1];
                    cache[key] = isNaN(get[key]) ? get[key] : int(get[key]);
                }
                finishRoll(get.crp.rollId);
            break;
            case _.isObject(attributes):
                get.keys = Object.keys(attributes);
                get.values = Object.values(attributes);
                get.length = get.keys.length;
                get.string = '!';
                for (let i = 0; i < get.length; i++) {
                    get.string += ` {{${get.keys[i]}=[[0[@{${cache.static_sheet_settings_gm}|${get.values[i]}}]]]}}`;
                }
                get.crp = await startRoll(get.string);
                for (let i = 0; i < get.length; i++) {
                    const key = `${get.keys[i]}`;
                    get[key] = get.crp.results[key].expression.match(rxGrab)[1];
                    cache[key] = isNaN(get[key]) ? get[key] : int(get[key]);
                }
                finishRoll(get.crp.rollId);
            break;
        }
    }

    function capitalize(str) {
        const temp = {
            str: str,
            whitespace: /\s/g.test(str),
        };
        temp.str = temp.whitespace ? temp.str.split(" ") : [`${temp.str}`];
        for (let i = 0, x = temp.str.length; i < x; i++) {
            temp.str[i] = temp.str[i][0].toUpperCase() + temp.str[i].substr(1);
        }
        return temp.whitespace ? temp.str.join(" ") : temp.str[0];
    }

    function convertUnitMeasurement(cache, query, type) {
        const temp = {};
        clog(cache, temp, 'convertUnitMeasurement()');

        temp.length = n.length;
        if (n > 0) {
            if (temp.length - 1 > 3) {
                temp.measurement = int(n) / (10 ** (temp.length - 1));
                temp.unit = 'km';
            } else {
                temp.measurement = n;
                temp.unit = 'm';
            }
        } else if (n < 0) {
            temp.measurement = parseFloat(n) * (10 ** (temp.length - 2));
            if (temp.length === 4) {
                temp.unit = 'cm';
            } else if (temp.length === 5) {
                temp.unit = 'mm';
            } else {
                temp.unit = 'mcm';
            }
        }

        switch (type) {
            case 'height':
                temp.title_string = 
                    `${getTranslationByKey("enter-height-in")} ${query.template.height.unit} (` +
                    `${query.template.height.min}-${query.template.height.max}` +
                    ` ${query.template.height.unit_abv})`;
            break;
        }
    }

    function setDice (cache, roll, eo = 0) {
        const exceed2dice =
            cache.rulesdb.rules_optional_dice_status === 'exceed' ? true : false;
        const temp = {};
        clog(cache, temp, 'setDice()');
        temp.mod = roll.mod;
        temp.string = '{{total=[[';
        temp.d6 = ' [[1d6]]+[[1d6]]';
        temp.d6_value = ' {{dice0=$[[0]]}} {{dice1=$[[1]]}}';
        temp.eo = eo;
        temp.extra_dice = int((temp.mod.edge || 0) + (temp.mod.obstacle || 0 * -1) + temp.eo);
        temp.ndice = 
            (temp.extra_dice > 1 || temp.extra_dice < -1) ? 
                exceed2dice ? temp.extra_dice + 2 : 4 : 
            (temp.extra_dice === 1 || temp.extra_dice === -1) ? 3 : 2;
        for (let i = 2, n = temp.ndice; i < n; i++) {
            temp.d6 += '+[[1d6]]';
            temp.d6_value += ` {{dice${i}=$[[${i}]]}}`;
        }
        temp.string += `${temp.d6} ]]}} ${temp.d6_value}`;
        roll.dice = {
            number: temp.ndice,
            type: temp.extra_dice < 0 ? 'obstacle' : 
                temp.extra_dice > 0 ? 'edge' : 'normal',
        }
        return temp.string;
    }

    function getDiceIcon(dice_value, light_icon = false) {
        const icon_character = {
            1:'G',
            2:'H',
            3:'I',
            4:'J',
            5:'K',
            6:'L'
        };
        const dice_icon = icon_character[dice_value];
        return !light_icon ? dice_icon : dice_icon.toLowerCase();
    }

    function getRollDifficultyByTN(tn) {
        const difficulty = {
            6:'Simple',
            9:'Easy',
            12:'Average',
            15:'Difficult',
            18:'Challenging',
            21:'Unlikely',
            24:'Doubtful',
            27:'Improbable',
            30:'Inconceivable'
        }
        return difficulty[tn];
    }

    function getArrayPositionByID(cache, array, id) {
        const temp = {};
        clog(cache, temp, 'getArrayPositionByID()');
        temp.index = array.findIndex(a => {
            return a.id.toLowerCase() === id.toLowerCase();
        });
        /*
        array.find((c,i) => {
            if (c.id.toLowerCase() === id.toLowerCase()) temp.i = i;
        });
        */
        return temp.index;
    }

    /* Group Show/Hide Functions */
    function showDynamicGroupFields(cache) {
        const temp = {};
        clog(cache, temp, 'showDynamicGroupFields()');
        //temp.groupdb = cache.groupdb[cache.static_group_visible_id || 0];
        temp.group_type = cache.groupdb[cache.static_group_visible_id || 0].group_type;
        temp.remove = temp.group_type === 'standard' ? 'show' : 'hide';
        temp.add = temp.group_type === 'standard' ? 'hide' : 'show';
        $20(`.group-type-visibility`).removeClass(`group-type-visibility-${temp.remove}`);
        $20(`.group-type-visibility`).addClass(`group-type-visibility-${temp.add}`);
    }

    function setAttributeGroupVisibility(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'setAttributeGroupVisibility()');
        temp.visible_id = int(cache.static_group_visible_id);
        for (let i = 0; i < cache.groupdb.length; i++) {
            temp.group_id = int(cache.groupdb[i].group_id);
            for (let j = 0; j < cache.groupdb[i].attribute_ids.length; j++) {
                const id = cache.groupdb[i].attribute_ids[j].toLowerCase();
                set_values[`repeating_attribute_${id}_visibility`] = 
                temp.group_id === temp.visible_id ? 1 : 0;
            }
            for (let j = 0; j < cache.groupdb[i].defect_ids.length; j++) {
                const id = cache.groupdb[i].defect_ids[j].toLowerCase();
                set_values[`repeating_defect_${id}_visibility`] = 
                temp.group_id === temp.visible_id ? 1 : 0;
            }
            if (temp.group_id === temp.visible_id) {
                set_values.static_attributes_group_name = cache.groupdb[i].name;
                set_values.static_attributes_group_points = `${cache.groupdb[i].group_points}`;
                set_values.static_attributes_group_type = cache.groupdb[i].group_type.capitalize();
                set_values.static_attributes_group_origin = cache.groupdb[i].origin.capitalize();
                set_values.static_attributes_group_source = cache.groupdb[i].source.capitalize();
                if (cache.groupdb[i].group_type !== 'standard') {
                    set_values.static_group_pointpool_name = cache.groupdb[i].pool_name || '';
                    if (cache.groupdb[i].group_type === 'power flux') {
                        setPowerFluxPoolPoints(cache, set_values);
                    } else if (cache.groupdb[i].group_type === 'power variation') {
                        setPowerVariationPoolPoints(cache, set_values);
                    } else if (cache.groupdb[i].group_type === 'dynamic powers') {
                        setDynamicPowersPoolLevels(cache, set_values);
                    }
                    set_values.static_group_type_level = `${cache.groupdb[i].level || 0} (${cache.groupdb[i].elevel || 0})`;
                    set_values.static_group_type_stat = `${cache.groupdb[i].stat.capitalize() || 'None'}`;
                    set_values.static_group_type_points = cache.groupdb[i].points || 0;
                    set_values.static_group_type_description = cache.groupdb[i].description || '';
                    set_values.static_group_type_enhancements = 
                        customizationsToString(cache, cache.groupdb[i].enhancements) || '';
                    set_values.static_group_type_limiters =
                        customizationsToString(cache, cache.groupdb[i].limiters) || '';
                    set_values.static_group_type_cost = attribute_costs[cache.groupdb[i].group_type];
                }
            }
        }
    }

    function setSkillUiVisibility(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'setSkillUiVisibility()');
        temp.visible_id = int(cache.static_skills_visible_id);
        for (let i = 0; i < cache.attrdb.skills.length; i++) {
            const skills = cache.attrdb.skills[i].individual;
            for (let j = 0; j < skills.length; j++) {
                set_values[`repeating_skill_${skills[j].row_id.toLowerCase()}_visibility`] = 
                    i === temp.visible_id ? 1 : 0;
            }
            if (i === temp.visible_id) {
                set_values.static_skills_attribute_name = cache.attrdb.skills[i].name;
                set_values.static_skills_points_total = cache.attrdb.skills[i].elevel * 10;
                set_values.static_skills_points_remaining = 
                    set_values.static_skills_points_total
                    - cache.attrdb.skills[i].individual.reduce((a, b) => a + b.points, 0) || 0;
            }
        }
    }

    function setPowerFluxPoolPoints(cache, set_values) {
        if (cache.is_sheetopened) { return; }
        const temp = {};
        clog(cache, temp,'setPowerFluxPoolPoints()');
        temp.flux_points_used = 0;
        temp.group_ids = cache.groupdb[cache.static_group_visible_id].attribute_ids;
        for (let i = 0; i < all_attributes.length; i++) {
            const attributes = cache.attrdb[all_attributes[i]];
            for (let j = 0; j < attributes.length; j++) {
                if (temp.group_ids.includes(attributes[j].row_id) && attributes[j].active) {
                    temp.flux_points_used += attributes[j].points;
                    break;
                }
            }
        }
        temp.flux_points_available = cache.groupdb[cache.static_group_visible_id].pool_points;
        set_values.static_group_pointpool_points = 
            `${temp.flux_points_used} / ${temp.flux_points_available}`;
    }

    function setDynamicPowersPoolLevels(cache, set_values) {
        if (cache.is_sheetopened) { return; }
        const temp = {};
        clog(cache, temp,'setDynamicPowersPoolLevels()');
        temp.dynamic_levels_used = 0;
        temp.group_ids = cache.groupdb[cache.static_group_visible_id].attribute_ids;
        for (let i = 0; i < all_attributes.length; i++) {
            const attributes = cache.attrdb[all_attributes[i]];
            for (let j = 0; j < attributes.length; j++) {
                if (temp.group_ids.includes(attributes[j].row_id) && attributes[j].active) {
                    temp.dynamic_levels_used += attributes[j].level;
                    break;
                }
            }
        }
        temp.dynamic_levels_available = cache.groupdb[cache.static_group_visible_id].pool_points;
        set_values.static_group_pointpool_points = 
            `${temp.dynamic_levels_used} / ${temp.dynamic_levels_available}`;
    }

    function setPowerVariationPoolPoints(cache, set_values) {
        if (
            cache.is_sheetopened //|| 
            //cache.groupdb[cache.static_group_visible_id].locked
        ) { return; }
        const temp = {};
        clog(cache, temp,'setPowerVariationPoolPoints()');
        temp.variation_points_used = 0;
        temp.variation_points_max = 0;
        //temp.group_ids = cache.groupdb[cache.static_group_visible_id].attribute_ids;
        for (let i = 0; i < all_attributes.length; i++) {
            const attributes = cache.attrdb[all_attributes[i]];
            for (let j = 0; j < attributes.length; j++) {
                if (attributes[j].group_id === cache.static_group_visible_id) {
                    const point_index = attributes[j].config.findIndex(c => c.name === 'base points');
                    temp.variation_points_max += attributes[j].config[point_index].rank;
                    temp.variation_points_used += attributes[j].active ? attributes[j].points : 0;
                }
            }
        }
        //temp.variation_points_used += cache.groupdb[cache.static_group_visible_id].points;
        set_values.static_group_pointpool_points = 
            `${temp.variation_points_used} / ${temp.variation_points_max}`;
    }

    function setPowerVariationGroupPoints(cache, set_values) {
        if (
            cache.is_sheetopened || 
            cache.groupdb[cache.static_group_visible_id].locked
        ) { return; }
        const temp = {};
        clog(cache, temp,'setPowerVariationGroupPoints()');
        temp.group_points = 
            cache.groupdb[cache.static_group_visible_id].elevel * attribute_costs['power variation'];
        for (let i = 0; i < all_attributes.length; i++) {
            const attributes = cache.attrdb[all_attributes[i]];
            for (let j = 0; j < attributes.length; j++) {
                if (attributes[j].group_id === cache.static_group_visible_id) {
                    const point_index = attributes[j].config.findIndex(c => c.name === 'base points');
                    temp.group_points += attributes[j].config[point_index].rank;
                }
            }
        }
        cache.groupdb[cache.static_group_visible_id].group_points = temp.group_points;
        set_values.static_attributes_group_points = temp.group_points;
    }

    /* Theme Functions */
    function initializeTheme(values) {
        const theme = {};
        clog(values, theme, 'initializeTheme()', 'event');
        theme.current = values.static_sheet_settings_theme.toLowerCase().removeWhiteSpace() || 'tristatcore';//removeWhiteSpace(values.static_sheet_settings_theme.toLowerCase()) || 'tristatcore';
        theme.components = [
            'background','border','button','minor','input','input-major','major','slider','title'
        ];
        theme.scheme = {
            0: 'tristatcore',
            1: 'belalugosi',
            2: 'darkforest',
            3: 'galaxyexpress',
            4: 'highcontrast',
            5: 'imperial',
            6: 'lavender',
            7: 'oceans',
            8: 'pomegranate',
            9: 'sandstone',
            10: 'stormtrooper',
            11: 'valleyofthewind',
            12: 'besm',
            13: 'absolutepower'
        };
        _.each(theme.components, component => {
            theme.selector = `theme-${component}`;
            $20(`.${theme.selector}`)
            .addClass(`${theme.selector}-${theme.current}`);
        });
    }

    function setTheme(cache) {
        const theme = {};
        clog(cache, theme, 'setTheme()', 'event');
        theme.new = cache.newValue.toLowerCase().removeWhiteSpace();//removeWhiteSpace(cache.newValue.toLowerCase());
        theme.previous = cache.previousValue === undefined ? 'tristatcore' :
        cache.previousValue.toLowerCase().removeWhiteSpace();//removeWhiteSpace(cache.previousValue.toLowerCase());
        theme.components = [
            'background','border','button','minor','input','input-major','major','slider','title'
        ];
        _.each(theme.components, component => {
            theme.selector = `theme-${component}`;
            $20(`.${theme.selector}`)
            .removeClass(`${theme.selector}-${theme.previous}`);
            $20(`.${theme.selector}`)
            .addClass(`${theme.selector}-${theme.new}`);
        });
    }

    async function setSheetLogo(cache) {
        const temp = {};
        clog(cache, temp, 'setSheetLogo()');
        temp.logos = ['tristatcore','besm','absolutepower'];
        temp.logo = cache.static_sheet_settings_type.toLowerCase() === 'gm' ? 
           cache.static_rules_base_default : 
           cache.static_sheet_settings_gm === '' ?
           'besm' : await crpGet(cache, 'static_rules_base_default');
        temp.logo = temp.logo === 'besmx' ? 'besm' : temp.logo;
        temp.logo = temp.logo.indexOf('undefined') !== -1 ?
            'besm' : temp.logo;
            temp.logos.splice(temp.logos.indexOf(temp.logo.removeWhiteSpace()),1);
        for (let i = 0, n = temp.logos.length; i < n; i++) {
            $20(`.grid-minor-screen-logo`)
            .removeClass(`${temp.logos[i]}-logo`);
        }
        $20(`.grid-minor-screen-logo`)
        .addClass(`${temp.logo}-logo`);
    }

    async function changeSheetLogo(cache) {
        const temp = {};
        clog(cache, temp, 'changeSheetLogo()');
        temp.logos = ['tristatcore','besm','absolutepower'];
        temp.logo = cache.newValue || 'besm';
        temp.logo = temp.logo === 'besmx' ? 'besm' : temp.logo;
        for (let i = 0, n = temp.logos.length; i < n; i++) {
            $20(`.grid-minor-screen-logo`)
            .removeClass(`${temp.logos[i]}-logo`);
        }
        $20(`.grid-minor-screen-logo`)
        .addClass(`${temp.logo}-logo`);
        cache.rulebook = cache.newValue || 'tristatcore';
    }

    async function setBaseRules(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'setBaseRules()');
        cache.rulebook = cache.rulebook === undefined ? 'besm' : cache.rulebook;
        temp.rules = all_optional_rules.concat(all_normalizations, all_homebrew_rules);
        for (let i = 0; i < temp.rules.length; i++) {
            temp.ap_knockback = cache.rulebook === 'absolutepower' && 
                temp.rules[i] === 'optional_knockback';
            temp.not_besm_or_besmx = cache.rulebook.indexOf('besm') === -1 && (
                temp.rules[i] === 'enhancement_cognition' ||
                temp.rules[i] === 'attribute_deathdodge' ||
                temp.rules[i] === 'attribute_debilitate' ||
                temp.rules[i] === 'enhancement_powerflux' ||
                temp.rules[i] === 'attribute_expertise' ||
                temp.rules[i] === 'attribute_flankdefense' ||
                temp.rules[i] === 'limiter_transmute' ||
                temp.rules[i] === 'attribute_miniobject' ||
                temp.rules[i] === 'enhancement_sizechange' ||
                temp.rules[i] === 'limiter_powerflux' ||
                temp.rules[i] === 'enhancement_sixthsense' ||
                temp.rules[i] === 'attribute_speedburst' ||
                temp.rules[i] === 'attribute_summoncreature' ||
                temp.rules[i] === 'attribute_taunt' || 
                temp.rules[i] === 'limiter_timed' || 
                temp.rules[i] === 'enhancement_transfer' || 
                temp.rules[i] === 'enhancement_weapon'
            );
            temp.not_besm = cache.rulebook !== 'besm' && (
                temp.rules[i] === 'enhancement_absorption' ||
                temp.rules[i] === 'limiter_absorption' ||
                temp.rules[i] === 'enhancement_conversion' ||
                temp.rules[i] === 'enhancement_forcefield' ||
                temp.rules[i] === 'defect_nohealing' ||
                temp.rules[i] === 'attribute_plantcontrol' ||
                temp.rules[i] === 'optional_shield' ||
                temp.rules[i] === 'limiter_powerflux' ||
                temp.rules[i] === 'enhancement_absorption' ||
                temp.rules[i] === 'enhancement_teleport'
            );
            temp.besmx_extradefenses = cache.rulebook === 'besmx' && (
                temp.rules[i] === 'attribute_extradefenses'
            );
            temp.besmx_or_ap_merge = (
                cache.rulebook === 'besmx' ||
                cache.rulebook === 'absolutepower'
                ) && temp.rules[i] === 'limiter_merge';
            temp.besm_and_besmx_tournament = 
                cache.rulebook.indexOf('besm') !== -1 && (
                temp.rules[i] === 'attribute_tournament'
            );
            const status = 
                temp.ap_knockback ||
                temp.not_besm_or_besmx ||
                temp.not_besm ||
                temp.besmx_extradefenses ||
                temp.besmx_or_ap_merge ||
                temp.besm_and_besmx_tournament ? 1 : 0;
            set_values[`rules_${temp.rules[i]}_status`] = status;
            cache.rulesdb[`rules_${temp.rules[i]}_status`] = status;
            set_values[`rules_${temp.rules[i]}_icon`] = 
                temp.ap_knockback ||
                temp.not_besm_or_besmx ||
                temp.not_besm ||
                temp.besmx_extradefenses ||
                temp.besmx_or_ap_merge ||
                temp.besm_and_besmx_tournament ? '3' : '_';
        }
        set_values.rulesdb = JSON.stringify(cache.rulesdb);
    }

    /* Status Bar Related Functions */
    function initializeStatusBars(cache, status_sections) {
        const temp = {};
        clog(cache, temp, 'initializeStatusBars()');
        for (let i = 0; i < status_sections.length; i++) {
            temp.selector = `status-bar-${status_sections[i]}`;
            temp.remaining = 
                int(cache[`static_character_${status_sections[i]}_remaining`]);
            temp.base = 
                int(cache[`static_character_${status_sections[i]}_base`]);
            temp.damage = temp.base - temp.remaining;
            temp.status_math = Math.floor((temp.damage*10)/temp.base);
            temp.status = temp.status_math > 10 ? 10 : temp.status_math;
            $20(`.${temp.selector}`)
            .addClass(`status-bar-${temp.status}`);
        }
    }

    function updateStatusBar(cache, section, status) {
        const temp = {};
        clog(cache, temp, 'updateStatusBar()');
        temp.selector = `status-bar-${section}`;
        for (let i = 1; i < 11; i++) {
            $20(`.${temp.selector}`)
            .removeClass(`status-bar-${i}`);
        }
        $20(`.${temp.selector}`)
        .addClass(`status-bar-${status}`);
    }

    function getStatusDescription(cache, section, status) {
        const description = {
            'energy': {
                10: 'Exhausted',
                9: 'Winded',
                8: 'Winded',
                7: 'Winded',
                6: 'Weary',
                5: 'Weary',
                4: 'Weary',
                3: 'Active',
                2: 'Active',
                1: 'Active',
                0: 'Rested'
            },
            'health': {
                10: 'Mortally Wounded',
                9: 'Critically Wounded',
                8: 'Critically Wounded',
                7: 'Critically Wounded',
                6: 'Seriously Wounded',
                5: 'Seriously Wounded',
                4: 'Seriously Wounded',
                3: 'Lightly Wounded',
                2: 'Lightly Wounded',
                1: 'Lightly Wounded',
                0: 'Healthy'
            },
            'sanity': {
                10: 'Insane',
                9: 'Pathological',
                8: 'Pathological',
                7: 'Pathological',
                6: 'Unstable',
                5: 'Unstable',
                4: 'Unstable',
                3: 'Unwell',
                2: 'Unwell',
                1: 'Unwell',
                0: 'Well'
            },
            'society': {
                10: 'Spiraling',
                9: 'Insecure',
                8: 'Insecure',
                7: 'Insecure',
                6: 'Unsure',
                5: 'Unsure',
                4: 'Unsure',
                3: 'Shaken',
                2: 'Shaken',
                1: 'Shaken',
                0: 'Confident'
            },
        };
        clog(cache, description[section][status], 'getStatusDescription()');
        return description[section][status];
    }

    /* Start-up and Sheet Setup Functions */
    // >>> Update cache with truthly values instead. 
    // >>> Account for fasley values in the code evaluating.
    function updateCache(cache) {
        clog(cache, cache, 'updateCache()', 'event');
        if (cache.newValue !== undefined) {
            cache[cache.sourceAttribute] = cache.newValue
        }
    }

    function doEventTasks(cache, event_info) {
        clog(cache, event_info, 'Event Listener', 'start');
        // If attr removed then flag removed attribute, else update cache
        cache.removed = event_info.triggerName.indexOf('remove') !== -1;
        if (cache.removed) {
            event_info.sourceAttribute = `${event_info.sourceAttribute}_removed`;
        } else if (event_info.newValue !== undefined) {
            cache[event_info.sourceAttribute] = event_info.newValue;
        }
        // Assign sourceAttribute value if is button
        if (event_info.sourceAttribute === undefined) {
            event_info.sourceAttribute = 
            event_info.triggerName.substring(8, event_info.triggerName.length);
        }
        // >>>investigate if this is needed or can retool
        // Assign sourceAttribute value if is button in a repeating section
        /*
        if ((event_info.triggerName.indexOf('repeating_skill_') !== -1 && 
            event_info.htmlAttributes !== undefined) || 
            (event_info.triggerName.indexOf('repeating_active_') !== -1 && 
            event_info.htmlAttributes !== undefined)) {
                const button = event_info.htmlAttributes.name.
                substring(3,event_info.htmlAttributes.name.length);
                event_info.sourceAttribute = `${event_info.sourceAttribute}${button}`;
        }
        */
        // set initial previousValue to 0 or '' to reduce repetitive checking
        event_info.previousValue = 
            event_info.previousValue === event_info.newValue ? 
            Number.isInteger(int(event_info.newValue)) ? 0 :
            typeof event_info.newValue === 'string' || 
            event_info.newValue instanceof String ? '' :
            undefined : event_info.previousValue;

        event_info.newValue = isNaN(event_info.newValue) ?
            event_info.newValue : int(event_info.newValue);
        event_info.previousValue = isNaN(event_info.previousValue) ?
            event_info.previousValue : int(event_info.previousValue);
    }

    function createDatabase(cache, array) {
        const temp = {};
        clog(cache, temp, 'createDatabase()');
        _.chain(array)
            .each(element => { temp[`${element}`] = []; })
            .value();
        return temp;
    }

    function getSourceAttributes(cache, sourceAttribute) {
        const source_attributes = sourceAttribute.split('_');
        cache.originalCaseRowID = source_attributes[2];
        cache.source = sourceAttribute.toLowerCase();
        cache.source_path = `${source_attributes[0]}_${source_attributes[1]}_${source_attributes[2].toLowerCase()}`;
        cache.source_type = source_attributes[0];
        cache.source_section = source_attributes[1];
        cache.source_id = source_attributes[2].toLowerCase();
        cache.source_attribute = source_attributes[3];
    }

    function getAttrKeys(cache) {
        const temp = ['static_sheet_settings_debug','static_sheet_settings_gm'];
        clog(cache, temp, 'getAttrKeys()');
        switch (cache.source_type) {
            case 'repeating':
                switch (cache.source_section) {
                    case 'attribute':
                    case 'defect':
                    case 'skill':
                        switch (cache.source_attribute) {
                            case 'accordion':
                                temp.push(`${cache.source_path}_state`);
                            break;
                            case 'active':
                                temp.push(
                                    'attrdb',
                                    'defectdb',
                                    `${cache.source_path}_${cache.source_section}`,
                                    'groupdb',
                                    'static_group_visible_id'
                                );
                            break;
                        }
                    break;
                }
            break;
            case 'react':
                temp.push(
                    'attrdb',
                    'character_name',
                    'defectdb',
                    'groupdb',
                    'rulesdb',
                    'statsdb',
                    'static_character_details_pronoun'
                );
            break;
            case 'static':
                switch (cache.source_id) {
                    case 'accordion':
                    case 'accordions':
                        temp.push(`${cache.source_path}_state`);
                    break;
                    case 'edit':
                        switch (cache.source_section) {
                            case 'screen':
                                temp.push(
                                    'character_name',
                                    'defectdb',
                                    'groupdb',
                                    'static_character_details_size',
                                    'statsdb'
                                );
                            break;
                            case 'skills':
                                temp.push(
                                    'attrdb',
                                    'defectdb',
                                    'rulesdb',
                                    'statsdb',
                                    //'static_skills_points_total',
                                    'static_skills_visible_id'
                                );
                            break;
                            case 'stats':
                                temp.push(
                                    'attrdb',
                                    'defectdb',
                                    'groupdb',
                                    'rulesdb',
                                    'statsdb'
                                );
                            break;
                            case 'status':
                                temp.push(
                                    'attrdb',
                                    'conditiondb',
                                    'defectdb',
                                    'rulesdb',
                                    'statsdb'
                                );
                            break;
                            case 'attributes':
                                temp.push(
                                    'attrdb',
                                    'defectdb',
                                    'groupdb',
                                    'rulesdb',
                                    'static_group_visible_id',
                                    'statsdb'
                                );
                            break;
                            case 'journal':
                                temp.push(
                                    'journaldb',
                                    'static_journal_visible_id',
                                );
                            break;
                        }
                    break;
                    case 'save':
                    case 'select':
                        switch (cache.source_section) {
                            case 'journal':
                                temp.push(
                                    'journaldb',
                                    'static_journal_page_entry',
                                    'static_journal_page_number',
                                    'static_journal_visible_id'
                                );
                            break;
                        }
                    break;
                    case 'groupselect':
                    case 'grouptoggle':
                        temp.push(
                            'attrdb',
                            'groupdb',
                            'static_group_visible_id',
                            'static_group_type_description'
                        );
                    break;
                    /*
                    case 'help':
                        temp.push('static_sheet_settings_gm');
                    break;
                    */
                    case 'points':
                        temp.push(
                            'statsdb'
                            /*
                            'static_character_points_base',
                            'static_character_points_gained',
                            'static_character_points_temp'
                            */
                        );
                    break;
                    case 'rolls':
                        temp.push(
                            'attrdb',
                            'character_name',
                            'defectdb',
                            'groupdb',
                            'rulesdb',
                            'static_character_details_pronoun',
                            'statsdb'
                        );
                    break;
                    case 'uiselect':
                    case 'uitoggle':
                        temp.push(
                            'attrdb',
                            'static_skills_visible_id'
                        )
                    break;
                    case 'update':
                        temp.push(
                            'attrdb',
                            'conditiondb',
                            'rulesdb'
                        );
                    break;
                }
                switch (cache.source_section) {
                    case 'rules':
                        temp.push(
                            'rulesdb',
                            `${cache.source_path}_status`,
                            'static_rules_base_default'
                        );
                        if (cache.source_id === 'debilitate') {
                            temp.push('rules_optional_criticalhits_status');
                        }
                    break;
                }
            break;
            case 'rules':
                temp.push(
                    'rulesdb',
                    `${cache.source_path}_status`,
                    'static_rules_base_default'
                );
                if (cache.source_id === 'debilitate') {
                    temp.push('rules_optional_criticalhits_status');
                }
            break;
        }
        return temp;
    }

    async function cacheSectionIDs(cache, section) {
        cache[`${section}_ids`] = [];
        cache[`${section}_ids`] = await getSectionIDsAsync(section);
        clog(cache, cache[`${section}_ids`], `getSectionIDs(${section})`);
    }

    function updateSheetRulesSummary(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'updateSheetRulesSummary()');
        if (cache.rulesdb === undefined) { return; }
        const descriptions = {
            attribute:[
                {
                    name:'deathdodge',
                    display:['death dodge']
                },
                {
                    name:'eknockback',
                    display:['enhanced knockback']
                },
                {
                    name:'extradefenses',
                    display:['extra defenses']
                },
                {
                    name:'flankdefense',
                    display:['flank defense']
                },
                {
                    name:'hardboiled',
                    display:['hard boiled']
                },
                {
                    name:'miniobject',
                    display:['mini object']
                },
                {
                    name:'speedburst',
                    display:['speed burst']
                },
            ],
            defect:[
                {
                    name:'nohealing',
                    display:['no healing']
                },
            ],
            enhancement:[
                {
                    name:'absorption',
                    display:['absorption','synergistic']
                },
                {
                    name:'cognition',
                    display:['cognition','area']
                },
                {
                    name:'conversion',
                    display:['conversion','escalate']
                },
                {
                    name:'forcefield',
                    display:['forcefield','air-tight']
                },
                {
                    name:'powerflux',
                    display:['power flux','debuff']
                },
                {
                    name:'sixthsense',
                    display:['sixth sense','range']
                },
                {
                    name:'sizechange',
                    display:['size change','modified shrinking']
                },
                {
                    name:'summoncreatures',
                    display:['summon creatures','area']
                },
                {
                    name:'teleport',
                    display:['teleport','blind']
                },
                {
                    name:'transfer',
                    display:['transfer','area, targets']
                },
                {
                    name:'weapon',
                    display:['weapon','anemic, demoralize, lethargy']
                },
            ],
            homebrew:[
                {
                    name:'ammotracking',
                    display:['ammo tracking']
                },
                {
                    name:'depletereserve',
                    display:['easy deplete']
                },
                {
                    name:'disperse',
                    display:['armor','disperse']
                },
                {
                    name:'specificlimiter',
                    display:['forcefield','specific']
                },
            ],
            limiter:[
                {
                    name:'absorption',
                    display:['absorption','capped']
                },
                {
                    name:'merge',
                    display:['proportional','damage']
                },
                {
                    name:'plantcontrol',
                    display:['plant control','group, species']
                },
                {
                    name:'powerflux',
                    display:['power flux','skill flux']
                },
                {
                    name:'merge',
                    display:['merge','proportional damage']
                },
                {
                    name:'transmute',
                    display:['transmute','material category']
                },
            ],
            optional:[
                {
                    name:'criticalfailures',
                    display:['critical failures']
                },
                {
                    name:'criticalhits',
                    display:['critical hits']
                },
                {
                    name:'enhancedrecovery',
                    display:['enhanced recovery']
                },
                {
                    name:'extradamage',
                    display:['extra damage']
                },
                {
                    name:'individual',
                    display:['individual skills']
                },
                {
                    name:'knockback',
                    display:['knock back']
                },
                {
                    name:'knockout',
                    display:['knock out']
                },
                {
                    name:'mos',
                    display:['margin of success']
                },
                {
                    name:'movementpenalties',
                    display:['movement penalties']
                },
                {
                    name:'rangepenalties',
                    display:['range penalties']
                },
                {
                    name:'seriousinjury',
                    display:['serious injury']
                },
                {
                    name:'shield',
                    display:['striking a sheild']
                },
                { 
                    name:'shockvalue',
                    display:['shock value']
                },
                {
                    name:'spreadinitiative',
                    display:['spread initiative']
                },
                {
                    name:'variable',
                    display:['variable damage']
                },
            ],
            rule_values:[
                {
                    name:'mos-dm',
                    display:['damage modifier adjusted by margin of success']
                },
                {
                    name:'attackroll-dm',
                    display:['damage modifier adjusted by attack roll']
                },
                {
                    name:'damageroll-dm',
                    display:['damage modifier adjusted by additional damage roll']
                },
                {
                    name:'mos-td',
                    display:['total damage adjusted by margin of success']
                },
                {
                    name:'attackroll-td',
                    display:['total damage adjusted by attack roll']
                },
                {
                    name:'damageroll-td',
                    display:['total damage adjusted by additional damage roll']
                },
                {
                    name:'mos',
                    display:['margin of success']
                },
                {
                    name:'natural12',
                    display:['natural 12']
                },
                {
                    name:'natural2',
                    display:['natural 2']
                },
                {
                    name:'exceed',
                    display:['exceed two dice']
                },
            ],
            genre:{
                0:"multi-genre",
                1:"action adventure",
                2:"animal adventures",
                3:"classic horror",
                4:"detective",
                5:"loony cartoons",
                6:"romantic comedy",
                7:"slice of life",
                8:"spy thriller",
                9:"supernatural occult",
                10:"eco fantasy",
                11:"high fantasy",
                12:"low fantasy",
                13:"urban fantasy",
                14:"cyberpunk/realitypunk",
                15:"hard sf",
                16:"mecha drama",
                17:"post-apocalyptic",
                18:"soft sf",
                19:"space opera",
                20:"20th century war",
                21:"age of discovery",
                22:"age of pirates",
                23:"age of samurai",
                24:"ancient mediterranean",
                25:"industrial age",
                26:"middle ages",
                27:"steampunk",
                28:"stone age",
                29:"wild west",
            }
        };
        temp.normalize = ['attribute','defect','enhancement','homebrew','limiter','optional'];
        temp.attribute = '';
        temp.defect = '';
        temp.enhancement = '';
        temp.homebrew = '';
        temp.limiter = '';
        temp.optional = '';
        temp.display = 'Rulebook: ';
        temp.display +=
            cache.rulebook === 'tristatcore' ? 'Tri-Stat Core' :
            cache.rulebook === 'besmx' ? 'BESM Extras' :
            cache.rulebook === 'absolutepower' ? 'Absolute Power' :
            'BESM';
        temp.display += '\n\n';
        temp.rule_keys = Object.keys(cache.rulesdb);
        temp.rule_values = Object.values(cache.rulesdb);
        for (let i = 0; i < temp.rule_values.length; i++) {
            if (
                (isNaN(temp.rule_values[i]) || temp.rule_values[i]) &&
                temp.rule_keys[i] !== 'rules_optional_genre_status'
            ) {
                const key = temp.rule_keys[i].split("_");
                const rule_index = descriptions[key[1]].findIndex(r => {
                    return r.name === key[2];
                });
                const rule_value_index = isNaN(temp.rule_values[i]) ?
                    descriptions.rule_values.findIndex(r => {
                        return r.name === temp.rule_values[i];
                    }) : -1;
                temp.enabled_rule = rule_index !== -1 ?
                    descriptions[key[1]][rule_index].display.length === 1 &&
                    descriptions[key[1]][rule_index].name !== "individual" ?
                        descriptions[key[1]][rule_index].display[0].capitalize() :
                        `${descriptions[key[1]][rule_index].display[0].capitalize()} ` +
                        `(${
                            descriptions[key[1]][rule_index].name === "individual" ?
                                descriptions.genre[cache.rulesdb.rules_optional_genre_status].capitalize() :
                                descriptions[key[1]][rule_index].display[1].capitalize()
                        })`
                    : key[2].capitalize();
                temp.enabled_rule_value = rule_value_index !== -1 ?
                    descriptions.rule_values[rule_value_index].display[0].capitalize() :
                    temp.rule_values[i];
                temp[key[1]] += `  ${temp.enabled_rule}`;
                temp[key[1]] += isNaN(temp.rule_values[i]) ?
                    `: ${temp.enabled_rule_value}` : '';
                temp[key[1]] += '\n';
            }
        }
        for (let i = 0; i < temp.normalize.length; i++) {
            if (temp[temp.normalize[i]].length !== 0) {
                temp.display += 
                    temp.normalize[i] === 'attribute' ||
                    temp.normalize[i] === 'defect' ||
                    temp.normalize[i] === 'enhancement' ||
                    temp.normalize[i] === 'limiter' ? 
                        `Normalized ${temp.normalize[i].capitalize()}s\n` :
                    temp.normalize[i] === 'homebrew' || 
                    temp.normalize[i] === 'optional' ? 
                        `${temp.normalize[i].capitalize()} Rules\n` : '';
                temp.display += `${temp[temp.normalize[i]]}\n`;
            }
        }
        set_values.static_sheet_settings_rules = temp.display;
    }

    /* Character Point Related Functions */
    function setCharacterPointsRemaining(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'setCharacterPointsRemaining()');
        temp.group_points = cache.groupdb.map(g => g.removed ? 0 : g.group_points || 0).reduce((a, b) => a + b, 0);
        const stats = ['body','mind','soul'];
        temp.stat_points = (stats.map(s => cache.statsdb[s].base).reduce((a, b) => a + b, 0)) * 2;
        temp.character_points_spent = temp.stat_points + temp.group_points;
        cache.statsdb.cp.spent = temp.character_points_spent;
        set_values.static_character_points_spent = cache.statsdb.cp.spent;
        set_values.static_character_points_remaining = 
            cache.statsdb.cp.base
            + cache.statsdb.cp.gained
            + cache.statsdb.cp.temp
            - cache.statsdb.cp.spent;
    }
    

    function getSpentCharacterPoints(cache) {
        const temp = {};
        clog(cache, temp, 'getSpentCharacterPoints()');
        temp.group_points = cache.groupdb.map(g => g.removed ? 0 : g.group_points).reduce((a, b) => a + b, 0);
        /*
        for (let i = 0, n = cache.groupdb.length; i < n; i++) {
            temp.group_points += int(cache.groupdb[i].group_points);
        }
        */
        const stats = ['body','mind','soul'];
        temp.stat_points = stats.map(s => cache.statsdb[s].base).reduce((a, b) => a + b, 0);
        /*
        for (let i = 0; i < 3; i++) {
            temp.stat_points += cache.statsdb[stats[i]].base;
        }
        */
        return (temp.stat_points * 2) + temp.group_points;
    }

    /* Attribute Related Fuctions */
    async function setActiveAttribute(cache, set_values) {
        const temp = {};
        clog(cache, temp, `setActiveAttribute(${cache.attribute})`);
        // Collect required values
        temp.get_attrs = [];
        if (!Array.isArray(cache.attribute)) {
            const string_to_array = [];
            string_to_array.push(cache.attribute);
            cache.attribute = string_to_array;
        }
        // Calculate Base Value
        for (let i = 0, n = cache.attribute.length; i < n; i++) {
            switch(cache.attribute[i]) {
                case 'attack mastery':
                    if (cache.acv === undefined) {
                        cache.acv = Math.round((
                            cache.statsdb.body.base +
                            cache.statsdb.mind.base +
                            cache.statsdb.soul.base
                        ) / 3);
                    }
                break;
                case 'combat technique':
                    for (let i = 0, n = temp.attrdb.config.length; i < n; i++) {
                        switch (temp.attrdb.config[i].name) {
                            case 'hardboiled':
                                cache.shockvalue =
                                    cache.statsdb.body.base +
                                    cache.statsdb.soul.base;
                            break;
                        }
                    }
                break;
                case 'defense mastery':
                    if (cache.dcv === undefined) {
                        cache.dcv = Math.round((
                            cache.statsdb.body.base +
                            cache.statsdb.mind.base +
                            cache.statsdb.soul.base
                        ) / 3);
                    }
                break;
                case 'energized':
                    if (cache.energy === undefined) {
                        cache.energy = (
                            cache.statsdb.mind.base +
                            cache.statsdb.soul.base
                        ) * 5;
                    }
                break;
                case 'massive damage':
                    cache.dm = 5;
                break;
                case 'social mastery':
                    if (cache.society === undefined) {
                        const scv = Math.round((
                            cache.statsdb.mind.base +
                            cache.statsdb.soul.base
                        ) / 2);
                        cache.scv = scv;
                        cache.society = scv;
                    }
                break;
                case 'tough':
                    if (cache.health === undefined) {
                        cache.health = (
                            cache.statsdb.body.base +
                            cache.statsdb.soul.base
                        ) * 5;
                    }
                break;
                case 'unassailable':
                    if (cache.sanity === undefined) {
                        cache.sanity =
                            cache.statsdb.mind.base +
                            cache.statsdb.soul.base;
                    }
                break;
            }
            // Apply values
            switch(cache.attribute[i]) {
                case 'attack mastery':
                    cache.attrdb[cache.attribute[i]].forEach(a => {
                        if (a.active) {
                            cache.acv += a.elevel;
                        }
                    });
                break;
                case 'combat technique':
                    cache.hardboiled = 0;
                    cache.reflexes = 0;
                    cache.attrdb[cache.attribute[i]].forEach(a => {
                        for (let i = 0, n = a.config.length; i < n; i++) {
                            switch (a.config[i].name) {
                                case 'hardboiled':
                                    cache.attribute.unshift('hardboiled');
                                    if (a.active) {
                                        cache.hardboiled += (a.config[i].rank * 10);
                                    }
                                break;
                                /*
                                case 'lightning reflexes':
                                    cache.attribute.unshift('lightning reflexes');
                                    if (a.active) {
                                        cache.reflexes += (a.config[i].rank);
                                    }
                                break;
                                */
                            }
                        }
                    });
                    cache.hardboiled = Math.min(cache.hardboiled, cache.shockvalue / 2);
                    cache.shockvalue = cache.shockvalue + cache.hardboiled;
                break;
                case 'defense mastery':
                    cache.attrdb[cache.attribute[i]].forEach(a => {
                        if (a.active) {
                            cache.dcv += a.elevel;
                        }
                    });
                break;
                case 'extra actions':
                    cache.actions = 1;
                    cache.attrdb[cache.attribute[i]].forEach(a => {
                        if (a.active) {
                            cache.actions += a.elevel;
                        }
                    });
                break;
                case 'extra defenses':
                    cache.defenses = 0;
                    cache.attrdb[cache.attribute[i]].forEach(a => {
                        if (a.active) {
                            cache.defenses += a.elevel;
                        }
                    });
                break;
                case 'energized':
                    cache.attrdb[cache.attribute[i]].forEach(a => {
                        if (a.active) {
                            cache.energy += (a.elevel * 10);
                        }
                    });
                break;
                case 'massive damage':
                    cache.attrdb[cache.attribute[i]].forEach(a => {
                        if (a.active) {
                            const limited = a.limiters.find(l => {
                                return l.name === 'focussed damage' || l.name === 'targetted damage';
                            });
                            if (limited === undefined) { cache.dm += a.elevel; }
                        }
                    });
                break;
                case 'social mastery':
                    cache.attrdb[cache.attribute[i]].forEach(a => {
                        if (a.active) {
                            const scv = a.elevel * 2;
                            cache.scv += scv;
                            cache.society += scv;
                        }
                    });
                break;
                case 'tough':
                    cache.attrdb[cache.attribute[i]].forEach(a => {
                        if (a.active) {
                            cache.health += (a.elevel * 10);
                        }
                    });
                break;
                case 'unassailable':
                    cache.attrdb[cache.attribute[i]].forEach(a => {
                        if (a.active) {
                            cache.sanity += (a.elevel * 2);
                        }
                    });
                break;
            }
        }
        if (
            cache.attribute[0] === 'energized' ||
            cache.attribute[0] === 'tough' ||
            cache.attribute[0] === 'unassailable' ||
            cache.attribute[0] === 'social mastery'
        ) {
            const derived_values = {
                'energized':'energy',
                'tough':'health',
                'unassailable':'sanity',
                'social mastery':'society',
            };
            const point_max = 
                cache[derived_values[cache.attribute[0]]] + 
                cache.statsdb[derived_values[cache.attribute[0]].temp];
            const point_loss = 
                cache.statsdb[derived_values[cache.attribute[0]].damage] + 
                cache.statsdb[derived_values[cache.attribute[0]].stun];
            setStatusStateDescription(cache, set_values, derived_values[cache.attribute[0]], point_max, point_loss);
        }
    }

    function getSizeTemplate(cache) {
        const size = {};
        clog(cache, size, 'getSizeTemplate()');
        size.name = cache.static_character_details_size.toLowerCase();
        const templates = [
            {name:'point',rank:-10,height:{min:['100','4'],max:['400','16'],unit:['micrometers','thousands of an inch'],unit_abv:['μm','thou']},mass:{min:['1','0.007'],max:['40','0.3'],unit:['micrograms','doite'],unit_abv:['μg','doite']},lift:0.0000002,dm:-100,ar:100,ranged:20,speed:0.001},
            {name:'mote',rank:-9,height:{min:['500','20'],max:['900','35'],unit:['micrometers','thousands of an inch'],unit_abv:['μm','thou']},mass:{min:['50','0.4'],max:['500','3.7'],unit:['micrograms','doite'],unit_abv:['μg','doite']},lift:0.000001,dm:-90,ar:90,ranged:18,speed:0.002},
            {name:'speck',rank:-8,height:{min:['1','40'],max:['4','160'],unit:['millimeters','thousands of an inch'],unit_abv:['mm','thou']},mass:{min:['1','0.3'],max:['5','1.5'],unit:['milligrams','mite'],unit_abv:['mg','mite']},lift:0.000004,dm:-80,ar:80,ranged:16,speed:0.004},
            {name:'minute',rank:-7,height:{min:['5','200'],max:['9','350'],unit:['millimeters','thousands of an inch'],unit_abv:['mm','thou']},mass:{min:['6','2'],max:['40','12.3'],unit:['milligrams','mite'],unit_abv:['mg','mite']},lift:0.00002,dm:-70,ar:70,ranged:14,speed:0.008},
            {name:'wee',rank:-6,height:{min:['1','0.5'],max:['2','1'],unit:['centimeters','inches'],unit_abv:['cm','in']},mass:{min:['50','15.5'],max:['500','155'],unit:['milligrams','mite'],unit_abv:['mg','mite']},lift:0.0001,dm:-60,ar:60,ranged:12,speed:0.01667},
            {name:'teeny',rank:-5,height:{min:['3','1.1'],max:['4','1.5'],unit:['centimeters','inches'],unit_abv:['cm','in']},mass:{min:['1','0.5'],max:['5','3'],unit:['grams','dram'],unit_abv:['g','dr']},lift:0.0004,dm:-50,ar:50,ranged:10,speed:0.0333},
            {name:'fine',rank:-4,height:{min:['5','2'],max:['9','3.5'],unit:['centimeters','inches'],unit_abv:['cm','in']},mass:{min:['6','3.5'],max:['30','17'],unit:['grams','dram'],unit_abv:['g','dr']},lift:0.002,dm:-40,ar:40,ranged:8,speed:0.06667},
            {name:'diminutive',rank:-3,height:{min:['10','4'],max:['24','9'],unit:['centimeters','inches'],unit_abv:['cm','in']},mass:{min:['50','28'],max:['300','170'],unit:['grams','dram'],unit_abv:['g','dr']},lift:0.01,dm:-30,ar:30,ranged:6,speed:0.125},
            {name:'tiny',rank:-2,height:{min:['25','10'],max:['49','19'],unit:['centimeters','inches'],unit_abv:['cm','in']},mass:{min:['0.5','1'],max:['2','4'],unit:['kilograms','pounds'],unit_abv:['kg','lb']},lift:0.04,dm:-20,ar:20,ranged:4,speed:0.25},
            {name:'small',rank:-1,height:{min:['50','20'],max:['99','38'],unit:['centimeters','inches'],unit_abv:['cm','in']},mass:{min:['6','13'],max:['20','44'],unit:['kilograms','pounds'],unit_abv:['kg','lb']},lift:0.2,dm:-10,ar:10,ranged:2,speed:0.5},
            {name:'medium',rank:0,height:{min:['1','39'],max:['2','79'],unit:['meters','inches'],unit_abv:['m','in']},mass:{min:['50','110'],max:['150','330'],unit:['kilograms','pounds'],unit_abv:['kg','lb']},lift:0,dm:0,ar:0,ranged:0,speed:0},
            {name:'large',rank:1,height:{min:['3','118'],max:['4','157'],unit:['meters','inches'],unit_abv:['m','in']},mass:{min:['200','440'],max:['1200','2650'],unit:['kilograms','pounds'],unit_abv:['kg','lb']},lift:5,dm:10,ar:10,ranged:-2,speed:2},
            {name:'huge',rank:2,height:{min:['5','197'],max:['8','315'],unit:['meters','inches'],unit_abv:['m','in']},mass:{min:['1.5','1.5'],max:['8','8'],unit:['tonnes','tons'],unit_abv:['t','lt']},lift:25,dm:20,ar:20,ranged:-4,speed:4},
            {name:'mammoth',rank:3,height:{min:['9','345'],max:['15','591'],unit:['meters','inches'],unit_abv:['m','in']},mass:{min:['10','10'],max:['60','60'],unit:['tonnes','tons'],unit_abv:['t','lt']},lift:100,dm:30,ar:30,ranged:-6,speed:8},
            {name:'gigantic',rank:4,height:{min:['16','17'],max:['30','34'],unit:['meters','yards'],unit_abv:['m','yd']},mass:{min:['75','75'],max:['500','500'],unit:['tonnes','tons'],unit_abv:['t','lt']},lift:500,dm:40,ar:40,ranged:-8,speed:15},
            {name:'gargantuan',rank:5,height:{min:['31','35'],max:['60','69'],unit:['meters','yards'],unit_abv:['m','yd']},mass:{min:['550','550'],max:['4000','4000'],unit:['tonnes','tons'],unit_abv:['t','lt']},lift:2500,dm:50,ar:50,ranged:-10,speed:30},
            {name:'colossal',rank:6,height:{min:['61','70'],max:['125','139'],unit:['meters','yards'],unit_abv:['m','yd']},mass:{min:['4','4'],max:['30','30'],unit:['kilotonnes','thousand of tons'],unit_abv:['kt',',000 lt']},lift:10000,dm:60,ar:60,ranged:-12,speed:60},
            {name:'enormous',rank:7,height:{min:['126','140'],max:['250','274'],unit:['meters','yards'],unit_abv:['m','yd']},mass:{min:['40','40'],max:['250','250'],unit:['kilotonnes','thousand of tons'],unit_abv:['kt',',000 lt']},lift:50000,dm:70,ar:70,ranged:-14,speed:125},
            {name:'monstrous',rank:8,height:{min:['251','275'],max:['500','549'],unit:['meters','yards'],unit_abv:['m','yd']},mass:{min:['0.3','0.3'],max:['2','2'],unit:['millions of tonnes','millions of tons'],unit_abv:['MT',',000,000 lt']},lift:25000,dm:80,ar:80,ranged:-16,speed:250},
            {name:'titanic',rank:9,height:{min:['501','550'],max:['1000','1100'],unit:['meters','yards'],unit_abv:['m','yd']},mass:{min:['2','2'],max:['15','15'],unit:['millions of tonnes','millions of tons'],unit_abv:['MT',',000,000 lt']},lift:1000000,dm:90,ar:90,ranged:-18,speed:500},
            {name:'monumental',rank:10,height:{min:['1','0.6'],max:['2','1.2'],unit:['kilometers','miles'],unit_abv:['km','mi']},mass:{min:['15','15'],max:['125','125'],unit:['millions of tonnes','millions of tons'],unit_abv:['MT',',000,000 lt']},lift:5000000,dm:100,ar:100,ranged:-20,speed:1000},
        ];
        size.template = templates.find(t => {
            return t.name === size.name;
        });
        return size.template;
    }

    function customizationsToString(cache, customizations = []) {
        const temp = {};
        clog(cache, temp, 'customizationsToString()');
        temp.customization_string = '';
        for (let i = 0, n = customizations.length; i < n; i++) {
            temp.customization_string += `${customizations[i].name}: ` +
            `${customizations[i].rank}\n`;
        }
        return temp.customization_string;
    }

    /* Condition Related Functions */
    async function buildConditionsMenu(cache) {
        const temp = {
            menu: '',
            condition: '',
            conditions: [
                'anemic',
                'blinded',
                'contagious',
                'continuing',
                'dead',
                'demoralized',
                'drained',
                'incapacitated',
                'incurable',
                'irritant',
                'lethargic',
                'prone',
                'serious injury',
                'stunned',
                'tangled',
                'unconscious'
            ],
        };
        clog(cache, temp, 'buildConditionsMenu()');
        for (let i = 0, n = temp.conditions.length; i < n; i++) {
            temp.condition = getTranslationByKey(`${temp.conditions[i]}`);
            temp.condition_name = temp.condition.capitalize();//capitalize(temp.condition);
            temp.menu += `|${temp.condition_name},${temp.conditions[i]}`;
        }
        temp.menu += `|${getTranslationByKey("go-back")},conditions`;
        return temp.menu;
    }

    async function buildActiveConditionsMenu(cache) {
        const temp = {
            active_conditions: {},
            attrs_to_get: [],
            conditions: [],
            condition_ids: [],
            menu: ''
        };
        clog(cache, temp, 'buildActiveConditionsMenu()');
        temp.condition_ids = await getSectionIDsAsync('condition');
        for (let i =0, n = temp.condition_ids.length; i < n; i++) {
            temp.attrs_to_get.push(`repeating_condition_${temp.condition_ids[i]}_name`);
        }
        temp.active_conditions = await getAttrsAsync(temp.attrs_to_get);
        temp.conditions = Object.values(temp.active_conditions);
        for (let i = 0, n = temp.conditions.length; i < n; i++) {
            const condition = temp.conditions[i].toLowerCase();
            const condition_name = getTranslationByKey(`${condition}`).capitalize();//capitalize(getTranslationByKey(`${condition}`));
            temp.menu += `|${condition_name},${temp.conditions[i]}~${temp.condition_ids[i]}`;
        }
        temp.menu += `|${getTranslationByKey("go-back")},conditions`;
        return temp.menu;
    }

    async function getConditionDamage(cache) {
        const temp = {};
        clog(cache, temp, 'getConditionDamage()');
        temp.title = 'Enter damage amount';
        temp.options = '';
        await crpQuery(cache, temp);
        return temp.selection;
    }

    async function getConditionUserInput(cache, condition, input) {
        const temp = {};
        clog(cache, temp, 'getConditionUserInput()');
        clog(cache, condition);
        clog(cache, input);
        temp.titles = [
            {},
            {// input 1
                'blinded':'enter-amount-roll-failed-by',
                'contagious':'select-contagion',
                'continuing':'enter-number-of-rounds',
                'demoralized':'enter-combat-value-loss',
                'drained':'select-stat-affected',
                'incapacitated':'select-time-scale',
                'incurable':'enter-damage-amount',
                'lethargic':'choose-movement-environment',
                'tangled':'enter-tangle-health-points',
                'unconscious':'enter-number-of-rounds',
                'default':''
            },
            {// input 2
                'continuing':'select-time-scale',
                'drained':'enter-amount-stat-drains-by',
                'incurable':'select-limited-healing',
                'default':''
            },
            {// input 3
                'continuing':'enter-damage-amount',
                'default':''
            }
        ];
        temp.title = 
            getTranslationByKey(`${temp.titles[input][condition]}`) || 
            temp.titles[input]['default'];
        temp.options_available = [
            {},
            {// input 1
                'contagious':`|${getTranslationByKey("damage")},damage` +
                    `|${getTranslationByKey("anemic")},anemic|${getTranslationByKey("blinded")},blinded` +
                    `|${getTranslationByKey("continuing")},continuing|${getTranslationByKey("demoralized")},demoralized` +
                    `|${getTranslationByKey("drain")},drain|${getTranslationByKey("enervation")},enervation` +
                    `|${getTranslationByKey("flare")},flare|${getTranslationByKey("incapacitating")},incapacitating` +
                    `|${getTranslationByKey("incurable")},incurable|${getTranslationByKey("irritant")},irritant` +
                    `|${getTranslationByKey("lethargic")},lethargic|${getTranslationByKey("tangled")},tangled`,
                'drained':`|${getTranslationByKey("body")},body|${getTranslationByKey("mind")},mind|${getTranslationByKey("soul")},soul`,
                'incapacitated':`|${getTranslationByKey("round")},round|${getTranslationByKey("minute-time")},minute-time`,
                'lethargic':`|${getTranslationByKey("air")},air|${getTranslationByKey("ground")},ground` +
                    `|${getTranslationByKey("space")},space|${getTranslationByKey("water")},water`,
                'default':''
            },
            {// input 2
                'continuing':
                    `|${getTranslationByKey("per-round")},${getTranslationByKey("rounds")}` +
                    `|${getTranslationByKey("per-hour")},${getTranslationByKey("every-hour-target-number-15")}` +
                    `|${getTranslationByKey("per-day")},${getTranslationByKey("every-day-target-number-15")}`,
                'incurable':
                    `|${getTranslationByKey("natural-healing").capitalize()},${getTranslationByKey("natural-healing")}` +
                    `|${getTranslationByKey("slowed-natural-healing").capitalize()},${getTranslationByKey("slowed-natural-healing")}` +
                    `|${getTranslationByKey("special-event").capitalize()},${getTranslationByKey("special-event")}`,
                    /*
                    `|${capitalize(getTranslationByKey("natural-healing"))},${getTranslationByKey("natural-healing")}` +
                    `|${capitalize(getTranslationByKey("slowed-natural-healing"))},${getTranslationByKey("slowed-natural-healing")}` +
                    `|${capitalize(getTranslationByKey("special-event"))},${getTranslationByKey("special-event")}`,
                    */
                'default':''
            },
            {// input 3
                'default':''
            }
        ];
        temp.options = 
            temp.options_available[input][condition] || 
            temp.options_available[input]['default'];
        await crpQuery(cache, temp);
        if (condition === 'demoralized' || condition === 'drained' && 
            !isNaN(temp.selection) && temp.selection > 0) {
                temp.selection = temp.selection * -1;
        }
        if (condition === 'drained' && isNaN(temp.selection)) {
            temp.selection = temp.selection.capitalize();//capitalize(temp.selection);
        }
        return temp.selection;
    }

    function getIsUserInputRequired(condition) {
        const user_input_required = /(blinded|contagious|continuing|demoralized|drained|incapacitated|incurable|lethargic|tangled|unconscious)/;
        return user_input_required.test(condition);
    }

    async function setContagion(cache, set_values, contagion) {
        const temp = {};
        clog(cache, temp, 'setContagion()');
        clog(cache, contagion, '>>>TEST(contagion)');
        temp.id = generateRowID();
        if (getIsUserInputRequired(contagion.input1)) {
            temp.input1 = await getConditionUserInput(cache, contagion.input1, 1) || '';
            temp.input2 = await getConditionUserInput(cache, contagion.input1, 2) || '';
            temp.input3 = await getConditionUserInput(cache, contagion.input1, 3) || '';
        } else if (contagion.input1 === 'anemic') {
            temp.input1 = -1;
        } else if (contagion.input1 === 'serious injury') {
            temp.input1 = getTranslationByKey("round-or-minute-out-of-combat");
        }
        if (contagion.input1 === 'blinded') {
            temp.input2 = await getSenses(cache);
        } else if (contagion.input1 === 'lethargic') {
            temp.input2 = getLethargicReduction(cache, temp, contagion.input1);
        }
        set_values[`repeating_condition_${temp.id}_name`] = 
        `${contagion.input1.capitalize()}`;//`${capitalize(contagion.input1)}`;
        set_values[`repeating_condition_${temp.id}_description`] = 
            await getConditionDescription(cache, contagion.input1, temp);
        temp.id = temp.id.toLowerCase();
        cache.conditiondb[contagion].push(temp);
        return {
            input1: temp.input1 || '',
            input2: temp.input2 || '',
            input3: temp.input3 || '',
        };
    }

    async function setConditiondb(cache, set_values, condition) {
        const temp = {};
        clog(cache, temp, 'setConditiondb()');
        // Determin if condition is new, and if not then find existing condition to update.
        temp.is_new = true;
        if (cache.condition_ids.indexOf(cache.condition_id.toLowerCase()) !== -1) {
            temp.is_new = false;
            temp.i = cache.conditiondb[condition].findIndex(c => {
                return c.id.toLowerCase() === cache.condition_id.toLowerCase();
            });//getArrayPositionByID(cache, cache.conditiondb[condition], cache.condition_id);
        }
        // Get any required input from player.
        if (getIsUserInputRequired(condition)) {
            temp.input1 = cache.input1 === undefined ?
                await getConditionUserInput(cache, condition, 1) : cache.input1;
            temp.input2 = cache.input2 === undefined ?
                await getConditionUserInput(cache, condition, 2) : cache.input2;
            temp.input3 = cache.input3 === undefined ?
                await getConditionUserInput(cache, condition, 3) : cache.input3;
        } else if (condition === 'anemic') {
            temp.input1 = temp.is_new ? -1 : cache.conditiondb[condition][0].input1 -= 1;
        } else if (condition === 'serious injury') {
            temp.input1 = getTranslationByKey("round-or-minute-out-of-combat");
        }
        if (condition === 'blinded') {
            temp.input2 = await getSenses(cache);
        } else if (condition === 'lethargic') {
            temp.input2 = getLethargicReduction(cache, temp, condition);
        } else if (condition === 'contagious' && temp.input1 === 'damage' || 
        temp.input1 === 'enervation') {
            temp.input2 = await getConditionDamage(cache);
        }
        if (condition === 'lethargic' && !temp.is_new) {
            cache.conditiondb[condition][temp.i].input2 = temp.input2;
        } else {
            temp[`${condition}`] = {
                input1: temp.input1 || '',
                input2: temp.input2 || '',
                input3: temp.input3 || '',
                id: cache.condition_id.toLowerCase(),
                duration: Infinity,
            };
            if (condition === 'contagious' && temp.input1 !== 'damage' && 
            temp.input1 !== 'enervation') {
                temp[`${condition}`].contagion = 
                await setContagion(cache, set_values, temp);
            }
            if (temp.is_new) {
                temp[`${condition}`].duration = 
                condition === 'anemic' || condition === 'demoralized' ||
                condition === 'irritant' || condition === 'lethargic' ? 20 :
                condition === 'blinded' || condition === 'unconscious' ||
                condition === 'continuing' && temp.input2 === "rounds" ? temp.input1 :
                condition === 'incapacitated' && temp.input1 === 'round' ? 1 :
                condition === 'incapacitated' && temp.input1 === 'minute-time' ? 20 :
                condition === 'drained' ? (temp.input2 * -1) * 1200 : Infinity;
                cache.conditiondb[condition].push(temp[condition]);
                if (condition === 'drained') {
                    const drained = {};
                    drained.answer = temp.input2 * -1;
                    drained.stat = temp.input1.toLowerCase();
                    drained.point_type = 'damage';
                    drained.point_method = 'set';
                    await setStat(cache, drained, set_values);
                    await setDerivedValues(cache, set_values);
                }
            } else {
                cache.conditiondb[condition][temp.i] = temp[condition];
            }
        }
    }

    async function getSenses(cache) {
        const temp = {};
        clog(cache, temp, 'getSenses()');
        temp.senses = ['hearing','sight','smell','taste','touch'];
        temp.title = 'Select Senses';
        temp.options = '';
        temp.result = '';
        temp.exit = false;
        while (temp.exit === false) {
            temp.options = '';
            for (let i = 0, n = temp.senses.length; i < n; i++) {
                temp.options += 
                    `|${getTranslationByKey(temp.senses[i]).capitalize()},${getTranslationByKey(temp.senses[i])}`;
                    //`|${capitalize(getTranslationByKey(temp.senses[i]))},${getTranslationByKey(temp.senses[i])}`;
            }
            temp.options += `|${getTranslationByKey("done-finished").capitalize()},done`;
            //`|${capitalize(getTranslationByKey("done-finished"))},done`;
            await crpQuery(cache, temp);
            if (temp.selection === 'done') {
                temp.exit = true;
            } else {
                temp.senses.splice(temp.senses.indexOf(temp.selection), 1);
            }
            temp.comma = temp.senses.length !== 4 ? ', ' : '';
            temp.result += temp.selection !== 'done' ?
                `${temp.comma}${temp.selection.capitalize()}` : '';
                //`${temp.comma}${capitalize(temp.selection)}` : '';
            if (temp.senses.length === 0) temp.exit = true;
        }
        return temp.result;
    }

    async function getStats(cache, query) {
        const temp = {};
        clog(cache, temp, 'getStats()');
        //temp.stats = ['body','mind','soul'];
        temp.result = query.result !== undefined ? [...query.result] : [];
        temp.exit = false;
        temp.title_static = getTranslationByKey("choose-stats");
        temp.options = '';
        while (temp.exit === false) {
            temp.title = `${temp.title_static}. Selected [${
                temp.result.length === 0 ? 'None' : temp.result.join(', ').capitalize()
            }]`;
            temp.options = temp.result.length === 0 ?
                '' : `|${getTranslationByKey("done-finished").capitalize()},done`;
            for (let i = 0; i < all_stats.length; i++) {
                temp.bracket = temp.result.indexOf(all_stats[i]) !== -1 ? 
                    true : false;
                temp.options += 
                    `|${temp.bracket ? '[' : ''}` +
                    `${getTranslationByKey(all_stats[i]).capitalize()}` +
                    `${temp.bracket ? ']' : ''}` +
                    `,${all_stats[i]}`;
            }
            await crpQuery(cache, temp);
            if (temp.selection === 'done') {
                temp.exit = temp.result.length !== 0 ? true : false;
            } else {
                temp.index = temp.result.indexOf(temp.selection);
                if (temp.index !== -1) {
                    temp.result.splice(temp.index, 1);
                } else {
                    temp.result.push(temp.selection);
                }
            }
        }
        return temp.result;
    }

    function getMarginOfSuccess(cache, result, target = 0) {
        const temp = {};
        clog(cache, temp, 'getMarginOfSuccess()');
        temp.result = result < 0 ? 'failure' : 'success';
        if (cache.rulesdb.rules_optional_mos_status) {
            temp.margin = temp.result === 'failure' ? result * -1 : result;
            switch (temp.margin) {
                case 23:
                case 22:
                case 21:
                case 20:
                case 19:
                case 18:
                    temp.mos = 'extreme';
                break;
                case 17:
                case 16:
                case 15:
                case 14:
                case 13:
                case 12:
                    temp.mos = 'major';
                break;
                case 11:
                case 10:
                case 9:
                case 8:
                case 7:
                case 6:
                    temp.mos = 'significant';
                break;
                case 5:
                case 4:
                case 3:
                    temp.mos = 'moderate';
                break;
                case 2:
                case 1:
                    temp.mos = 'slight';
                break;
                case 0:
                    temp.mos = 'tie-or-slim';
                break;
                default:
                    temp.mos = 'monstrous';
            }
            return `${getTranslationByKey(temp.mos)} ${getTranslationByKey(temp.result)}`;
        } else {
            return getTranslationByKey(temp.result);//temp.result;
        }
        
    }

    function setSkillsPointTotal(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'setSkillsPointTotal()');
        temp.skills = cache.attrdb.skills[cache.skill_index].individual;
        temp.spent = temp.skills.map(s => s.points).reduce((a, b) => a + b, 0);
        temp.spent += temp.skills.map(s => s.specializations.length - 1).reduce((a, b) => a + b, 0);
        temp.index = cache.attrdb.skills[cache.skill_index].config.findIndex(c => c.name === 'skill points');
        temp.total = cache.attrdb.skills[cache.skill_index].config[temp.index].rank;
        set_values.static_skills_points_remaining = temp.total - temp.spent;
    }

    function setGroupCharacterPoints(cache, set_values, group_id) {
        const temp = {};
        clog(cache, temp, 'setGroupCharacterPoints()');
        temp.spent = 0;
        temp.group_id = int(group_id);
        for (let i = 0; i < all_attributes.length; i++) {
            const attribute = cache.attrdb[all_attributes[i]];
            for (let j = 0; j < attribute.length; j++) {
                temp.spent += attribute[j].group_id === temp.group_id ?
                    attribute[j].points : 0;
            }
        }
        for (let i = 0; i < all_defects.length; i++) {
            const defect = cache.defectdb[all_defects[i]];
            for (let j = 0; j < defect.length; j++) {
                temp.spent += defect[j].group_id === temp.group_id ?
                defect[j].points : 0;
            }
        }
        temp.group_points = 
            cache.groupdb[temp.group_id].origin === 'item' ||
            cache.groupdb[temp.group_id].origin === 'shield' ? 
                Math.max(Math.floor(temp.spent/2), 0) :
            cache.groupdb[temp.group_id].origin === 'gear' ? 
                cache.groupdb[temp.group_id].level : temp.spent;
        cache.groupdb[temp.group_id].group_points = temp.group_points;
        if (cache.static_group_visible_id === temp.group_id) {
            set_values.static_attributes_group_points = temp.group_points;
        }
    }

    function getLethargicReduction(cache, user_data, condition) {
        const temp = {};
        clog(cache, temp, 'getLethargicReduction()');
        temp.condition_data = cache.conditiondb[condition].find(c => {
            return c.input1 === user_data.input1;
        });
        if (temp.condition_data === undefined) {
            temp.input2 = 0.5;
        } else {
            temp.input2 = temp.condition_data.input2 / 2;
            cache.condition_id = temp.condition_data.id;
            user_data.is_new = false;
            user_data.i = cache.conditiondb[condition].findIndex(c => {
                return c.id.toLowerCase() === cache.condition_id.toLowerCase();
            });//getArrayPositionByID(cache, cache.conditiondb[condition], cache.condition_id);
        }
        /*
        user_data.input2 = temp.condition_data === undefined ?
            0.5 : temp.condition_data.input2 / 2;
        cache.condition_id = temp.condition_data === undefined ?
            cache.condition_id : temp.condition_data.id;
        */
        return temp.input2;
    }

    function removeConditiondbEntry(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'removeConditiondbEntry()');
        temp.i = cache.conditiondb[cache.condition.name].findIndex(c => {
            return c.id === cache.condition.id;
        });
        cache.conditiondb[cache.condition.name].splice([temp.i], 1);
        //set_values.conditiondb = JSON.stringify(cache.conditiondb);
    }

    async function setConditionAnemic(cache, temp) {
        clog(cache, temp, 'setConditionAnemic()');
        temp.input1 = -1;
    }
  
    async function getConditionDescription(cache, condition, contagion = false) {
        const temp = {};
        clog(cache, temp, 'getConditionDescription()');
        if (!contagion) {
            cache.conditiondb[condition].find( c => {
                if (c.id === cache.condition_id.toLowerCase()) {
                    temp.input1 = c.input1;
                    temp.input2 = c.input2;
                    temp.input3 = c.input3;
                    temp.id = c.id;
                };
            });
            if (condition === 'contagious') {
                temp.contagion = 
                temp.input1 === 'damage' || temp.input1 === 'enervation' ?
                    `${temp.input2} ${temp.input1}` : temp.input1;
            }
        } else {
            Object.assign(temp, contagion);           
        }
        const duration_descriptions = {
            'anemic':'one-minute-or-dramatic-scene',
            'blinded':'rounds',
            'contagious':'until-negated',
            'continuing':`${temp.input1} ${temp.input2}`,
            'dead':'permanent',
            'demoralized':'one-minute-or-dramatic-scene',
            'drained':'recovered-per-hour',
            'incapacitated':`${temp.input1}`,
            'incurable':'until-damage-is-healed',
            'irritant':'one-minute-or-dramatic-scene',
            'lethargic':'one-minute-or-dramatic-scene',
            'prone':'requires-a-general-action-to-stand-up',
            'serious injury':'until-successful-surgery',
            'stunned':'requires-a-general-action-to-recover',
            'tangled':'health-points-of-tangle-must-be-destroyed',
            'unconscious':'rounds',
        };
        const effect_descriptions = {
            'anemic':'damage-multiplier-u',
            'blinded':'blinded',
            'contagious':'to-others-who-touch-or-otherwise-contact-the-character',
            'continuing':'damage',
            'dead':'cannot-take-any-actions',
            'demoralized':'attack-combat-value-and-defensive-combat-value',
            'drained':`${temp.input2} ${temp.input1}`,
            'incapacitated':'completely-immobilized',
            'incurable':`${temp.input2}`,
            'irritant':'minor-obstacle-on-all-stat-and-skill-rolls',
            'lethargic':'movement-reduced',
            'prone':'minor-obstacle-to-attack-or-defend',
            'serious injury':'negative-one-health-point-every',
            'stunned':'cannot-do-anything-but-defend',
            'tangled':'major-obstacle-to-any-movement-related-roll',
            'unconscious':'cannot-take-any-actions',
        };
        const prefixed_conditions = ['blinded','continuing','incurable','tangled','unconscious'];
        temp.description = `${getTranslationByKey("duration").capitalize()}: `;
        //`${capitalize(getTranslationByKey("duration"))}: `;
        temp.description += 
            condition === 'continuing' ?`${temp.input1} ${temp.input2}; ` :
            condition === 'drained' ? `+1 ${temp.input1} ` +
            `${getTranslationByKey(duration_descriptions[condition])}; ` :
            condition === 'incapacitated' ? `1 ` +
            `${getTranslationByKey(duration_descriptions[condition])}; ` :
            condition === 'incurable' ? `` +
            `${getTranslationByKey(duration_descriptions[condition])} ` +
            `[${temp.input1}]; ` :
            prefixed_conditions.indexOf(condition) !== -1 ? `${temp.input1} ` +
            `${getTranslationByKey(duration_descriptions[condition])}; ` :
            `${getTranslationByKey(duration_descriptions[condition])}; `;
        temp.description += `${getTranslationByKey("effect").capitalize()}: `;
        //`${capitalize(getTranslationByKey("effect"))}: `;
        temp.description += 
            condition === 'anemic' || 
            condition === 'demoralized' ? `${temp.input1} ` +
            `${getTranslationByKey(effect_descriptions[condition])}` :
            condition === 'blinded' ? `${temp.input2} ` +
            `${getTranslationByKey(effect_descriptions[condition])}` :
            condition === 'contagious' ? `${temp.contagion} ` +
            `${getTranslationByKey(effect_descriptions[condition])}` :
            condition === 'continuing' ? `${temp.input3} ` +
            `${getTranslationByKey(effect_descriptions[condition])}` :
            condition === 'drained' ? `${temp.input2} ${temp.input1}` :
            condition === 'incurable' ? `${temp.input2}` :
            condition === 'lethargic' ? `${temp.input1} ` +
            `${getTranslationByKey(effect_descriptions[condition])} ` +
            `${(1 - temp.input2) * 100}%` :
            condition === 'serious injury' ? 
            `${getTranslationByKey(effect_descriptions[condition])} ` +
            `${temp.input1}` :
            `${getTranslationByKey(effect_descriptions[condition])}`;
        return temp.description;
    }

    function getConditionType(cache, condition) {
        const temp = {};
        clog(cache, temp, 'getConditionType()');
        temp.cumulative = ['anemic','demoralized','drained'];
        temp.stackable = ['blinded','contagious','continuing','incurable','lethargic','serious injury','tangled'];
        temp.type = 
            temp.cumulative.indexOf(condition) !== -1 ? 'cumulative' :
            temp.stackable.indexOf(condition) !== -1 ? 'stackable' :
            'unique';
        return temp.type;
    }

    function getConditionID(cache, condition) {
        const temp = {};
        clog(cache, temp, 'getConditionID()');
        switch(getConditionType(cache, condition)) {
            case 'cumulative':
                temp.id = cache.conditiondb[condition].length === 0 ?
                    generateRowID() : cache.conditiondb[condition][0].id;
            break;
            case 'stackable':
                temp.id = generateRowID();
            break;
            default:
                temp.id = cache.conditiondb[condition][0] === undefined ?
                generateRowID() : false;
        }
        return temp.id;
    }

    /* Attribute Functions */
    async function getAllAttributes(cache) {
        const temp = {};
        clog(cache, temp, 'getAllAttributes()');
        temp.rules = {
            rules_base: 'static_rules_base_default',
            rules_xdef: 'static_rules_extradefenses_status',
            rules_kb: 'static_rules_knockback_status',
            rules_sanity: 'static_rules_sanity_status',
            rules_society: 'static_rules_society_status',
        }
        await crpGet(cache, temp.rules);
        temp.attributes = [];
        temp.attributes = temp.attributes.concat(base_attributes);
        if (cache.rules_xdef) { temp.attributes = temp.attributes.concat(besmx_attributes); }
        if (cache.rules_kb) { temp.attributes = temp.attributes.concat(kb_attributes); }
        if (cache.rules_sanity) { temp.attributes = temp.attributes.concat(sanity_attributes); }
        if (cache.rules_society) { temp.attributes = temp.attributes.concat(society_attributes); }
        temp.attributes.sort();
        return temp.attributes;
    }

    /* Defect Functions */
    function applyShortcomingObstacle(cache, query) {
        let result = false;
        for (let i = 0; i < cache.defectdb.shortcoming.length; i++) {
            for (let j = 0; j < query.shortcoming.stats.length; j++) {
                if (
                    cache.defectdb.shortcoming[i].config[1].rank !== 'all' &&
                    query.shortcoming.stats[j] === cache.defectdb.shortcoming[i].config[0].rank
                ) {
                    result = true;
                    break;
                }
            }
            if (result) { break; }
        }
        return result;
    }

    /* Button Functions */
    function setAccordion(cache, set_values) {
        // Note: 0 == closed, 1 == opened
        const temp = {};
        clog(cache, temp, 'setAccordion()');
        temp[`${cache.source_path}_state`] = 
            int(cache[`${cache.source_path}_state`]) === 1 ? 0 : 1;
        Object.assign(set_values, temp);
    }

    function setAttributeAccordions(cache, set_values) {
        // Note: 0 == closed, 1 == opened
        const temp = {};
        clog(cache, temp, 'setAttributeAccordions()');
        const global_state = int(cache.static_attributes_accordions_state);
        temp.static_attributes_accordions_state = global_state === 0 ? 1 : 0;
        for (let i = 0; i < cache.attribute_ids.length; i++) {
            temp[`repeating_attribute_${cache.attribute_ids[i]}_state`] = temp.static_attributes_accordions_state;
        }
        for (let i = 0; i < cache.defect_ids.length; i++) {
            temp[`repeating_defect_${cache.defect_ids[i]}_state`] = temp.static_attributes_accordions_state;
        }
        Object.assign(set_values, temp);
    }

    function setSkillAccordions(cache, set_values) {
        // Note: 0 == closed, 1 == opened
        const temp = {};
        clog(cache, temp, 'setSkillAccordions()');
        const global_state = int(cache.static_skills_accordions_state);
        temp.static_skills_accordions_state = global_state === 0 ? 1 : 0;
        for (let i = 0; i < cache.skill_ids.length; i++) {
            temp[`repeating_skill_${cache.skill_ids[i]}_state`] = temp.static_skills_accordions_state;
        }
        Object.assign(set_values, temp);
    }

    async function getDice(cache, query, roll) {
        const temp = {};
        clog(cache, temp, 'getDice()');
        query.title = 'Roll is';
        query.options = 
            `|Normal,0` +
            `|Minor Edge,1` +
            `|Minor Obstacle,-1` +
            `|Major Edge,2` +
            `|Major Obstacle,-2`;
        await crpQuery(cache, query);
        const exceed2dice =
            cache.rulesdb.rules_optional_dice_status === 'exceed' ? true : false;
        temp.string = '{{total=[[';
        temp.d6 = ' [[1d6]]+[[1d6]]';
        temp.d6_value = ' {{dice0=$[[0]]}} {{dice1=$[[1]]}}';
        temp.extra_dice = int((roll.mod.edge || 0) + (roll.mod.obstacle || 0 * -1) + int(query.selection));
        temp.dice_type = temp.extra_dice === 0 ? 'normal' : 
            temp.extra_dice > 0 ? 'edge' : 'obstacle';
        temp.extra_dice = temp.extra_dice < 0 ? temp.extra_dice * -1 : temp.extra_dice;
        temp.ndice = temp.extra_dice > 1 ?
                exceed2dice ? temp.extra_dice + 2 : 4 : 
            temp.extra_dice === 1 ? 3 : 2;
        for (let i = 2; i < temp.ndice; i++) {
            temp.d6 += '+[[1d6]]';
            temp.d6_value += ` {{dice${i}=$[[${i}]]}}`;
        }
        temp.string += `${temp.d6} ]]}} ${temp.d6_value}`;
        roll.dice = {
            number: temp.ndice,
            type: temp.dice_type,
        }
        return temp.string;
    }

    async function toggleRuleSetting(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'toggleRuleSetting()');
        //temp.get_attrs = await getAttrsAsync(['rulesdb']);
        //cache.rulesdb = JSON.parse(temp.get_attrs.rulesdb);
        temp.setting = cache.newValue !== undefined ?
            cache.newValue :
            int(cache.rulesdb[`${cache.source_path}_status`]) === 1 ? 0 : 1;
        if (cache.source_id === 'shockvalue') {
            if (!temp.setting) {
                set_values.rules_optional_knockout_status = temp.setting;
                set_values.rules_optional_seriousinjury_status = temp.setting;
                set_values.rules_attribute_hardboiled_status = temp.setting;
                set_values.rules_optional_knockout_icon = '_';
                set_values.rules_optional_seriousinjury_icon = '_';
                set_values.rules_attribute_hardboiled_icon = '_';
                cache.rulesdb.rules_optional_knockout_status = temp.setting;
                cache.rulesdb.rules_optional_seriousinjury_status = temp.setting;
                cache.rulesdb.rules_attribute_hardboiled_status = temp.setting;
            } else if (temp.setting && 
                    (
                        cache.static_rules_base_default === 'besmx' ||
                        cache.static_rules_base_default === 'absolutepower'
                    )
                ) {
                    set_values.rules_attribute_hardboiled_status = temp.setting;
                    set_values.rules_attribute_hardboiled_icon = '3';
                    cache.rulesdb.rules_attribute_hardboiled_status = temp.setting;
                }
        }
        if (
            cache.source_id === 'knockout' ||
            cache.source_id === 'seriousinjury' ||
            cache.source_id === 'hardboiled'
        ) {
            if (temp.setting) {
                set_values.rules_optional_shockvalue_status = temp.setting;
                set_values.rules_optional_shockvalue_icon = '3';
                cache.rulesdb.rules_optional_shockvalue_status = temp.setting;
            }
        }
        cache.rulesdb[`${cache.source_path}_status`] = temp.setting;
        if (cache.newValue === undefined) {
            set_values[`${cache.source_path}_status`] = temp.setting;
            set_values[`${cache.source_path}_icon`] = temp.setting === 1 ?
                '3' : '_';
        }
        set_values.rulesdb = JSON.stringify(cache.rulesdb);
    }

    async function selectTarget(cache, roll) {
        const rxGrab = /^0\[(.*)\]\s*$/;
        const temp = {};
        clog(cache, temp, 'selectTarget()');
        temp.template = `! ` +
            `{{charname=[[0[@{target|character_name}] ]]}} ` +
            `{{charid=[[0[@{target|character_id}] ]]}}`;
        temp.roll = await startRoll(temp.template);
        roll.target.name = 
            temp.roll.results.charname.expression.match(rxGrab)[1];
        roll.target.id = 
            temp.roll.results.charid.expression.match(rxGrab)[1];
        finishRoll(temp.roll.rollId);
    }

    function getStatsRemaining(cache, stats) {
        const temp = [];
        clog(cache, temp, `getStatsRemaining(${stats})`);
        for (let i = 0, n = stats.length; i < n; i++) {
            temp[i] = 
                cache.statsdb[stats[i]].base +
                cache.statsdb[stats[i]].temp -
                cache.statsdb[stats[i]].damage - (
                    stats[i] === 'health' ? 
                    cache.statsdb.health.stun : 0
                ) -
                (cache.statsdb[stats[i]].shortcoming || 0);
        }
        return temp;
    }

    function getCV(cache, cv) {
        const temp = {};
        clog(cache, temp, `getCV(${cv})`);
        temp.mastery = cache.attrdb[`${cv} mastery`].length !== 0 ?
            cache.attrdb[`${cv} mastery`].map(m => {
                return m.active ? m.elevel : 0;
            }).reduce((m, n) => { return m + n; }, 0) : 0;
        temp.cv = 0;
        for (let i = 0; i < 3; i++) {
            temp.cv += 
                cache.statsdb[all_stats[i]].base +
                cache.statsdb[all_stats[i]].temp -
                cache.statsdb[all_stats[i]].damage -
                (cache.statsdb[all_stats[i]].shortcoming || 0);
        }
        temp.cv += cache.attrdb.augmented.length !== 0 ?
            cache.attrdb.augmented.map(m => {
                return m.active ? m.elevel : 0;
            }).reduce((m, n) => { return m + n; }, 0) : 0;
        temp.cv = Math.round(temp.cv/3);
        return temp.cv + temp.mastery;
    }

    async function actionRoll(cache, set_values) {
        const roll = { // contains all data relevant to the roll
            base: 0,
            mod: {
                edge: 0,
                obstacle: 0
            },
            stat: 0,
            template: '&{template:rolls}' +
                ' {{pronoun=@{static_character_details_pronoun}}}' +
                ' {{character_name=@{static_character_details_name}}}',
        };
        const query = { // contains data for the roll itself
            answer: false,
            do_roll: false,
            get: {},
            get_attrs: [],
            values: []
        };
        clog(cache, roll, 'actionRoll(roll)');
        clog(cache, query, 'actionRoll(query)');
        if (cache.source_type === 'react') {
            roll.attacker = rollEscape.unescape(cache.originalRollId);
        }
        const rulebook = await crpGet(cache, 'static_rules_base_default') || 'besm';
        const color = rulebook === 'besmx' ? 'besm' : rulebook;
        query.attributes = [];
        const filtered_attributes = all_attributes.map(a => {
            return (a === 'skills' || a === 'skill group' || a === 'weapon') ? '' : a;
        }).filter(n => n);
        for (let i = 0; i < filtered_attributes.length; i++) {
            for (let j = 0; j < cache.attrdb[filtered_attributes[i]].length; j++) {
                const attribute = cache.attrdb[filtered_attributes[i]][j];
                if (attribute.active && attribute.stat !== 'none') {
                    query.attributes.length = query.attributes.push(
                        `|${attribute.name.capitalize()},` +
                        `${filtered_attributes[i]}~${j}`
                    );
                }
            }
        }
        roll.template += cache.source_type === 'react' ?
            ` {{color=color-react-${color}}} {{color-react=color-${color}}}` :
            ` {{color=color-${color}}} {{color-react=color-react-${color}}}`;
        query.next = cache.source_type === 'react' ? 
            cache.source_attribute === 'skill' ?
                cache.rulesdb.rules_optional_individual_status !== 0 ? 'skill' : 'skill_group' :
            cache.source_attribute : 'rollsroot';
        roll.type = cache.source_type === 'react' ? 
            cache.source_attribute === 'skill' ?
                cache.rulesdb.rules_optional_individual_status !== 0 ? 'skill' : 'skill_group' :
        cache.source_attribute : '';
        while (!query.do_roll) {
            switch(query.next) {
                // Roll Menu Options Root
                case 'rollsroot':
                    query.title = 'Choose a roll';
                    query.options = 
                        '|2d6,2d6' +
                        `|${getTranslationByKey("attack")},attack`;
                    query.options += query.attributes.length !== 0 ?
                        `|${getTranslationByKey("attribute")},attribute` : '';
                    query.options +=
                        `|${getTranslationByKey("initiative")},initiative`;
                    query.options +=
                    cache.attrdb[`${cache.rulesdb.rules_optional_individual_status ? 'skills' : 'skill group'}`].length !== 0 ?
                        `|${getTranslationByKey("skill")},` +
                        `${cache.rulesdb.rules_optional_individual_status ? 'skill': 'skill_group'}` : '';
                    query.options +=
                        `|${getTranslationByKey("stat")},stat`;
                    query.last = query.next;
                break;
                // 1st tier roll options
                case '2d6':
                    query.title = '';
                    query.do_roll = true;
                    roll.template += ' {{twodsix=1}}' +
                        ` {{title=${getTranslationByKey("roll")} 2d6}}`;
                    roll.cv = 0;
                break;
                case 'attack':
                    query.title = '';
                    roll.template += ' {{attack=1}}' +
                        ` {{title=${getTranslationByKey("attack")}}}`;
                    query.last = query.next;
                break;
                case 'attribute':
                    query.title = `${getTranslationByKey("select-attribute")}`;
                    query.options = query.attributes.sort().join('');
                    query.options += `|${getTranslationByKey("go-back")},rollsroot`;
                    query.last = query.next;
                break;
                case 'defense':
                    query.title = '';
                    roll.template += ` {{attack=1}} ` +
                        `{{title=${getTranslationByKey("defense")}}}`;
                    query.last = query.next;
                break;
                case 'select_weapon':
                    query.has_weapons = cache.attrdb.weapon.length;
                    if (
                        roll.type === 'defense' &&
                        query.has_weapons === 0 &&
                        roll.attacker.weapon.range === 0
                    ) {
                        query.title = '';
                        query.selection = 'unarmed';
                        break;
                    }
                    query.has_deflection = false;
                    if (roll.type === 'defense') {
                        cache.attrdb['combat technique'].forEach(a => {
                            for (let i = 0, n = a.config.length; i < n; i++) {
                                if (
                                    a.config[i].name === 'deflection' &&
                                    a.active
                                ) {
                                    query.has_deflection = true;
                                }
                            }
                        });
                    }
                    query.title = roll.type === 'attack' ?
                        `${getTranslationByKey("choose-attack")}` :
                        `${getTranslationByKey("choose-defense")}`;
                    query.options = '';
                    if (query.has_weapons) {
                        if (
                            roll.type === 'attack' || (
                                roll.type === 'defense' &&
                                roll.attacker.weapon.range === 0
                            ) || (
                                roll.type === 'defense' &&
                                roll.attacker.weapon.range !== 0 &&
                                query.has_deflection
                            )
                        ) {
                            for (let i = 0, n = cache.attrdb.weapon.length; i < n; i++) {
                                const ranged_weapon = roll.type === 'defense' ?
                                    cache.attrdb.weapon[i].enhancements.findIndex(e => {
                                        return e.name === 'range';
                                    }) : -1;
                                if (cache.attrdb.weapon[i].active && roll.type === 'attack') {
                                    query.options += `|${cache.attrdb.weapon[i].name},${i}`;
                                } else if (
                                    cache.attrdb.weapon[i].active && 
                                    roll.type === 'defense' &&
                                    roll.attacker.weapon.range === 0 &&
                                    ranged_weapon === -1
                                ) {
                                    query.options += `|${cache.attrdb.weapon[i].name},${i}`;
                                } else if (
                                    cache.attrdb.weapon[i].active && 
                                    roll.type === 'defense' &&
                                    roll.attacker.weapon.range !== 0 &&
                                    query.has_deflection
                                ) {
                                    if (query.options === '') {
                                        query.options += `|${getTranslationByKey("deflection")},` +
                                        `?{${getTranslationByKey("choose-weapon")}`;
                                    }
                                    query.options += `&#124;${cache.attrdb.weapon[i].name}&#44;${i}`;
                                    if (i === n-1) {
                                        query.options += `&#124;${getTranslationByKey("go-back")}&#44;select_weapon&#125;`;
                                    }
                                }
                            }
                        }
                    }
                    if (
                        roll.type === 'defense' &&
                        roll.attacker.weapon.range !== 0
                    ) {
                        query.options += 
                            `|${getTranslationByKey("personal")},personal` +
                            `|${getTranslationByKey("movement")},movement`;
                    }
                    query.options += (
                        roll.type === 'attack' || (
                            roll.type === 'defense' &&
                            roll.attacker.weapon.range === 0
                        ) || (
                            roll.type === 'defense' &&
                            roll.attacker.weapon.range !== 0 &&
                            query.has_deflection
                        )
                    ) ? `|${getTranslationByKey("unarmed")},unarmed` : '';
                    const encode = {
                        '|':'&#124;',
                        ',':'&#44;'
                    };
                    query.options += query.attributes.length === 0 ? '' :
                        `|${getTranslationByKey("attribute")},?{${getTranslationByKey("select-attribute")}` +
                        `${query.attributes.join("").replace(/[|,]/g, m => encode[m])}&#125;`;
                    query.options += `|${getTranslationByKey("go-back")},rollsroot`;
                break;
                case 'is_enemy':
                    const enemy_indexies = [];
                    for (let i = 0; i < cache.defectdb['inept defense'].length; i++) {
                        if (cache.defectdb['inept defense'][i].active) {
                            for (let j = 0; j < cache.defectdb['inept defense'][i].config.length; j++) {
                                if (cache.defectdb['inept defense'][i].config.findIndex(d => d.rank === 'enemy') !== -1) {
                                    enemy_indexies.push([i,j]);
                                }
                            }
                        }
                    }
                    if (enemy_indexies.length !== 1) {
                        query.title = '';
                        query.options = '';
                        for (let i = 0; i < enemy_indexies.length; i++) {
                            query.options += `|${cache.defectdb['inept defense'][enemy_indexies[i][0]].config[enemy_indexies[i][1]].enemy},` +
                            `${cache.defectdb['inept defense'][enemy_indexies[i][0]].rank}`;
                        }
                    } else {
                        query.title = `Apply Inept Defense vs. ` +
                            `${cache.defectdb['inept defense'][enemy_indexies[0][0]].config[enemy_indexies[0][1]].enemy}`;
                        query.options = `|${getTranslationByKey("no")},no|${getTranslationByKey("yes")},` +
                            `${cache.defectdb['inept defense'][enemy_indexies[0][0]].rank}`;
                    }
                    query.last = query.next;
                break;
                case 'combat_maneuver':
                    query.title = `${getTranslationByKey("select-maneuver")}`;
                    query.options = roll.weapon.is_attribute && !roll.weapon.range ? 
                        `|${getTranslationByKey("touch")},touch` : `|${getTranslationByKey("attack")},attack`;
                    query.options += cache.rulesdb.rules_optional_maneuvers_status ?
                        `|${getTranslationByKey("called-shot")},?{${getTranslationByKey("select-called-shot")}` +
                            `&#124;${getTranslationByKey("bypass-armor")}&#44;bypass armor` +
                            `&#124;${getTranslationByKey("reduce-armor")}&#44;reduce armor` +
                            `&#124;${getTranslationByKey("vital-spot")}&#44;vital spot` +
                            `&#124;${getTranslationByKey("weak-point")}&#44;weak point&#125;` : '';
                    query.options += !roll.weapon.range && cache.rulesdb.rules_optional_maneuvers_status ?
                        `|${getTranslationByKey("grapple")},?{${getTranslationByKey("select-grapping-maneuver")}` +
                            `&#124;${getTranslationByKey("bite")}&#44;bite` +
                            `&#124;${getTranslationByKey("grab")}&#44;grab` +
                            `&#124;${getTranslationByKey("lock")}&#44;lock` +
                            `&#124;${getTranslationByKey("pin")}&#44;pin` +
                            `&#124;${getTranslationByKey("throw")}&#44;throw&#125;` : '';
                    query.options += `|${getTranslationByKey("go-back")},select_weapon`;
                    query.last = query.next;
                break;
                case 'target_type':
                    query.title = `${getTranslationByKey("select-target-type")}`;
                    query.options = 
                        `|${getTranslationByKey("opposed-roll")},target_select` +
                        `|${getTranslationByKey("target-number")},target_number` +
                        `|${getTranslationByKey("go-back")},${(
                            cache.rulesdb.rules_optional_maneuvers_status &&
                            roll.type === 'attack'
                        ) || (
                            query.selection === 'unarmed' &&
                            roll.type === 'attack'
                        ) ? 'combat_maneuver' : 'select_weapon'
                        }`;
                    query.last = query.next;
                break;
                case 'target_select':
                    query.title = '';
                    await selectTarget(cache, roll);
                    query.last = query.next;
                break;
                case 'target_number':
                    query.title = 'Enter Target Number';
                    query.options = '';
                    query.last = query.next;
                break;
                case 'initiative':
                    query.title = '';
                    query.do_roll = true;
                    roll.template += ' {{initiative=1}} {{title=Initiative}}';
                break;
                case 'skill_group':
                    query.title = `Select Skill Group`;
                    query.skill_groups = [];
                    for (let i = 0; i < all_skill_groups.length; i++) {
                        const skill_group = { name: '', elevel: 0 };
                        for (let j = 0; j < cache.attrdb['skill group'].length; j++) {
                            if (cache.attrdb['skill group'][j].name.toLowerCase() === all_skill_groups[i]) {
                                skill_group.name = all_skill_groups[i];
                                skill_group.elevel += cache.attrdb['skill group'][j].elevel;
                            }
                        }
                        if (skill_group.name !== '') { query.skill_groups.push(skill_group); }
                    }
                    query.options = query.skill_groups.map((s, i) => `|${
                        getTranslationByKey(s.name.toKebobCase())
                    },${i}`).join('');
                    query.options += `|${getTranslationByKey("go-back")},rollsroot`;
                    query.last = query.next;
                break;
                case 'skill':
                    query.title = `Select Skill`;
                    query.skills = [];
                    for (let i = 0; i < all_skills.length; i++) {
                        const skill = { name: '', rank: 0, spec: [], stat: [] };
                        for (let j = 0; j < cache.attrdb.skills.length; j++) {
                            const individual = cache.attrdb.skills[j].individual;
                            for (let k = 0; k < individual.length; k++) {
                                if (individual[k].skill === all_skills[i]) {
                                    skill.name = individual[k].skill;
                                    skill.rank += individual[k].rank;
                                    skill.spec = [...new Set([...skill.spec, ...individual[k].specializations])].sort();
                                    skill.stat = skill.stat.length === 0 ? individual[k].stat :
                                        arraysAreEqual(skill.stat, individual[k].stat) ? skill.stat : [];
                                }
                            }
                        }
                        if (skill.name !== '') { query.skills.push(skill); }
                    }
                    query.options = query.skills.map((s, i) => `|${
                        getTranslationByKey(s.name.toKebobCase())
                    },${i}`).join('');
                    query.options += `|${getTranslationByKey("go-back")},rollsroot`;
                    query.last = query.next;
                break;
                case 'specialization':
                    query.title = 'Select Specialization';
                    query.options = '|None,none';
                    for (let i = 0; i < query.skills[query.index].spec.length; i++) {
                        query.options += `|${getTranslationByKey(query.skills[query.index].spec[i].toKebobCase())},${i}`;
                    }
                    query.last = query.next;
                break;
                case 'stat':
                    query.title = '';
                    roll.stat = await getStats(cache, query);
                    roll.denominator = roll.stat.length;
                    roll.title_stats = roll.denominator !== 1 ? 
                        `${roll.stat.capitalize().join('+')} ` : 
                        `${roll.stat[0].capitalize()} `;
                    roll.template += roll.type === 'skill' || roll.type === 'skill_group' ?
                        ` {{stat=1}} {{title=${roll.type === 'skill_group' ? 'Skill Group' : query.name} Roll}}` :
                        ` {{stat=1}} {{title=${roll.title_stats}Stat Roll}}`;
                    query.get = getStatsRemaining(cache, roll.stat);
                    roll.cv = Math.round(query.get.reduce(
                        (m, n) => { return m + n; }, 0) / roll.denominator
                    );
                break;
                case 'shortcoming':
                    query.title = `${getTranslationByKey("apply-shortcoming")}${
                        cache.defectdb.shortcoming.length !== 1 ? '' : 
                        ": " + cache.defectdb.shortcoming[2].name
                    }?`;
                    query.options = '';
                    if (cache.defectdb.shortcoming.length !== 1) {
                        query.options += `|${getTranslationByKey("none")},no`;
                        for (let i = 0; i < cache.defectdb.shortcoming.length; i++) {
                            for (let j = 0; j < query.shortcoming.stats.length; j++) {
                                if (
                                    cache.defectdb.shortcoming[i].config[1].rank !== 'all' &&
                                    query.shortcoming.stats[j] === cache.defectdb.shortcoming[i].config[0].rank
                                ) {
                                    query.options += `|${cache.defectdb.shortcoming[i].name},${i}`;
                                }
                            }
                        }
                    } else {
                        query.options += `|${getTranslationByKey("no")},no|${getTranslationByKey("yes")},2`;
                    }
                    query.last = query.next;
                break;
                default:
                    query.title = '';
                    query.do_roll = true;
            }
            // Present player with a menu choice
            if (query.title) {
                await crpQuery(cache, query);
                query.title = '';
            }
            // Take action on the selected menu item
            switch (query.next) {
                case 'rollsroot':
                    roll.type = query.selection;
                    query.next = query.selection;
                break;
                case 'attribute':
                    if (query.selection !== 'rollsroot') {
                        const selected_attribute = query.selection.split('~');
                        query.attribute = cache.attrdb[selected_attribute[0]][selected_attribute[1]];
                        query.name = query.attribute.name;
                        query.result = query.attribute.stat === 'variable' ? [] : [query.attribute.stat];
                    }
                    query.next = query.selection === 'rollsroot' ? query.selection : 'stat';
                break;
                case 'skill_group':
                    if (query.skill_groups.length !== 0 && query.selection !== 'rollsroot') {
                        query.index = int(query.selection);
                        query.name = getTranslationByKey(`${query.skill_groups[query.index].name.toKebobCase()}`);
                        query.level = query.skill_groups[query.index].elevel;
                    } else {
                        roll.type = 'stat';
                    }
                    query.next = 
                        query.selection === 'rollsroot' ? query.selection : 'stat';
                break;
                case 'skill':
                    if (query.skills.length !== 0 && query.selection !== 'rollsroot') {
                        query.index = int(query.selection);
                        query.name = getTranslationByKey(`${query.skills[query.index].name.toKebobCase()}`);
                        query.level = query.skills[query.index].rank;
                        query.stat = query.skills[query.index].stat;
                        query.specializations = '';
                    } else {
                        roll.type = 'stat';
                    }
                    query.next = 
                        query.selection === 'rollsroot' ? query.selection : 
                        query.skills[query.selection].spec.length !== 0 ? 'specialization' :
                        'stat';
                break;
                case 'specialization':
                    if (query.selection !== 'none') {
                        query.specialization = query.skills[query.index].spec[query.selection];
                        roll.mod.edge += 1;
                    }
                    query.result = query.stat;
                    query.next = 'stat';
                break;
                case 'attack':
                case 'defense':
                case 'stat':
                    roll.target = {
                        id: '',
                        name: '',
                        target: 0
                    };
                    query.shortcoming = {};
                    query.shortcoming.exists = cache.defectdb.shortcoming.length !== 0;
                    if (query.shortcoming.exists) {
                        query.shortcoming.temp = cache.defectdb.shortcoming.map(s => {
                            if (
                                roll.denominator === 1 &&
                                s.config[0].rank === roll.stat[0]
                            ) {
                                return s.config[0].rank;
                            } else {
                                for (let i = 0; i < roll.stat.length; i++) {
                                    if (
                                        s.config[0].rank === roll.stat[i]
                                    ) {
                                        return s.config[0].rank;
                                    }
                                }
                            }
                        }).filter(n => n);
                        query.shortcoming.stats = [...new Set(query.shortcoming.temp)];
                    }
                    query.next = query.next === 'stat' ? 
                        query.shortcoming.stats.length !== 0 && applyShortcomingObstacle(cache, query) ? 'shortcoming' :
                        'target_type' : 'select_weapon';
                    query.do_roll = cache.source_type === 'react' && (
                        cache.source_attribute === 'skill' ||
                        cache.source_attribute === 'stat'
                    ) ? true : false;
                break;
                case 'shortcoming':
                    if (query.selection !== 'no') {
                        roll.s_index = int(query.selection);
                        roll.mod.obstacle -= 
                            cache.defectdb.shortcoming[roll.s_index].config[1].rank === 'minor' ? 2 :
                            cache.defectdb.shortcoming[roll.s_index].config[1].rank === 'major' ? 1 : 0;
                    }
                    query.next = 'target_type';
                break;
                case 'select_weapon':
                    roll.weapon = {
                        elevel: 0,
                        index: -1,
                        is_attribute: false,
                        maneuver: roll.type,
                        name: '',
                        range: 0
                    };
                    // Get weapon range and name
                    if (
                        query.selection === 'personal' ||
                        query.selection === 'movement' ||
                        query.selection === 'unarmed'
                    ) {
                        roll.weapon.name = query.selection;
                    } else if (isNaN(query.selection)) {
                        query.load = query.selection.split("~");
                        roll.weapon.index = int(query.load[1]);
                        roll.weapon.name = 
                            cache.attrdb[query.load[0]][roll.weapon.index].name;
                        roll.weapon.is_attribute = true;
                    } else {
                        roll.weapon.index = int(query.selection);
                        roll.weapon.name = 
                            cache.attrdb.weapon[roll.weapon.index].name;
                        roll.weapon.elevel = 
                            cache.attrdb.weapon[roll.weapon.index].elevel;
                    }
                    roll.weapon.severity = 
                        roll.weapon.index === -1 || roll.weapon.is_attribute ? 'none' :
                        query.selection === 'unarmed' ? 'stun' :
                        cache.attrdb.weapon[roll.weapon.index].enhancements.findIndex(e => {
                            return e.name === 'stun';
                        }) !== -1 ? 'stun' : 'damage';
                    let enemy = false;
                    if (cache.defectdb['inept defense'].length !== 0) {
                        cache.inept_defense = [];
                        for (var i = 0; i < cache.defectdb['inept defense'].length; i++) {
                            if (cache.defectdb['inept defense'][i].active) {
                                const index = cache.defectdb['inept defense'][i].config.findIndex(d => d.name === 'attack_type');
                                cache.inept_defense.push(
                                    [`${cache.defectdb['inept defense'][i].config[index].rank}`,cache.defectdb['inept defense'][i].rank]
                                );
                            }
                        }
                        for (var i = 0; i < cache.inept_defense.length; i++) {
                            if (cache.inept_defense[i][0] === 'enemy') {
                                enemy = true;
                            }
                        }
                    }
                    query.next = (
                        query.selection === 'rollsroot' || 
                        query.selection === 'select_weapon'
                    ) ? query.selection : (
                            cache.rulesdb.rules_optional_maneuvers_status &&
                            roll.type === 'attack'
                        ) || (
                            query.selection === 'unarmed' &&
                            roll.type === 'attack'
                        ) ? 'combat_maneuver' : 
                        cache.source_type !== 'react' ?
                            'target_type' :
                        enemy ? 'is_enemy' : 'done';
                    query.do_roll = query.selection === 'select_weapon' ?
                        false : query.do_roll;
                break;
                case 'is_enemy':
                    if (roll.enemy === undefined) {
                        roll.enemy = query.selection * -2;
                    } else {
                        roll.enemy -= query.selection * 2;
                    }
                    query.next = 'done';
                break;
                case 'combat_maneuver':
                    roll.maneuver = query.selection;
                    query.next = query.selection === 'select_weapon' ?
                        query.selection : 'target_type';
                break;
                case 'target_type':
                    query.target = query.selection;
                    roll.target_type = query.selection;
                    query.next = query.selection;
                break;
                case 'target_number':
                    roll.target.number = int(query.selection);
                    // There is inentionally no 'break' statement here so code execution falls through to exit loop (i.e. query.do_roll = true).
                case 'target_select':
                    query.do_roll = true;
                break;
            }
        }
        switch(roll.type) {
            case 'attack': //=> build weapon metadata
            case 'defense':
                roll.name = cache.character_name;
                roll.pronoun = cache.static_character_details_pronoun;
                if (roll.weapon.index !== -1) {
                    const sections = ['config','enhancements','limiters'];
                    const indexes = {
                        config:['damage_type','weapon_class'],
                        enhancements:['accurate','flexible','homing','indirect','range'],
                        limiters:['inaccurate'],
                    };
                    for (let i = 0; i < sections.length; i++) {
                        for (let j = 0, m = indexes[sections[i]].length; j < m; j++) {
                            const index = 
                                cache.attrdb.weapon[roll.weapon.index][sections[i]].findIndex(c => {
                                    return c.name === indexes[sections[i]][j];
                                });
                            if (index !== -1) {
                                roll.weapon[indexes[sections[i]][j]] =
                                    cache.attrdb.weapon[roll.weapon.index][sections[i]][index].rank;
                            } else {
                                roll.weapon[sections[i]] = [];
                            }
                        }
                    }
                    // Weapon edges and obstacles
                    const mods = [...indexes.enhancements, ...indexes.limiters].sort();
                    for (let i = 0; i < mods.length; i++) {
                        switch(mods[i]) {
                            case 'accurate':
                                roll.mod.edge += roll.weapon.accurate || 0;
                            break;
                            case 'flexible':
                                roll.mod.obstacle -= 
                                    roll.weapon.flexible === 1 ? 2 :
                                    roll.weapon.flexible === 2 ? 1 : 0;
                            break;
                            case 'homing':
                                roll.mod.edge += 
                                    roll.weapon.homing === 2 ? 1 : 0;
                            break;
                            case 'inaccurate':
                                roll.mod.obstacle -= roll.weapon.inaccurate || 0;
                            break;
                            case 'indirect':
                                roll.mod.obstacle -= roll.weapon.indirect || 0;
                            break;
                        }
                    }
                } else {
                    roll.weapon.weapon_class = 'unarmed';
                    roll.weapon.damage_type = 'blunt';
                    roll.weapon.elevel = 0;
                    roll.weapon.severity = 'stun';
                }
                // Weapon ACV/DCV
                roll.cv = getCV(cache, roll.type);
                const weapon_type = roll.weapon.range !== 0 ? 'ranged attack' : 'melee attack';
                if (cache.attrdb[weapon_type].length !== 0) {
                    for (let i = 0; i < cache.attrdb[weapon_type].length; i++) {
                        const class_index = 
                            cache.attrdb[weapon_type][i].config.findIndex(c => c.name === 'weapon_class');
                        if (
                            cache.attrdb[weapon_type][i].active &&
                            cache.attrdb[weapon_type][i].config[class_index].rank === roll.weapon.weapon_class
                        ) {
                            roll.cv += cache.attrdb[weapon_type][i].elevel * 2;
                        }
                    }
                }
                if (roll.type === 'attack' && cache.defectdb['inept attack'].length !== 0) {
                    for (let i = 0; i < cache.defectdb['inept attack'].length; i++) {
                        const class_index = 
                            cache.defectdb['inept attack'][i].config.findIndex(c => c.name === 'weapon_class');
                        if (cache.defectdb['inept attack'][i].active) {
                            const conditional = cache.defectdb['inept attack'][i].config[class_index].rank !== 'any';
                            roll.cv -= conditional ?
                                cache.defectdb['inept attack'][i].config[class_index].rank === roll.weapon.weapon_class ?
                                    cache.defectdb['inept attack'][i].rank * 2 : 0 :
                                cache.defectdb['inept attack'][i].rank * 2;
                        }
                    }
                } else if (roll.type === 'defense' && cache.defectdb['inept defense'].length !== 0) {
                    for (let i = 0; i < cache.inept_defense.length; i++) {
                        const attack_type = roll.attacker.weapon.range !== 0 ? 'ranged attack' : 'melee attack';
                        roll.cv -=
                            cache.inept_defense[i][0] === attack_type ? cache.inept_defense[i][1] * 2 :
                            cache.inept_defense[i][0] === 'any' ? cache.inept_defense[i][1] :
                            0;
                    }
                }
                roll.cv += roll.enemy || 0;
                //=> compute targeted attack here
                // Weapon DM
                roll.dm = 5;//cache.static_character_dm_base;
                for (let i = 0, n = cache.attrdb['massive damage'].length; i < n; i++) {
                    if (
                        cache.attrdb['massive damage'][i].active && (
                            cache.attrdb['massive damage'][i].config.class === roll.weapon.class ||
                            cache.attrdb['massive damage'][i].config.class === undefined
                        )
                    ) {
                        roll.dm += cache.attrdb['massive damage'][i].elevel;
                    }
                }
                //=> compute targeted massive damage here
                if (
                    !roll.weapon.range ||
                    roll.weapon.enhancements.findIndex(e => {
                        return e.name === 'muscle';
                    }) !== -1
                ) {
                    for (let i = 0, n = cache.attrdb['superstrength'].length; i < n; i++) {
                        if (
                            cache.attrdb['superstrength'][i].active &&
                            cache.attrdb['superstrength'][i].config.class === roll.weapon.class
                        ) {
                            roll.dm += cache.attrdb['superstrength'][i].elevel * (
                                rulebook === 'absolutepower' ? 2 : 1
                            );
                        }
                    }
                }
                if (cache.defectdb['reduced damage'].length !== 0) {
                    roll.dm -= cache.defectdb['reduced damage'].map(r => r.rank).reduce((m, n) => m + n, 0);
                    if (roll.dm < 0) { roll.dm = 0; }
                }
            break;
            case 'initiative':
                cache.actions = cache.attrdb['extra actions'].length !== 0 ?
                    cache.attrdb['extra actions'].map(a => {
                        return a.active ? a.elevel : 0;
                    }).filter(n => n).reduce((m, n) => m + n, 0) + 1 : 1;
                cache.reflexes = 0;
                cache.attrdb['combat technique'].forEach(a => {
                    for (let i = 0, n = a.config.length; i < n; i++) {
                        if (
                            a.config[i].name === 'lightning reflexes' &&
                            a.active
                        ) {
                            cache.reflexes += (a.config[i].rank);
                        }
                    }
                });
                roll.mod.edge += cache.reflexes;
                roll.cv = getCV(cache, 'attack');
                roll.initiative_dice = await getDice(cache, query, roll);
                roll.initiative_roll = await startRoll(`! ${roll.initiative_dice}`);
                finishRoll(roll.initiative_roll.rollId);
                roll.dice_values = 
                    roll.initiative_roll.results.total.expression.split("+");
                roll.dice_total = 
                    `{{total=[[ [[1d0+${roll.dice_values[0]}]] + [[1d0+${roll.dice_values[1]}]] `;
                for (let i = 2, n = roll.dice_values.length; i < n; i++) {
                    roll.dice_total += `+ [[1d0+${roll.dice_values[i]}]] `
                }
                roll.dice_total += 
                    `+ [[${roll.cv}]] &{tracker} ]]}}`;
                roll.dice_total += ` {{dice0=$[[0]]}} {{dice1=$[[1]]}}`;
                for (let i = 2, n = roll.dice_values.length; i < n; i++) {
                    roll.dice_total += ` {{dice${i}=$[[${i}]]}}`;
                }
                roll.tracker = true;
            break;
            case 'attribute':
            case 'skill':
            case 'skill_group':
            case 'stat':
                for (let i = 0; i < roll.denominator; i++) {
                    query.get[i] = isNaN(query.get[i]) ?
                        query.get[i] : int(query.get[i]);
                }
                roll.cv = Math.round(query.get.reduce(
                    (m, n) => { return m + n; }, 0) / roll.denominator
                ) + int(`${roll.type === 'skill' || roll.type === 'skill_group' ? query.level : 0}`);
                roll.cv -= roll.s_index !== undefined ? 
                    cache.defectdb.shortcoming[roll.s_index].config[1].rank === 'minor' ? (2 * cache.defectdb.shortcoming[roll.s_index].rank) :
                    cache.defectdb.shortcoming[roll.s_index].config[1].rank === 'major' ? cache.defectdb.shortcoming[roll.s_index].rank :
                    0 : 0;
                if (query.shortcoming.stats !== undefined) {
                    for (let i = 0; i < cache.defectdb.shortcoming.length; i++) {
                        for (let j = 0; j < query.shortcoming.stats.length; j++) {
                            if (
                                cache.defectdb.shortcoming[i].config[1].rank === 'all' &&
                                query.shortcoming.stats[j] === cache.defectdb.shortcoming[i].config[0].rank
                            ) {
                                roll.cv -= Math.round(cache.defectdb.shortcoming[i].rank / 2);
                            }
                        }
                    }
                }
                roll.name = cache.character_name;
            break;
        }
        // Build initial roll template.
        roll.pronoun = cache.static_character_details_pronoun;
        roll.template += ` {{base=${roll.cv}}}`;
        roll.template += roll.tracker ? ` ${roll.dice_total}` : 
            await getDice(cache, query, roll);
        switch (roll.type) {
            case 'attack':
            case 'attribute':
                if (roll.target_type === "target_select") {
                    roll.template += roll.type === 'attack' ?
                        ` {{emote=${roll.name} attempts an attack on ${roll.target.name}}}` :
                        ` {{emote=${roll.name} attempts to use ${roll.pronoun} ${query.attribute.name} attribute against ${roll.target.name}}}`;
                } else {
                    roll.template += roll.type === 'attack' ?
                        ` {{emote=${roll.name} attempts` +
                        ` ${cache.rulesdb.rules_optional_maneuvers_status &&
                            roll.maneuver !== 'attack' ?
                            ' a ' + roll.maneuver : ' an'} attack}}` :
                        ` {{emote=${roll.name} uses ${roll.pronoun} ${query.attribute.name} attribute}}`;
                }
            break;
            case 'defense':
                roll.template += ` {{emote=${roll.name} respods to ${roll.attacker.name}'s ` +
                `${roll.attacker.maneuver || roll.attacker.type} ${roll.weapon.name === 'unarmed' ?
                    'unarmed' : 'with ' + roll.pronoun + ' ' + roll.weapon.name
                }}}`;
            break;
            case 'skill':
            case 'skill_group':
            case 'stat':
                if (roll.target_type === "target_select") {
                    roll.template += ` {{emote=${roll.name} challenges ${roll.target.name} ` +
                        `with ${roll.pronoun} ` +
                    `${roll.type === 'skill' && query.specialization !== undefined ?
                            query.specialization.capitalize() + ' ' : ''}` +
                    `${roll.type === 'skill' || roll.type === 'skill_group' ?
                            query.name.capitalize() + ' ' : ''}` +
                    `${roll.type === 'stat' ? roll.title_stats + ' ' : ''}` +
                    `${roll.type.capitalize()} roll!}}`;
                } else if (cache.source_type === 'react') {
                    roll.template += ` {{emote=${roll.name} responds to ${roll.attacker.name} ` +
                        `with ${roll.pronoun} ` +
                    `${roll.type === 'skill' && query.specialization !== undefined ?
                            query.specialization.capitalize() + ' ' : ''}` +
                    `${roll.type === 'skill' || roll.type === 'skill_group' ?
                            query.name.capitalize() + ' ' : ''}` +
                    `${roll.type === 'stat' ? roll.title_stats + ' ' : ''}` +
                    `${roll.type.capitalize()} roll!}}`;
                } else {
                    roll.template += ` {{emote=${roll.name} attempts a ` +
                    `${roll.type === 'skill' && query.specialization !== undefined ?
                            query.specialization.capitalize() + ' ' : ''}` +
                    `${roll.type === 'skill' || roll.type === 'skill_group' ?
                            query.name.capitalize() + ' ' : ''}` +
                    `${roll.type === 'stat' ? roll.title_stats + ' ' : ''}` +
                    `${roll.type.capitalize()} roll!}}`;
                }
            break;
        }
        // Build react template.
        roll.template += query.target === 'target_select' ?
            ` {{react=1}} {{reactheader=${getTranslationByKey("opposed-rolls")}}}` +
            ` {{react-button=1}} {{reacttitle=${
                roll.type === 'attack' ? 
                getTranslationByKey("defense") : roll.type.capitalize()
            } Roll (${roll.target.name})}}` +
            ' {{reactlabel=IJ}} {{reactdata=[[0]]}}' +
            ` {{reactlink=${
                (
                    roll.type === 'stat' ||
                    roll.type === 'attribute'
                ) ? 'react_button_roll_stat' :
                roll.type === 'skill' || roll.type === 'skill_group' ? 'react_button_roll_skill' :
                'react_button_roll_defense'}}}` :
            query.target === 'target_number' ? 
            ` {{react=1}} {{reactheader=${getTranslationByKey("target-number")}}}` +
            ` {{reacttitle=${roll.type === 'skill_group' ? getTranslationByKey("skill-group") : getTranslationByKey(roll.type)}` +
            ` ${getTranslationByKey("roll-vs")}}}` +
            ` {{react-tn=${roll.target.number}}}` : '';
        // Roll against initial roll template and determine dice.
        query.crp = await startRoll(roll.template);
        roll.results = [];
        for (let i = 0, n = roll.dice.number; i < n; i++) {
            roll.results.push(query.crp.results[`dice${i}`].result);
        }
        roll.computed = {
            total: 0,
        };
        for (let i = 0, n = roll.dice.number; i < n; i++) {
            if (i === 0 || i === 1) {
                roll.computed[`dice_value${i}`] = 
                    roll.dice.type === 'obstacle' ? _.min(roll.results) :
                    roll.dice.type === 'edge' ? _.max(roll.results) :
                    roll.results[i];
                roll.computed[`dice${i}`] = 
                    getDiceIcon(roll.computed[`dice_value${i}`]);
                roll.computed.total += roll.computed[`dice_value${i}`];
                if (roll.dice.type !== 'normal') {
                    const results_length = 
                        roll.results.indexOf(roll.computed[`dice_value${i}`]);
                    roll.results.splice(results_length, 1);
                }
            } else {
                roll.computed[`dice_value${i}`] = roll.results[i-2];
                roll.computed[`dice${i}`] = 
                    getDiceIcon(roll.computed[`dice_value${i}`], true);
            }
        }
        roll.computed.total += roll.cv;
        if (roll.target_type === 'target_select') {
            roll.computed.reactdata = rollEscape.escape(roll);
        }
        finishRoll(query.crp.rollId,roll.computed);
        // Determine post-roll event(s).
        switch (roll.type) {
            case 'initiative':
                if (
                    cache.rulesdb.rules_optional_spreadinitiative_status &&
                    cache.actions !== 1
                ) {
                    const actions_by_initiative = [];
                    for (let i = 0; i < cache.actions; i++) {
                        actions_by_initiative.push(
                            Math.round(roll.computed.total / (i + 1))
                        );
                    }
                    set_values.static_character_initiative_base =
                        actions_by_initiative.join(", ");
                } else {
                    set_values.static_character_initiative_base = 
                        roll.computed.total;
                }
            break;
            case 'attack':
            case 'attribute':
            case 'defense':
            case 'skill':
            case 'skill_group':
            case 'stat':
                if (
                    (roll.type === 'attack' && roll.target_type !== 'target_number') ||
                    (
                        (
                            roll.type === 'attribute' ||
                            roll.type === 'skill' ||
                            roll.type === 'skill_group' ||
                            roll.type === 'stat'
                        ) && (
                            cache.source_type !== 'react' &&
                            roll.target_type !== 'target_number'
                        )
                    )
                ) { break; }
                roll.result = 
                    roll.target_type === 'target_number' ?
                        roll.computed.total - roll.target.number :
                    (
                        roll.type === 'attribute' ||
                        roll.type === 'skill' ||
                        roll.type === 'skill_group' ||
                        roll.type === 'stat'
                    ) && cache.source_type !== 'react' ?
                        roll.computed.total :
                        roll.attacker.computed.total - roll.computed.total;
                roll.mos = getMarginOfSuccess(cache, roll.result);
                roll.template = `&{template:rolls-result}`;
                roll.template += roll.target_type === 'target_number' ?
                    ' {{result-spacer=result-nospacer}}' : 
                    ' {{result-spacer=result-spacer}}';
                roll.template +=
                    ` {{color=color-${color}}} {{result-header=${roll.mos}}}`;
                if (roll.result >= 0) {
                    roll.template += ` {{result=[[1d1]]}}`;
                    if (
                        (
                            (
                                roll.type === 'attack' ||
                                roll.type === 'attribute' ||
                                roll.type === 'skill' ||
                                roll.type === 'skill_group' ||
                                roll.type === 'stat'
                            ) && (
                                roll.target_type === 'target_number' &&
                                cache.source_type !== 'react'
                            )
                        )
                    ) {
                        roll.template += ` {{emote=${
                            roll.target_type === 'target_number' ?
                            roll.name : roll.attacker.name
                        }'s` +
                        `${
                            roll.type === 'skill' && query.specialization !== undefined ?
                                ' ' + query.specialization.capitalize() : ''
                        }` +
                        `${
                            roll.type === 'skill' || roll.type === 'skill_group' ?
                                ' ' + query.name.capitalize() : ''
                        }` +
                        ` ${
                            cache.source_type === 'react' ?
                            roll.attacker.type.capitalize() :
                            roll.type.capitalize()
                        } roll vs. ${
                            roll.target_type === 'target_number' ?
                            'TN ' + roll.target.number : roll.name
                        } succeeded.}}`;
                    } else if (roll.type === 'defense') {
                        roll.template += ` {{emote=${roll.attacker.name}` +
                        `${
                            roll.attacker.weapon.maneuver === 'attack' ?
                            ' attacks' : ' executes a ' + roll.attacker.maneuver + ' on'
                        }` +
                        ` ${roll.name} with ` +
                            `${roll.attacker.weapon.name === 'unarmed' ? 'an unarmed attack' :
                            roll.attacker.pronoun + ' ' + roll.attacker.weapon.name}}}`;
                    } else if (
                        (
                            roll.type === 'attribute' ||
                            roll.type === 'skill' ||
                            roll.type === 'skill_group' ||
                            roll.type === 'stat'
                        ) && roll.attacker !== undefined
                    ) {
                        roll.template += ` {{emote=${roll.attacker.name}'s ${roll.attacker.type.fromSnakeCase()} ` +
                        `roll vs. ${roll.name} was a ${roll.mos.toLowerCase()}}}`;
                    }

                    if (roll.type === 'defense') {
                        const damage = {};
                        clog(cache, damage, 'actionRoll(damage)');
                        damage.percentage = 1;
                        if (roll.attacker.weapon.elevel !== -1) {
                            if (cache.rulesdb.rules_optional_variable_status !== 'fixed') {
                                damage.attack_roll = 
                                    roll.attacker.computed.dice_value0 + 
                                    roll.attacker.computed.dice_value1;
                                if (cache.rulesdb.rules_optional_variable_status.indexOf('damageroll') !== -1) {
                                    damage.template = 
                                        '! {{total=[[ [[1d6]]+[[1d6]] ]]}}' +
                                        ' {{dice0=$[[0]]}} {{dice1=$[[1]]}}';
                                    damage.crp = await startRoll(damage.template);
                                        damage.dice =
                                            `${getDiceIcon(damage.crp.results.dice0.result)} ` +
                                            `${getDiceIcon(damage.crp.results.dice1.result)}`;
                                        damage.roll = damage.crp.results.total.result;
                                    finishRoll(damage.crp.rollId);
                                    roll.template += ` {{damage-dice=${damage.dice}}}`;
                                }
                                switch (cache.rulesdb.rules_optional_variable_status) {
                                    case 'mos-dm':
                                        switch (roll.result) {
                                            case 0:
                                                roll.attacker.dm += -2;
                                            break;
                                            case 1:
                                            case 2:
                                                roll.attacker.dm += -1;
                                            break;
                                            case 3:
                                            case 4:
                                            case 5:
                                                roll.attacker.dm += 0;
                                            break;
                                            case 6:
                                            case 7:
                                            case 8:
                                            case 9:
                                            case 10:
                                            case 11:
                                                roll.attacker.dm += 1;
                                            break;
                                            default:
                                                roll.attacker.dm += 2;
                                        }
                                    break;
                                    case 'attackroll-dm':
                                        switch (damage.attack_roll) {
                                            case 2:
                                            case 3:
                                                roll.attacker.dm += -2;
                                            break;
                                            case 4:
                                            case 5:
                                                roll.attacker.dm += -1;
                                            break;
                                            case 9:
                                            case 10:
                                                roll.attacker.dm += 1;
                                            break;
                                            case 11:
                                            case 12:
                                                roll.attacker.dm += 2;
                                            break;
                                            default:
                                                roll.attacker.dm += 0;
                                        }
                                    break;
                                    case 'damageroll-dm':
                                        switch (damage.roll) {
                                            case 2:
                                            case 3:
                                                roll.attacker.dm += -2;
                                            break;
                                            case 4:
                                            case 5:
                                                roll.attacker.dm += -1;
                                            break;
                                            case 9:
                                            case 10:
                                                roll.attacker.dm += 1;
                                            break;
                                            case 11:
                                            case 12:
                                                roll.attacker.dm += 2;
                                            break;
                                            default:
                                                roll.attacker.dm += 0;
                                        }
                                    break;
                                    case 'mos-td':
                                        switch (roll.result) {
                                            case 0:
                                                damage.percentage = 0.25;
                                            break;
                                            case 1:
                                            case 2:
                                                damage.percentage = 0.5;
                                            break;
                                            case 3:
                                            case 4:
                                            case 5:
                                                damage.percentage = 1;
                                            break;
                                            case 6:
                                            case 7:
                                            case 8:
                                            case 9:
                                            case 10:
                                            case 11:
                                                damage.percentage = 1.25;
                                            break;
                                            default:
                                                damage.percentage = 1.5;
                                        }
                                    break;
                                    case 'attackroll-td':
                                        switch (damage.attack_roll) {
                                            case 2:
                                            case 3:
                                                damage.percentage = 0.25;
                                            break;
                                            case 4:
                                            case 5:
                                                damage.percentage = 0.5;
                                            break;
                                            case 9:
                                            case 10:
                                                damage.percentage = 1.25;
                                            break;
                                            case 11:
                                            case 12:
                                                damage.percentage = 1.5;
                                            break;
                                            default:
                                                damage.percentage = 1;
                                        }
                                    break;
                                    case 'damageroll-td':
                                        switch (damage.roll) {
                                            case 2:
                                            case 3:
                                                damage.percentage = 0.25;
                                            break;
                                            case 4:
                                            case 5:
                                                damage.percentage = 0.5;
                                            break;
                                            case 9:
                                            case 10:
                                                damage.percentage = 1.25;
                                            break;
                                            case 11:
                                            case 12:
                                                damage.percentage = 1.5;
                                            break;
                                            default:
                                                damage.percentage = 1;
                                        }
                                    break;
                                    default:
                                }
                                damage.multiplier = Math.max(roll.attacker.dm, 0);
                            } else {
                                damage.multiplier = roll.attacker.dm;
                            }
                        }
                        damage.percentage = roll.attacker.weapon.is_attribute ? 0 : damage.percentage;
                        damage.received = roll.attacker.weapon.elevel !== -1 ? Math.round(
                            (
                                (
                                    damage.multiplier * roll.attacker.weapon.elevel
                                ) + roll.attacker.cv
                            ) * damage.percentage
                        ) : 0;
                        roll.template += ` {{damage=${damage.received}}}`;
                        roll.template += roll.attacker.weapon.severity === 'stun' ?
                            ` {{stun=Stun }}` : '';
                        damage.taken = damage.received;
                        if (damage.taken !== 0) {
                            damage.absorbed = [];
                            damage.converted = [];
                            damage.stopped = [];
    
                            const protections = ['force field','armor','absorption'];
                            const defenses = {
                                armor_rating:0,
                                'force field':[],
                                'armor':[],
                                'absorption':[]
                            };
                            clog(cache, defenses, 'actionRoll(defenses)');
                            for (let p = 0; p < protections.length; p++) {
                                for (let i = 0; i < cache.attrdb[protections[p]].length; i++) {
                                    if (
                                        damage.taken !== 0 && // consider moving this out of the for statements to only read once, if damage calculation to protections will be calculated later...
                                        cache.attrdb[protections[p]][i].active
                                    ) {
                                        const protection = cache.attrdb[protections[p]][i];
                                        clog(cache, protection, `>>>>protection(${protection.name})`);
                                        const ar_index = 
                                            protection.config.findIndex(c => {
                                                return c.name === 'armor rating';
                                            });
                                        defenses.armor_rating = ar_index !== -1 ? 
                                            protection.config[ar_index].rank : 0;
                                        // Determine armor_rating if Emphasized or Optimized.
                                        const eo_index = protection.limiters.findIndex(l => {
                                            return l.name === 'emphasized' || l.name === 'optimized';
                                        });
                                        if (eo_index !== -1) {
                                            const dt_index = protection.config.findIndex(c => {
                                                return c.name === 'damage_type';
                                            })
                                            defenses.armor_rating = 
                                                roll.attacker.weapon.damage_type === protection.config[dt_index].rank ? //=> specialized
                                                defenses.armor_rating * 2 : //=> not specialized
                                                protection.limiters[eo_index].rank === 1 ? //=> emphasized
                                                Math.round(defenses.armor_rating / 2) : 0; //=> optimized
                                        }
                                        if (
                                            defenses.armor_rating !== 0 &&
                                            cache.groupdb[protection.group_id].group_type !== 'shield'
                                        ) {
                                            if (
                                                protections[p] === 'absorption' && (
                                                    roll.attacker.weapon.severity !== 'stun'
                                                    // add psychic
                                                    // add continuing
                                                    // add tangle
                                                    // add drain
                                                    // add flare
                                                    // add incapacitating
                                                    // add irritant
                                                )
                                            ) {
                                                const transform_index = protection.config.findIndex(c => {
                                                    return c.name === 'transform';
                                                });
                                                damage.absorbed.push({
                                                    name: protection.name,
                                                    total: damage.taken > defenses.armor_rating ? defenses.armor_rating : damage.taken,
                                                    transform: protection.config[transform_index].rank.substring(
                                                        0, protection.config[transform_index].rank.length - 7
                                                    ),
                                                    synergistic: protection.enhancements.findIndex(c => {
                                                        return c.name === 'synergistic'
                                                    }) !== -1 ? true : false,
                                                    capped: protection.limiters.findIndex(c => {
                                                        return c.name === 'capped'
                                                    }) !== -1 ? true : false,
                                                });
                                            }
                                            // Calculate damage against armor_rating.
                                            damage.taken = Math.max(damage.taken - defenses.armor_rating, 0);
                                            // Record damage stopped for Conversion with Escalate.
                                            if (protections[p] === 'force field' || protections[p] === 'armor') {
                                                damage.stopped.push(Math.min(damage.taken, defenses.armor_rating));
                                            }
                                            // Add active protection to the roll template.
                                            const label = protections[p] === 'force field' ?
                                                protections[p].removeWhiteSpace() : protections[p];
                                            roll.template += protections[p] !== 'absorption' ?
                                                ` {{${label}${i}key=${protection.name}}}` +
                                                ` {{${label}${i}value=${defenses.armor_rating}}}` : '';
                                            if (
                                                damage.taken !== 0 &&
                                                protections[p] === 'force field'
                                            ) {
                                                defenses.armor_rating = Math.max(defenses.armor_rating - 10, 0);
                                                protection.config[ar_index].rank = defenses.armor_rating;
                                                let value = '';
                                                for (let j = 0, m = protection.config.length; j < m; j++) {
                                                    value += `${protection.config[j].name.capitalize()}` +
                                                    ` (${protection.config[j].rank})\n`;
                                                }
                                                set_values[`repeating_attribute_${protection.row_id.toLowerCase()}_configuration`] = value;
                                                if (defenses.armor_rating === 0) {
                                                    set_values[`repeating_attribute_${protection.row_id.toLowerCase()}_active`] = false;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
    
                            // Apply Damage, Absorption, and Conversion
                            // Apply Absorption
                            for (let i = 0; i < damage.absorbed.length; i++) {
                                damage.absorbed_remainder = 0;
                                if (damage.absorbed[i].total !== 0) {
                                    const absortion_type = damage.absorbed[i].transform;
                                    const max_points = Math.round(cache.statsdb[absortion_type].base / 2);
                                    const current_damage = cache.statsdb[absortion_type].damage + (
                                        absortion_type === 'health' ? cache.statsdb.health.stun : 0
                                    );
                                    damage.absorbed[i].temp = 0;
                                    //=> Note: has to be damage and temp...remaining calculated later.
                                    //=> also, should heal stun since it is loss of health.
                                    if (
                                        damage.absorbed[i].total > current_damage
                                    ) {
                                        damage.absorbed[i].over = damage.absorbed[i].total - current_damage;
                                        cache.statsdb[absortion_type].damage = 0;
                                        if (absortion_type === 'health') { cache.statsdb.health.stun = 0; }

                                        damage.absorbed[i].temp += damage.absorbed[i].capped ? 
                                            0 : damage.absorbed[i].over;
                                        damage.absorbed[i].temp = damage.absorbed[i].capped ?
                                            damage.absorbed[i].temp : damage.absorbed[i].temp > max_points ? 
                                                max_points : damage.absorbed[i].temp;
                                                
                                        roll.template += 
                                            ` {{absorption${i}key=${damage.absorbed[i].name}}}` +
                                            ` {{absorption${i}value=${damage.absorbed[i].total}}}`;
                                    } else {
                                        cache.statsdb[absortion_type].damage -= damage.absorbed[i].total;
                                        if (cache.statsdb[absortion_type].damage < 0) {
                                            damage.absorbed[i].temp = damage.absorbed[i].capped ? 0 :
                                                cache.statsdb[absortion_type].damage * -1;
                                            cache.statsdb[absortion_type].damage = 0;
                                        }
                                        if (
                                            absortion_type === 'health' &&
                                            cache.statsdb[absortion_type].damage === 0 &&
                                            damage.absorbed[i].temp !== 0
                                        ) {
                                            cache.statsdb.health.stun -= damage.absorbed[i].temp;
                                            if (cache.statsdb.health.stun < 0) {
                                                damage.absorbed[i].temp = damage.absorbed[i].capped ? 0 :
                                                    cache.statsdb.health.stun * -1;
                                                cache.statsdb.health.stun = 0;
                                            }
                                        }
                                        
                                        const healed_points = damage.absorbed[i].total > current_damage ?
                                            current_damage : damage.absorbed[i].total;
                                        roll.template += 
                                            ` {{absorption${i}key=${damage.absorbed[i].name}}}` +
                                            ` {{absorption${i}value=${healed_points}}}`;
                                    }
                                }
                            }
                            if (damage.absorbed.length !== 0) {
                                const absorption_types = ['health','energy'];
                                for (let i = 0; i < absorption_types.length; i++) {
                                    const temp_points = damage.absorbed.map(a => {
                                        return a.transform === absorption_types[i] ? a.temp : 0;
                                    }).reduce((a, b) => a + b, 0);
                                    const max_points = Math.round(cache.statsdb[absorption_types[i]].base / 2);
                                    cache.statsdb[absorption_types[i]].temp +=
                                        Math.min(temp_points, max_points);

                                    if (temp_points > max_points) {
                                        cache.statsdb[absorption_types[i]].damage += temp_points - max_points;
                                    }

                                    cache.statsdb[absorption_types[i]].remaining =
                                        cache.statsdb[absorption_types[i]].base
                                        + cache.statsdb[absorption_types[i]].temp
                                        - cache.statsdb[absorption_types[i]].damage
                                        - (absorption_types[i] === 'health' ? cache.statsdb.health.stun : 0);

                                    set_values[`static_character_${absorption_types[i]}_damage`] = cache.statsdb[absorption_types[i]].damage;
                                    set_values[`static_character_${absorption_types[i]}_remaining`] = cache.statsdb[absorption_types[i]].remaining;
                                    if (absorption_types[i] === 'health') { set_values.static_character_health_stun = cache.statsdb.health.stun; }
                                    set_values[`static_character_${absorption_types[i]}_temp`] = cache.statsdb[absorption_types[i]].temp;
                                }
                            }
                            // Apply Conversion
                            for (let i = 0; i < cache.attrdb.conversion.length; i++) {
                                const absorbed_convertable = damage.absorbed.length !== 0 ? 
                                    damage.absorbed.map(a => a.synergistic ? a.total : 0).reduce((m, n) => m + n, 0) : 0;
                                const absorbed = damage.absorbed.length !== 0 ? 
                                    damage.absorbed.map(a => a.total).reduce((m, n) => m + n, 0) : 0;
                                if (
                                    damage.taken !== 0 || 
                                    absorbed_convertable !== 0
                                ) {
                                    if (roll.attacker.weapon.elevel !== -1) {
                                        for (let i = 0; i < cache.attrdb.conversion.length; i++) {
                                            const group_id = cache.attrdb.conversion[i].group_id;                           
                                            if (
                                                cache.attrdb.conversion[i].active &&
                                                cache.groupdb[group_id].group_type !== 'shield'
                                            ) {
                                                const has_escalate = 
                                                    cache.attrdb.conversion[i].enhancements.findIndex(c => c.name === 'escalate') !== -1;
                                                damage.convertable = Math.max(damage[`${has_escalate ? 'received' : 'taken'}`] - (absorbed - absorbed_convertable), 0);
                                                damage.converted[i] = Math.floor(damage.convertable / 10);
                                                roll.template += 
                                                    ` {{conversion${i}key=${cache.attrdb.conversion[i].name}}}` +
                                                    ` {{conversion${i}value=${damage.converted[i]}}}`;
                                                if (damage.taken === 0) {
                                                    break;
                                                }
                                            }
                                        }
                                        damage.temp_cp = Math.floor(
                                            damage.converted.filter(n => n).reduce((m, n) => m + n, 0)
                                        );
                                        if (damage.temp_cp !== 0) {
                                            const cp_temp = Math.min(
                                                damage.temp_cp + int(cache.statsdb.cp.temp),
                                                Math.round(int(cache.statsdb.cp.base) / 2)
                                            );
                                            set_values.static_character_points_temp = cp_temp;
                                            cache.statsdb.cp.temp = cp_temp;
                                            set_values.static_character_points_remaining = (
                                                int(cache.statsdb.cp.base) +
                                                int(cache.statsdb.cp.gained) +
                                                set_values.static_character_points_temp
                                            ) - int(cache.statsdb.cp.spent);
                                        }
                                    }
                                }
                            }

                            cache.statsdb.health.temp = damage.taken !== 0 ? 
                                Math.max(0, cache.statsdb.health.temp - damage.taken) : 0;

                            damage.taken = cache.statsdb.health.temp < 0 ?
                                cache.statsdb.health.temp * -1 : damage.taken;

                            cache.statsdb.health[`${roll.attacker.weapon.severity}`] += damage.taken;

                            cache.statsdb.health.remaining =
                                cache.statsdb.health.base
                                + cache.statsdb.health.temp
                                - cache.statsdb.health.damage
                                - cache.statsdb.health.stun;

                            set_values.static_character_health_damage = cache.statsdb.health.damage;
                            set_values.static_character_health_remaining = cache.statsdb.health.remaining;
                            set_values.static_character_health_stun = cache.statsdb.health.stun;
                            set_values.static_character_health_temp = cache.statsdb.health.temp;
                            
                            const max = cache.statsdb.health.base + cache.statsdb.health.temp;
                            const loss = cache.statsdb.health.damage + cache.statsdb.health.stun;
                            setStatusStateDescription(cache, set_values, 'health', max, loss);
                            roll.template += ` {{damagetaken=${damage.taken}}}`;
                        }
                    }
                } else {
                    if (roll.attacker === undefined) {
                        roll.template += ' {{result=[[1d0]]}}' +
                        ` {{emote=${roll.name}'s ${roll.type.capitalize()}` +
                        ` roll vs TN ${roll.target.number} failed.}}`;
                    } else {
                        roll.template += ' {{result=[[1d0]]}}' +
                        ` {{emote=${roll.attacker.name}'s ${roll.attacker.type.capitalize()}` +
                        ` ${roll.attacker.type === 'attack' ? 'on' : 'roll vs'} ${roll.name} failed.}}`;
                    }
                }
                roll.crp = await startRoll(roll.template);
                finishRoll(roll.crp.rollId);
            break;
        }
    }

    /* Menu Functions */
    async function displayHelp(cache) {
        const display = {};
        clog(cache, display, 'displayHelp()');
        display.template = `&{template:display-help} {{roll=1d0}}`;
        display.roll = await startRoll(display.template);
        finishRoll(display.roll.rollId);
    }

    async function openMenu(cache, set_values) {
        const query = {};
        let commit_changes = true;
        clog(cache, query, 'openMenu()');
        // Determine which menu to present
        switch (cache.source_id) {
            case 'edit':
                switch (cache.source_section) {
                    case 'screen':
                    case 'gmscreen':
                        query.selection = 'screenroot';
                    break;
                    case 'skills':
                        query.selection = 'skillsroot';
                    break;
                    case 'stats':
                        query.selection = 'statsroot';
                    break;
                    case 'status':
                        query.selection = 'statusroot';
                    break;
                }
            break;
            case 'update':
                query.selection = 'timeelapseroot';
                await cacheSectionIDs(cache, 'condition');
            break;
        }
        // Loop through menu choices until an answer is provided
        while (query.answer === undefined) {
            switch(query.selection) {
                // Screen Menu Options Root
                case 'screenroot':
                    query.title = `${getTranslationByKey("choose-section-to-edit")}`;
                    query.options = 
                        `|${getTranslationByKey("character-details")},characterdetails` +
                        `|${getTranslationByKey("character-points")},characterpoints` +
                        `|${getTranslationByKey("sheet-settings")},sheetsettings`;
                break;
                // Screen Menu Options Level 1
                case 'characterdetails':
                    query.title = `${getTranslationByKey("character-details")}`;
                    query.options = 
                        `|${getTranslationByKey("class")},static_character_details_class` +
                        `|${getTranslationByKey("height")},static_character_details_height` +
                        `|${getTranslationByKey("possessive-pronoun")},static_character_details_pronoun` +
                        `|${getTranslationByKey("race")},static_character_details_race` +
                        `|${getTranslationByKey("size")},static_character_details_size` +
                        `|${getTranslationByKey("weight")},static_character_details_weight` +
                        `|${getTranslationByKey("go-back")},screenroot`;
                break;
                case 'characterpoints':
                    query.title = `${getTranslationByKey("character-points")}`;
                    query.options = 
                        `|${getTranslationByKey("base")},static_character_points_base` +
                        `|${getTranslationByKey("gained")},static_character_points_gained` +
                        `|${getTranslationByKey("temporary")},static_character_points_temp` +
                        `|${getTranslationByKey("go-back")},screenroot`;
                break;
                case 'sheetsettings':
                    query.title = `${getTranslationByKey("sheet-settings")}`;
                    query.options = 
                         `|${getTranslationByKey("debug-level")},static_sheet_settings_debug` +
                         `|${getTranslationByKey("game-master-name")},static_sheet_settings_gm` +
                         `|${getTranslationByKey("player-name")},static_sheet_settings_player` +
                         `|${getTranslationByKey("sheet-type")},static_sheet_settings_type` +
                         `|${getTranslationByKey("theme")},static_sheet_settings_theme` +
                         `|${getTranslationByKey("go-back")},screenroot`;
                break;
                // Screen Menu Options Level 2
                case 'static_character_details_size':
                    query.title = `${getTranslationByKey("select-size-template")}`;
                    query.options = 
                        `|${getTranslationByKey("point")},point` +
                        `|${getTranslationByKey("mote")},mote` +
                        `|${getTranslationByKey("speck")},speck` +
                        `|${getTranslationByKey("minute-small")},minute` +
                        `|${getTranslationByKey("wee")},wee` +
                        `|${getTranslationByKey("teeny")},teeny` +
                        `|${getTranslationByKey("fine")},fine` +
                        `|${getTranslationByKey("diminutive")},diminutive` +
                        `|${getTranslationByKey("tiny")},tiny` +
                        `|${getTranslationByKey("small")},small` +
                        `|${getTranslationByKey("medium")},medium` +
                        `|${getTranslationByKey("large")},large` +
                        `|${getTranslationByKey("huge")},huge` +
                        `|${getTranslationByKey("mammoth")},mammoth` +
                        `|${getTranslationByKey("gigantic")},gigantic` +
                        `|${getTranslationByKey("gargantuan")},gargantuan` +
                        `|${getTranslationByKey("colossal")},colossal` +
                        `|${getTranslationByKey("enormous")},enormous` +
                        `|${getTranslationByKey("monstrous")},monstrous` +
                        `|${getTranslationByKey("titanic")},titanic` +
                        `|${getTranslationByKey("monumental")},monumental` +
                        `|${getTranslationByKey("go-back")},characterdetails`;
                    query.attribute = query.selection;
                break;
                case 'static_sheet_settings_debug':
                    query.title = 'Debug Level';
                    query.options = 
                        `|${getTranslationByKey("none")},none` +
                        `|${getTranslationByKey("info")},info` +
                        `|${getTranslationByKey("events")},events` +
                        `|${getTranslationByKey("performance")},performance` +
                        `|${getTranslationByKey("go-back")},sheetsettings`;
                    query.attribute = query.selection;
                break;
                case 'static_sheet_settings_type':
                    query.title = `${getTranslationByKey("sheet-type")}`;
                    query.options = 
                        `|${getTranslationByKey("game-master-u")},GM` +
                        `|${getTranslationByKey("player")},Player` +
                        `|${getTranslationByKey("go-back")},sheetsettings`;
                    query.attribute = query.selection;
                break;
                case 'static_sheet_settings_theme':
                    query.title = `${getTranslationByKey("theme")}`;
                    query.options = 
                        `|${getTranslationByKey("tri-stat-core")},tri stat core` +
                        `|${getTranslationByKey("big-eyes-small-mouth-u")},besm` +
                        `|${getTranslationByKey("absolute-power")},absolute power` +
                        `|${getTranslationByKey("bela-lugosi")},bela lugosi` +
                        `|${getTranslationByKey("dark-forest")},dark forest` +
                        `|${getTranslationByKey("galaxy-express")},galaxy express` +
                        `|${getTranslationByKey("high-contrast")},high contrast` +
                        `|${getTranslationByKey("imperial")},imperial` +
                        `|${getTranslationByKey("lavender")},lavender` +
                        `|${getTranslationByKey("oceans")},oceans` +
                        `|${getTranslationByKey("pomegranate")},pomegranate` +
                        `|${getTranslationByKey("sandstone")},sandstone` +
                        `|${getTranslationByKey("stormtrooper")},stormtrooper` +
                        `|${getTranslationByKey("valley-of-the-wind")},valley of the wind` +
                        `|${getTranslationByKey("go-back")},sheetsettings`;
                    query.attribute = query.selection;
                break;
                // Screen Menu Free Text Responses
                case 'static_character_details_pronoun':
                    query.title = `${getTranslationByKey("possessive-pronoun")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_character_points_base':
                    query.title = `${getTranslationByKey("character-point-base")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_character_points_gained':
                    query.title = `${getTranslationByKey("character-point-gained")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_character_points_temp':
                    query.title = `${getTranslationByKey("character-point-temporary")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_sheet_settings_player':
                    query.title = `${getTranslationByKey("player-name")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_character_details_height':
                    query.standard = 0;//await crpGet(cache, 'standard') !== 'metric' ? 
                        //0 : 1;
                    query.template = getSizeTemplate(cache);
                    query.title = 
                        `${getTranslationByKey("enter-height-in")} ${query.template.height.unit[query.standard]} (` +
                        `${query.template.height.min[query.standard]}-` +
                        `${query.template.height.max[query.standard]})`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_character_details_weight':
                    query.standard = 0; //await crpGet(cache, 'standard') === 'metric' ? 0 : 1;
                    query.template = getSizeTemplate(cache);
                    query.title = 
                        `${getTranslationByKey("enter-weight-in")} ${query.template.mass.unit[query.standard]} (` +
                        `${query.template.mass.min[query.standard]}-` +
                        `${query.template.mass.max[query.standard]})`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_character_details_race':
                    query.title = `${getTranslationByKey("enter-character-race")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_character_details_class':
                    query.title = `${getTranslationByKey("enter-character-class")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                case 'static_sheet_settings_gm':
                    query.title = `${getTranslationByKey("enter-game-master-name")}`;
                    query.options = '';
                    query.attribute = query.selection;
                break;
                // Stats Menu Options Root
                case 'statsroot':
                    query.title = `Choose Stat to edit`;
                    query.options = 
                        `|${getTranslationByKey("body")},statbody` +
                        `|${getTranslationByKey("mind")},statmind` +
                        `|${getTranslationByKey("soul")},statsoul`;
                break;
                // Stats Menu Options Level 1
                case 'statbody':
                case 'statmind':
                case 'statsoul':
                    query.stat = query.selection.slice(4);
                    query.title = `${getTranslationByKey("choose-task")}`;
                    query.options = 
                        `|${getTranslationByKey("base")},statbase` +
                        `|${getTranslationByKey("temp")},stattemp` +
                        `|${getTranslationByKey("damage")},statdamage` +
                        `|${getTranslationByKey("go-back")},statsroot`;
                break;
                // Stats Menu Options Level 2
                case 'statbase':
                case 'stattemp':
                case 'statdamage':
                    query.point_type = query.selection.slice(4);
                    query.title = `${getTranslationByKey("choose-method")}`;
                    query.options = 
                        `|${getTranslationByKey("add-value")},addstatpoints` +
                        `|${getTranslationByKey("remove-value")},removestatpoints` +
                        `|${getTranslationByKey("set-value")},setstatpoints` +
                        `|${getTranslationByKey("go-back")},statsroot`;
                break;
                case 'addstatpoints':
                case 'removestatpoints':
                case 'setstatpoints':
                    query.point_method = query.selection.slice(0, query.selection.length - 10);
                    query.title = 
                        `${getTranslationByKey("enter-value")}`;
                    query.options = '';
                    query.attribute = 'stats_points';
                break;
                // Status Menu Options Root
                case 'statusroot':
                    //cache.rulesdb = await crpGet(cache, 'rulesdb');
                    //cache.rulesdb = JSON.parse(cache.rulesdb);
                    query.title = `${getTranslationByKey("choose-section-to-edit")}`;
                    query.options = 
                        `|${getTranslationByKey("conditions")},conditions` +
                        `|${getTranslationByKey("energy-points")},energy` +
                        `|${getTranslationByKey("health-points")},health`;
                    query.options += cache.rulesdb.rules_optional_sanity_status ?
                        `|${getTranslationByKey("sanity-points")},sanity` : '';
                    query.options += cache.rulesdb.rules_optional_society_status ?
                        `|${getTranslationByKey("society-points")},society` : '';
                break;
                // Status Menu Options Level 1
                case 'conditions':
                    await cacheSectionIDs(cache, 'condition');
                    query.title = `${getTranslationByKey("choose-task")}`;
                    query.options = 
                        `|${getTranslationByKey("add-condition")},addcondition`;
                    query.options += cache.condition_ids.length !== 0 ?
                        `|${getTranslationByKey("remove-condition")},removecondition` : '';
                    query.options += 
                        `|${getTranslationByKey("go-back")},statusroot`;
                break;
                case 'energy':
                case 'health':
                case 'sanity':
                case 'society':
                    query.get_attrs = [
                        `static_character_${query.selection}_base`,
                        `static_character_${query.selection}_temp`,
                        `static_character_${query.selection}_damage`,
                    ];
                    if (query.selection === 'health') {
                        query.get_attrs.push(`static_character_${query.selection}_stun`);
                    }
                    query.point_section = query.selection;
                    query.title = `${getTranslationByKey("choose")} ${query.selection.capitalize()} ` +//${capitalize(query.selection)} ` +
                        `${getTranslationByKey("point-type")}`;
                    query.options = 
                         `|${getTranslationByKey("damage")},damage` +
                         `|${getTranslationByKey("temp")},temp`;
                    query.options += query.selection === 'health' ?
                        `|${getTranslationByKey("stun")},stun` : '';
                    query.options += `|${getTranslationByKey("go-back")},statusroot`;
                break;
                case 'damage':
                case 'temp':
                case 'stun':
                    query.point_type = query.selection;
                    query.title = `${getTranslationByKey("choose-method")}`;
                    query.options = 
                         `|${getTranslationByKey("add-value")},addpoints` +
                         `|${getTranslationByKey("remove-value")},removepoints` +
                         `|${getTranslationByKey("set-value")},setpoints` +
                         `|${getTranslationByKey("go-back")},statusroot`;
                break;
                case 'addpoints':
                case 'removepoints':
                case 'setpoints':
                    query.point_method = query.selection;
                    query.title = 
                        `${getTranslationByKey("enter-value")}`;
                    query.options = '';
                    query.attribute = 'status_points';
                break;
                // Status Menu Options Level 2
                case 'addcondition':
                    query.title = `${getTranslationByKey("choose-condition")}`;
                    query.options = await buildConditionsMenu(cache);
                    query.attribute = 'repeating_condition';
                break;
                case 'removecondition':
                    query.title = `${getTranslationByKey("choose-condition")}`;
                    query.options = await buildActiveConditionsMenu(cache);
                    query.attribute = 'delete_condition';
                break;
                // Time Elapse Menu Options
                case 'timeelapseroot':
                    query.title = `${getTranslationByKey("choose-task")}`;
                    query.options = 
                        `|1 ${getTranslationByKey("round")},round` +
                        `|n ${getTranslationByKey("rounds").capitalize()},rounds` +
                        `|${getTranslationByKey("one-minute-or-dramatic-scene").capitalize()},minute` +
                        /*
                        `|n ${capitalize(getTranslationByKey("rounds"))},rounds` +
                        `|${capitalize(getTranslationByKey("one-minute-or-dramatic-scene"))},minute` +
                        */
                        `|n ${getTranslationByKey("minutes-time")},minutes` +
                        `|1 ${getTranslationByKey("hour")},hour` +
                        `|n ${getTranslationByKey("hours")},hours` +
                        `|1 ${getTranslationByKey("day")},day` +
                        `|n ${getTranslationByKey("days")},days` +
                        `|${getTranslationByKey("go-back")},statusroot`;
                    query.attribute = 'time_elapsed';
                break;
                // Time Elapse Menu Options Level 1
                case 'rounds':
                case 'minutes':
                case 'hours':
                case 'days':
                    const number_of = 
                        query.selection === 'rounds' ? '1-20' :
                        query.selection === 'minutes' ? '1-60' :
                        query.selection === 'hours' ? '1-24' :
                        query.selection === 'days' ? '1+' : '';
                    query.title = `${getTranslationByKey("enter-number-of")} ` +
                        `${query.selection} (${number_of})`;
                    query.options = '';
                    query.time_unit = query.selection;
                break;
                // End of all menu options
                // Final result captured in query.answer
                default:
                    query.answer = query.selection;
            }
            if (query.answer === undefined) await crpQuery(cache, query);
        }
        // 
        switch (query.attribute) {
            case 'static_character_details_height':
                if (query.standard === 0) {
                    query.answer = `${parseFloat(query.answer)} ` +
                        `${query.template.height.unit_abv[query.standard]}`;
                } else {
                    query.feet = Math.floor(int(query.answer)/12);
                    query.inches = query.answer-(query.feet*12);
                    query.answer = `${query.feet}' ${query.inches}"`;
                }
            break;
            case 'static_character_details_weight':
                query.answer = `${parseFloat(query.answer)} ` +
                    `${query.template.mass.unit_abv[query.standard]}`;
            break;
            case 'static_character_points_base':
            case 'static_character_points_gained':
            case 'static_character_points_temp':
                //const values = await getAttrsAsync(['groupdb']);//,'statdb']);
                //cache.groupdb = JSON.parse(cache.groupdb);
                //cache.statdb = int(values.statdb);
                const points = {};
                clog(cache, points, 'Character Points Accounting(points)');
                points.base = query.attribute === 'static_character_points_base' ?
                    int(query.answer) : 
                    int(cache.statsdb.base);
                    //int(cache.static_character_points_base);
                points.gained = query.attribute === 'static_character_points_gained' ?
                    int(query.answer) : 
                    int(cache.statsdb.gained);
                    //int(cache.static_character_points_gained);
                points.temp = query.attribute === 'static_character_points_temp' ?
                    int(query.answer) : 
                    int(cache.statsdb.temp);
                    //int(cache.static_character_points_temp);
                points.total = points.base + points.gained + points.temp;
                points.spent = getSpentCharacterPoints(cache);// attributes_cost + defects_cost
                points.remaining = points.total - points.spent;
                //set_values.static_character_points_base = base;
                //set_values.static_character_points_gained = gained;
                //set_values.static_character_points_temp = temp;
                set_values.static_character_points_total = points.total;
                //set_values.static_character_points_spent = spent;
                set_values.static_character_points_remaining = points.remaining;
                const point_types = ['base','gained','temp','spent'];
                for (let i = 0; i < 4; i++) {
                    cache.statsdb.cp[point_types[i]] = points[point_types[i]];
                    set_values[`static_character_points_${point_types[i]}`] = 
                        points[point_types[i]];
                }
                //set_values.statsdb = JSON.stringify(cache.statsdb);
            break;
            case 'repeating_condition': // Add condition
                cache.condition_id = getConditionID(cache, query.selection);
                if (!cache.condition_id) {
                    return; //=> whisper to character can't add existing condition type
                } else {
                    //=> create new or stackable condition
                    await setConditiondb(cache, set_values, query.selection);
                    set_values[`repeating_condition_${cache.condition_id}_name`] = 
                        query.selection.capitalize();
                }
                set_values[`repeating_condition_${cache.condition_id}_description`] = 
                    await getConditionDescription(cache, query.selection);
                //set_values.conditiondb = JSON.stringify(cache.conditiondb);
                commit_changes = false;
            break;
            case 'delete_condition':
                cache.remove = query.selection.split('~');
                cache.condition = {
                    name: cache.remove[0].toLowerCase(),
                    id: cache.remove[1]
                };
                removeConditiondbEntry(cache, set_values);
                removeRepeatingRow(`repeating_condition_${cache.condition.id}`);
                commit_changes = false;
            break;
            case 'status_points':
                //query.point_values = await getAttrsAsync(query.get_attrs);
                query.attribute = `static_character_${query.point_section}_${query.point_type}`;
                query.point_change = int(query.answer);
                /*
                query.base = int(query.point_values[`static_character_${query.point_section}_base`]);
                query.damage = int(query.point_values[`static_character_${query.point_section}_damage`]);
                query.temp = int(query.point_values[`static_character_${query.point_section}_temp`]);
                query.stun = int(query.point_values[`static_character_${query.point_section}_stun`]);
                */
                if (query.point_method === 'addpoints') {
                    cache.statsdb[query.point_section][query.point_type] += query.point_change;
                    //query[query.point_type] += query.point_change;
                } else if (query.point_method === 'removepoints') {
                    cache.statsdb[query.point_section][query.point_type] -= query.point_change;
                    //query[query.point_type] -= query.point_change;
                } else {
                    cache.statsdb[query.point_section][query.point_type] = query.point_change;
                    //query[query.point_type] = query.point_change;
                }
                query.point_max = cache.statsdb[query.point_section].base + cache.statsdb[query.point_section].temp;
                //query.point_max = query.base + query.temp;
                query.point_loss = cache.statsdb[query.point_section].damage + (
                    query.point_section === 'health' ?
                        cache.statsdb.health.stun : 0
                );
                query.answer = cache.statsdb[query.point_section][query.point_type];
                /*
                set_values[`static_character_${query.point_section}_${query.point_type}`] =
                    cache.statsdb[query.point_section][query.point_type];
                set_values[`static_character_${query.point_section}_remaining`] = 
                    cache.statsdb[query.point_section].base
                    + cache.statsdb[query.point_section].temp
                    - cache.statsdb[query.point_section].damage + (
                        query.point_section === 'health' ?
                        cache.statsdb.health.stun : 0
                    );
                */
                //query.point_loss = query.damage + query.stun;
                setStatusStateDescription(cache, set_values, query.point_section, query.point_max, query.point_loss);
                //query.answer = query[query.point_type];
            break;
            case 'time_elapsed':
                const time_elapse = {};
                time_elapse.conditions = [
                    'anemic',
                    'blinded',
                    'continuing',
                    'demoralized',
                    'drained',
                    'force field',
                    'incapacitated',
                    'irritant',
                    'lethargic',
                    'serious injury',
                    'unconscious'
                ];
                for (let i = 0; i < time_elapse.conditions.length; i++) {
                    const current_condition = time_elapse.conditions[i] === 'force field' ?
                        cache.attrdb[`${time_elapse.conditions[i]}`] : 
                        cache.conditiondb[`${time_elapse.conditions[i]}`];
                    if (current_condition.length !== 0) {
                        query.time_unit = query.time_unit === undefined ?
                            query.selection : query.time_unit;
                        time_elapse.rounds = 
                            query.time_unit === 'round' ? 1 :
                            query.time_unit === 'rounds' ? query.selection :
                            query.time_unit === 'minute' ? 20 :
                            query.time_unit === 'minutes' ? query.selection * 20 :
                            query.time_unit === 'hour' ? 1200 :
                            query.time_unit === 'hours' ? query.selection * 1200 :
                            query.time_unit === 'day' ? 28800 :
                            query.time_unit === 'days' ? query.selection * 28800 :
                            Infinity;
                        for (let x = 0; x < current_condition.length; x++) {
                            
                            if (time_elapse.conditions[i] === 'force field') {
                                const ar_index = current_condition[x].config.findIndex(c => c.name === 'armor rating');
                                const has_regenerating = current_condition[x].enhancements.findIndex(c => c.name === 'regenerating') !== -1;
                                if (
                                    (
                                        current_condition[x].active === false &&
                                        current_condition[x].config[ar_index].rank < current_condition[x].elevel * 10
                                    ) || has_regenerating
                                ) {
                                    current_condition[x].config[ar_index].rank += time_elapse.rounds * 10;
                                    current_condition[x].config[ar_index].rank = 
                                        current_condition[x].config[ar_index].rank > current_condition[x].elevel * 10 ?
                                            current_condition[x].elevel * 10 : current_condition[x].config[ar_index].rank;

                                    current_condition[x].config.sort();
                                    let config_display = '';
                                    for (let i = 0; i < current_condition[x].config.length; i++) {
                                        config_display += `${current_condition[x].config[i].name.capitalize()} (${
                                            isNaN(current_condition[x].config[i].rank) ?
                                            current_condition[x].config[i].rank.capitalize() : 
                                            int(current_condition[x].config[i].rank)
                                        })\n`;
                                    }
                                    set_values[`repeating_attribute_${current_condition[x].row_id}_configuration`] = config_display;
                                }
                            } else {
                                time_elapse.rounds_remining =
                                    current_condition[x].duration - time_elapse.rounds;
                                current_condition[x].duration = time_elapse.rounds_remining;
                                time_elapse.condition_displays_rounds = [
                                    'blinded',
                                    'continuing',
                                    'unconscious'
                                ].indexOf(time_elapse.conditions[i]) !== -1;
                                if (time_elapse.condition_displays_rounds) {
                                    current_condition[x].input1 = time_elapse.rounds_remining;
                                } else if (time_elapse.conditions[i] === 'drained') {
                                    const drained = {};
                                    drained.answer = Math.ceil(time_elapse.rounds_remining / 1200);
                                    drained.stat = current_condition[x].input1.toLowerCase();
                                    drained.point_type = 'damage';
                                    drained.point_method = 'set';
                                    current_condition[x].input2 = drained.answer * -1;
                                    await setStat(cache, drained, set_values);
                                    await setDerivedValues(cache, set_values);
                                }
                                if (time_elapse.rounds_remining < 1) {
                                    cache.condition = {
                                        name: time_elapse.conditions[i],
                                        id: current_condition[x].id
                                    };
                                    removeConditiondbEntry(cache, set_values);
                                    removeRepeatingRow(`repeating_condition_${cache.condition.id}`);
                                } else {
                                    cache.condition_id = current_condition[x].id;
                                    set_values[`repeating_condition_${cache.condition_id}_description`] = 
                                    await getConditionDescription(cache, time_elapse.conditions[i]);
                                }
                            }
                        }
                        //set_values.conditiondb = JSON.stringify(cache.conditiondb);
                    }
                }
                commit_changes = false;
            break;
            case 'stats_points':
                await setStat(cache, query, set_values);
                await setDerivedValues(cache, set_values);
                commit_changes = false;
            break;
            case 'static_sheet_settings_type':
                set_values.static_sheet_state_type = query.answer.toLowerCase();
                set_values.static_sheet_settings_gm = cache.character_name;
                if (set_values.static_sheet_state_type === 'gm') {
                    cache.rulesdb = {
                        "rules_attribute_deathdodge_status":0,
                        "rules_attribute_debilitate_status":0,
                        "rules_attribute_eknockback_status":0,
                        "rules_attribute_expertise_status":0,
                        "rules_attribute_extradefenses_status":0,
                        "rules_attribute_flankdefense_status":0,
                        "rules_attribute_hardboiled_status":0,
                        "rules_attribute_miniobject_status":0,
                        "rules_attribute_speedburst_status":0,
                        "rules_attribute_taunt_status":0,
                        "rules_attribute_tournament_status":0,
                        "rules_defect_nohealing_status":0,
                        "rules_enhancement_absorption_status":0,
                        "rules_enhancement_cognition_status":0,
                        "rules_enhancement_conversion_status":0,
                        "rules_enhancement_forcefield_status":0,
                        "rules_enhancement_powerflux_status":0,
                        "rules_enhancement_sixthsense_status":0,
                        "rules_enhancement_sizechange_status":0,
                        "rules_enhancement_summoncreatures_status":0,
                        "rules_enhancement_teleport_status":0,
                        "rules_enhancement_transfer_status":0,
                        "rules_enhancement_weapon_status":0,
                        "rules_homebrew_ammotracking_status":0,
                        "rules_homebrew_depletereserve_status":0,
                        "rules_homebrew_disperse_status":0,
                        "rules_homebrew_specificlimiter_status":0,
                        "rules_limiter_capped_status":0,
                        "rules_limiter_plantcontrol_status":0,
                        "rules_limiter_proportionaldamage_status":0,
                        "rules_limiter_skillflux_status":0,
                        "rules_limiter_timed_status":0,
                        "rules_limiter_transmute_status":0,
                        "rules_optional_criticalfailures_status":"none",
                        "rules_optional_criticalhits_status":"none",
                        "rules_optional_dice_status":"normal",
                        "rules_optional_enhancedrecovery_status":0,
                        "rules_optional_extradamage_status":0,
                        "rules_optional_genre_status":0,
                        "rules_optional_individual_status":0,
                        "rules_optional_knockback_status":0,
                        "rules_optional_knockout_status":0,
                        "rules_optional_maneuvers_status":0,
                        "rules_optional_mos_status":0,
                        "rules_optional_movementpenalties_status":0,
                        "rules_optional_rangepenalties_status":0,
                        "rules_optional_sanity_status":0,
                        "rules_optional_seriousinjury_status":0,
                        "rules_optional_shield_status":0,
                        "rules_optional_shockvalue_status":0,
                        "rules_optional_society_status":0,
                        "rules_optional_spreadinitiative_status":0,
                        "rules_optional_variable_status":"fixed"
                    };
                    await setBaseRules(cache, set_values);
                }
            break;
        }
        if (commit_changes) set_values[query.attribute] = query.answer;
    }

    async function journalMenu(cache, set_values) {
        const query = {} ;
        clog(cache, query, 'journalMenu()');
        query.next = 'select_task';
        cache.static_journal_visible_id = int(cache.static_journal_visible_id);
        query.commit = false;
        while (!query.commit) {
            switch (query.next) {
                // Journal Menu Options
                case 'select_task':
                    query.length = cache.journaldb.length;
                    query.title = `${getTranslationByKey("choose-task")}`;
                    query.options = 
                        `|${getTranslationByKey("add")},add` +
                        `|${getTranslationByKey("edit")},edit`;
                    query.options += query.length !== 1 ? 
                        `|${getTranslationByKey("remove")},remove` : '';
                    query.last = query.next;
                break;
                case 'select_type':
                    query.title = `${getTranslationByKey(query.task)}`;
                    query.options = 
                        `|${getTranslationByKey("journal")},journal`;
                    query.options += query.task !== 'edit' ?
                        `|${getTranslationByKey("page")},page` : '';
                    query.options +=
                        `|${getTranslationByKey("go-back")},select_task`;
                    query.last = query.next;
                break;
                case 'edit_journal':
                    query.title = 'Select Journal to Rename';//`${getTranslationByKey("enter-new-title")}`;
                    query.options = '';
                    for (i = 0, n = cache.journaldb.length; i < n; i++) {
                        query.options += `|${cache.journaldb[i].name},${i}`;
                    }
                    query.options += `|${getTranslationByKey("go-back")},select_task`;
                    query.last = query.next;
                break;
                case 'remove_journal':

                break;
                case 'remove_page':
                    query.get = await getAttrsAsync([
                        'static_journal_page_number'
                    ]);
                    query.title = `Page Number to Remove (1-${query.get.static_journal_page_number})`;//`${getTranslationByKey("enter-new-title")}`;
                    query.options = '';
                    query.last = query.next;
                break;
                case 'remove_confirm':
                    query.title = `Confirm Remove ${
                        query.last === 'remove_page' ?
                        'Page' : 'Journal'
                    }`;
                    query.options = `|No,${query.last}|Yes,yes`;
                    query.last = query.next;
                break;
                case 'rename_journal':
                    query.title = `${getTranslationByKey("enter-new-title")}`;//query.title = 'Rename Journal';
                    query.options = '';
                    query.last = query.next;
                break;
                default:
                    query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.last) {
                    case 'select_task':
                        query.task = query.selection;
                        query.next = query.selection === 'edit' ?
                            'edit_journal' : 'select_type';
                    break;
                    case 'select_type':
                        query.type = query.selection;
                        query.next = query.selection === 'select_task' ? 
                            'select_task' : 'done';
                    break;
                    case 'edit_journal':
                        query.journal_id = query.selection;
                        query.next = 'rename_journal';
                    break;
                    case 'remove_journal':

                    break;
                    case 'remove_page':
                        query.remove = query.selection;
                        query.next = 'remove_confirm';
                    break;
                    case 'remove_confirm':
                        if (query.selection !== 'yes') {
                            query.next = query.selection;
                        }
                    break;
                    case 'rename_journal':
                        cache.journaldb[query.journal_id].name = query.selection;
                        if (cache.static_journal_visible_id === query.journal_id) {
                            set_values.static_journal_title_name = query.selection;
                        }
                        query.commit = true;
                    break;
                }
            } else {
                switch(`${query.task}_${query.type}`) {
                    case 'add_journal':
                        const new_journal = {
                            entries: [],
                            journal_id: 0,
                            last_index: 0,
                            name: '',
                            removed: false,
                        };
                        cache.journaldb.push(new_journal);
                        query.length = cache.journaldb.length;
                        query.index = query.length - 1;
                        cache.journaldb[query.index].journal_id = query.index;
                        cache.journaldb[query.index].name = `Journal Entry ${query.length}`;
                        set_values.static_journal_visible_id = query.index;
                        set_values.static_journal_page_entry = '';
                        set_values.static_journal_page_number = '1';
                        set_values.static_journal_title_name = cache.journaldb[query.index].name;
                    break;
                    case 'add_page':
                        const save = await getAttrsAsync([
                            'static_journal_page_entry',
                            'static_journal_page_number'
                        ]);
                        // Get the current page number (-1 to get index)
                        const current_page = int(save.static_journal_page_number);
                        // Save the current journal entry to the correct index
                        cache.journaldb[cache.static_journal_visible_id].entries[current_page - 1] = 
                            save.static_journal_page_entry;
                        // Create new journal entry
                        cache.journaldb[cache.static_journal_visible_id].entries.push('');
                        set_values.static_journal_page_number =
                            cache.journaldb[cache.static_journal_visible_id].entries.length;
                        set_values.static_journal_page_entry = '';
                    break;
                }
            }
        }            
    }

    async function skillsMenu(cache, set_values) {
        const query = {} ;
        clog(cache, query,'skillsMenu()');
        const skills_cost = {
            "acrobatics":[3,3,3,2,2,3,2,1,2,2,3,2,2,2,2,2,3,2,2,3,1,1,2,3,2,1,2,2,1,2],
            "animal training":[2,2,2,1,1,1,1,2,1,2,3,2,2,2,1,1,1,2,1,1,1,2,1,2,2,1,2,1,2,3],
            "architecture":[1,1,2,1,1,1,1,1,1,2,1,1,1,1,2,1,1,2,1,1,1,2,1,2,2,3,2,2,1,1],
            "area knowledge":[2,2,3,2,3,2,2,2,2,2,2,2,2,3,2,1,2,3,1,3,2,3,2,2,1,2,1,1,2,1],
            "artisan":[1,1,1,1,1,1,1,2,1,2,2,1,1,1,1,1,1,2,1,1,1,2,2,2,2,2,2,2,2,2],
            "biological sciences":[2,2,2,2,2,2,2,1,3,2,3,1,1,1,3,3,1,3,2,2,1,1,1,1,1,1,1,1,1,1],
            "boating":[2,2,1,1,2,1,1,1,2,1,1,2,2,2,2,2,2,1,1,1,2,2,3,1,2,1,2,1,1,1],
            "burglary":[2,2,2,2,3,2,2,1,2,1,2,2,2,2,2,1,2,2,2,2,2,1,3,2,2,1,2,2,1,2],
            "business":[1,1,1,1,1,1,1,2,1,2,1,1,2,1,2,1,2,1,1,2,1,2,1,1,1,3,1,1,1,1],
            "civilisation":[2,1,1,1,1,1,1,1,2,2,3,3,2,1,2,1,2,2,2,3,2,3,1,1,1,2,1,2,1,1],
            "climbing":[2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,1,1,2,2,1,2,1,3,1,1,1,1,2,2,1],
            "computers":[2,3,1,3,3,3,2,2,3,2,0,0,0,2,3,3,3,2,2,2,2,0,0,0,0,0,0,0,0,0],
            "controlled breathing":[1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1],
            "cultural arts":[1,1,1,1,1,1,2,2,1,2,2,1,1,2,1,1,2,1,2,1,1,2,1,2,2,2,1,2,1,1],
            "demolitions":[2,3,2,1,2,3,1,1,2,1,1,1,1,1,2,1,3,2,1,1,2,1,2,1,1,1,1,1,0,2],
            "disguise":[2,2,2,2,2,3,2,2,3,2,1,2,2,2,2,1,1,1,1,3,2,1,2,2,2,1,2,2,1,2],
            "domestic arts":[1,1,1,1,1,2,3,3,1,1,1,1,2,1,1,1,1,2,2,1,1,2,2,2,1,2,2,2,3,2],
            "driving":[2,3,1,2,3,2,2,2,2,2,0,0,0,2,2,2,3,2,2,2,3,1,1,1,1,1,1,3,2,1],
            "engineering":[2,1,2,2,1,1,1,1,2,2,2,2,1,1,3,3,3,2,1,2,2,2,1,1,2,3,1,3,1,1],
            "environmental sciences":[1,1,1,1,2,1,2,1,2,2,3,2,1,1,2,3,2,3,2,2,1,2,1,1,2,2,1,1,1,1],
            "electronics":[2,2,1,2,2,2,1,1,2,2,1,1,1,1,3,3,3,2,2,2,2,0,0,0,0,0,0,0,0,0],
            "empathy":[1,1,2,2,2,1,3,3,1,3,3,2,2,2,2,1,2,3,2,2,1,2,2,1,1,2,1,2,2,1],
            "etiquette":[1,1,1,1,1,1,2,2,1,1,2,2,1,1,1,1,2,1,1,1,1,2,1,3,2,2,1,2,1,1],
            "forgery":[1,1,1,1,2,1,2,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1],
            "gaming":[1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,3],
            "interrogation":[2,2,2,2,3,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,1,2],
            "intimidation":[2,3,2,3,2,2,2,1,2,3,2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,3,2,2,3,2],
            "languages":[1,1,1,2,1,1,1,2,1,3,2,2,1,1,1,1,1,1,3,1,1,2,2,1,1,2,1,1,1,1],
            "law":[1,1,1,1,3,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,2,1,1,1,2],
            "leadership":[1,2,2,2,2,1,2,1,2,3,1,1,2,2,2,2,3,2,2,2,2,3,2,3,2,2,2,2,3,3],
            "listening":[2,1,3,2,2,2,2,1,2,2,2,2,2,2,2,1,1,2,2,2,2,1,2,1,1,1,2,2,1,2],
            "mechanics":[2,2,1,1,2,1,1,2,2,2,1,1,1,2,2,2,3,3,2,2,2,2,1,1,1,3,1,3,0,1],
            "medical":[2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,3,2,2,2,3,2,2,2,2,3,2,1,2],
            "military sciences":[2,2,2,2,2,1,1,1,2,1,2,3,2,1,2,2,3,2,2,2,3,2,2,2,2,1,2,2,1,2],
            "naturopathy":[1,1,1,1,1,1,1,2,1,3,3,2,2,1,2,1,1,2,2,1,1,1,1,1,2,1,1,1,3,2],
            "navigation":[1,1,1,1,1,1,1,1,1,1,2,2,2,1,1,2,3,2,2,3,2,2,3,2,2,2,2,2,2,2],
            "occult":[2,1,1,3,1,1,1,1,2,3,3,3,2,3,1,1,1,1,1,1,1,1,1,2,1,1,2,2,2,2],
            "occupation":[1,1,1,1,1,2,1,2,1,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1],
            "performing arts":[1,1,2,1,2,2,2,2,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1],
            "persuasion":[3,3,2,1,2,2,3,2,3,2,2,2,2,2,2,2,2,2,2,3,2,2,3,2,2,2,2,2,2,2],
            "physical sciences":[2,1,1,1,2,2,1,1,2,2,2,1,1,1,1,3,2,2,2,2,1,1,1,1,1,2,1,2,1,1],
            "piloting":[2,2,1,2,2,2,1,1,2,1,1,1,0,1,2,2,2,2,2,3,3,0,0,0,0,0,0,3,0,0],
            "poisons":[1,1,1,1,1,1,1,1,2,1,2,2,2,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1],
            "police sciences":[2,2,1,2,3,1,1,1,2,1,1,1,1,2,2,2,2,1,1,1,1,1,0,0,0,1,0,1,0,1],
            "power lifting":[2,3,2,2,2,3,1,1,2,1,1,2,2,2,2,2,1,1,1,2,2,1,2,2,1,1,2,2,3,2],
            "religion":[1,1,1,3,1,1,1,1,2,3,2,2,2,2,1,1,1,1,1,2,1,2,1,2,3,1,2,1,1,1],
            "riding":[1,1,1,1,1,1,1,1,1,1,2,2,2,1,1,1,1,2,1,1,1,2,2,3,2,1,3,1,2,3],
            "search":[2,2,2,2,3,1,1,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2],
            "seduction":[2,2,2,2,2,1,3,2,2,3,2,2,2,2,2,2,3,2,3,2,2,2,3,2,2,2,2,2,2,3],
            "sleight of hand":[2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,1,2,1,2,1,1,1,1,1,1,2],
            "social sciences":[1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,2,2,2,3,1,1,2,1,1,1,1,1,2,1,1],
            "sports":[1,1,1,1,1,2,2,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1,1,1,1,1],
            "stealth":[3,2,3,2,2,2,2,2,3,2,2,2,3,3,2,2,2,3,2,2,2,2,2,2,2,1,2,2,2,2],
            "street sense":[2,2,1,2,3,2,2,2,3,2,1,1,2,2,3,2,2,3,2,2,2,1,2,2,2,2,3,1,1,2],
            "survival":[2,2,3,2,2,2,1,1,2,2,2,2,3,1,1,1,1,3,1,1,2,2,3,2,2,2,2,2,3,2],
            "swimming":[1,1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1],
            "urban tracking":[2,1,2,3,3,1,2,1,2,3,1,1,1,2,3,1,2,2,1,1,2,1,1,1,1,2,2,1,0,2],
            "visual arts":[1,1,1,1,1,1,2,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1],
            "wilderness tracking":[1,1,2,1,1,1,1,1,1,1,2,2,2,1,1,1,1,2,1,1,2,2,3,2,2,1,2,2,3,2],
            "writing":[1,1,1,1,1,1,2,2,1,2,2,1,1,2,1,1,1,1,1,1,1,2,1,1,1,2,1,2,1,1]
        };
        const skill_stats = {
            'acrobatics':["body"],
            'animal training':["soul"],
            'architecture':["mind"],
            'areak nowledge':["mind"],
            'artisan':["body","soul"],
            'biological sciences':["mind"],
            'boating':["body","mind"],
            'burglary':["varaible"],
            'business':["mind"],
            'civilisation':["mind"],
            'climbing':["body"],
            'computers':["mind"],
            'controlled breathing':["varaible"],
            'cultural arts':["mind"],
            'demolitions':["varaible"],
            'disguise':["varaible"],
            'domestic arts':["varaible"],
            'driving':["varaible"],
            'engineering':["mind"],
            'environmental sciences':["mind"],
            'electronics':["mind"],
            'empathy':["soul"],
            'etiquette':["mind"],
            'forgery':["mind"],
            'gaming':["varaible"],
            'interrogation':["varaible"],
            'intimidation':["varaible"],
            'languages':["mind"],
            'law':["mind"],
            'leadership':["soul"],
            'listening':["body","soul"],
            'mechanics':["varaible"],
            'medical':["varaible"],
            'military sciences':["mind"],
            'naturopathy':["varaible"],
            'navigation':["mind"],
            'occult':["mind"],
            'occupation':["mind"],
            'performing arts':["body","mind","soul"],
            'persuasion':["soul"],
            'physical sciences':["mind"],
            'piloting':["body","mind"],
            'poisons':["mind"],
            'police sciences':["mind"],
            'power lifting':["body"],
            'religion':["varaible"],
            'riding':["varaible"],
            'search':["mind"],
            'seduction':["varaible"],
            'sleight of hand':["body"],
            'social sciences':["mind"],
            'sports':["varaible"],
            'stealth':["varaible"],
            'street sense':["varaible"],
            'survival':["varaible"],
            'swimming':["body"],
            'urban tracking':["mind"],
            'visual arts':["varaible"],
            'wilderness tracking':["varaible"],
            'writing':["mind","soul"]
        }
        query.next = 'select_task';
        query.commit = false;
        cache.skill_index = int(cache.static_skills_visible_id);
        while (!query.commit) {
            switch (query.next) {
                case 'select_task':
                    query.skill = '';
                    query.rank = 0;
                    query.specializations = [];
                    query.stat = [];
                    query.total = cache.attrdb.skills[cache.skill_index].individual.length;
                    query.title = `${getTranslationByKey("choose-task")}`;
                    query.options = `|${getTranslationByKey("add")},add`;
                    query.options += query.total !== 0 ? 
                        `|${getTranslationByKey("edit")},edit` : '';
                    query.options += query.total !== 0 ? 
                        `|${getTranslationByKey("remove")},remove` : '';
                    query.options += `|${getTranslationByKey("exit")},exit`;
                    query.last = query.next;
                break;
                case 'add_skill':
                    query.skill = '';
                    query.title = `${getTranslationByKey("add-skill")}`;
                    query.options = '';
                    for (let i = 0; i < all_skills.length; i++) {
                        query.options += cache.attrdb.skills[cache.skill_index].individual.findIndex(s => {
                            return s.skill === all_skills[i];
                        }) === -1 ? `|${getTranslationByKey(all_skills[i].toKebobCase())},${all_skills[i]}` : '';
                    }
                    query.options += `|${getTranslationByKey("go-back")},select_task`;
                    query.last = query.next;
                break;
                case 'edit_skill':
                    query.title = `${getTranslationByKey("edit")}`;
                    query.options = '';
                    query.options = cache.attrdb.skills[cache.skill_index].individual.map((s, i) => {
                        return `|${s.skill.capitalize()},${i}`;
                    });
                    query.options += `|${getTranslationByKey("go-back")},select_task`;
                    query.last = query.next;
                break;
                case 'remove_skill':
                    query.title = 'Remove';
                    query.options = cache.attrdb.skills[cache.skill_index].individual.map((s, i) => {
                        return `|${s.skill.capitalize()},${s.skill}~${i}~${s.row_id}`;
                    });
                    query.options += `|${getTranslationByKey("go-back")},select_task`;
                    query.last = query.next;
                break;
                case 'remove_confirm':
                    query.title = `Confirm Remove ${query.remove[0].capitalize()}`;
                    query.options = `|No,${query.last}|Yes,yes`;
                    query.last = query.next;
                break;
                case 'skill_menu':
                    query.title = `${getTranslationByKey(query.skill.toKebobCase())}`;
                    query.options = 
                        `|${getTranslationByKey("rank")} [ ${query.rank} ],select_rank` +
                        `|${getTranslationByKey("specializations")} [ ${query.specializations.length} ],` +
                            `select_specializations` +
                        `|${getTranslationByKey("stat")} [ ${
                            query.stat.length === 1 ? 
                                query.stat[0].capitalize() : 'Avg ' + query.stat.capitalize().join("+")
                        } ],select_stat` +
                        `|${getTranslationByKey("go-back")},${query.task}_skill` +
                        `|${getTranslationByKey("done")},${
                            query.task === 'edit' ? 'update_skill' : 'write_newskill'
                        }`;
                    query.last = query.next;
                break;
                case 'select_rank':
                    query.title = `${getTranslationByKey(query.skill.toKebobCase())} ` +
                        `${getTranslationByKey("rank")}`;
                    query.options = '';
                    query.last = query.next;
                break;
                case 'select_specializations':
                    const skill_specializations = {
                        'acrobatics':['balance','flexibility','jumps','tumbling'],
                        'animal training':['any-single-animal'],
                        'architecture':['aquatic','bridges','fortifications','small-buildings','skyscrapers'],
                        'area knowledge':['one-specific-locale'],
                        'artisan':['bowyer-fletcher','blacksmith','carpentry','enchanting-objects','leatherworking','metalworking','plumbing','pottery','tailoring','woodworking'],
                        'biological sciences':['astrobiology','bacteria-viruses','bioengineering','botany','genetics','physiology','zoology'],
                        'boating':['hovercraft','hydrofoils','large-ships','small-boats','submarines'],
                        'burglary':['breaking-and-entering','disarming-physical-traps','hot-wiring','safe-cracking'],
                        'business':['accounting','administration','economics','executive','fraud','government','management','marketing','negotiating','sales'],
                        'civilisation':['one-specific-culture-or-population'],
                        'climbing':['natural-surfaces','poles','ropes','vegetation','walls'],
                        'computers':['artificial-intelligence','cryptography','databases','electronic-warfare','intrusion-security','networks','programming'],
                        'controlled breathing':['calm','cyclic-breathing','holding-breath','slow-heart-rate'],
                        'cultural arts':['gastronomy','history','literature','mythology','nobility','philosophy','rare-object-appraisal','urban-legends'],
                        'demolitions':['artificial-structures','bomb-disposal','natural-structures','safe-cracking','underwater'],
                        'disguise':['costume','impersonation','make-up','prosthetics'],
                        'domestic arts':['childrearing','cleaning','cooking','decorating','gardening','home-budgeting'],
                        'driving':['armored-fighting-vehicle','bicycle','big-rig','bus','car','giant-robot','motorcycle','small-truck','teamster','walker'],
                        'engineering':['communications','computers','consumer-electronics','robotics','security','sensors'],
                        'environmental sciences':['body-language','calming','interpreting-words','intuition','lie-detection','listening'],
                        'electronics':['aerospace','agricultural','biomedical','chemical','civil','computer','electrical','environmental','mechanical','mining'],
                        'empathy':['climatology','ecology','geology','geography','geophysics','hydrology','meteorology','oceanography'],
                        'etiquette':['alien','lower-class','middle-class','upper-class'],
                        'forgery':['artwork','electronic-documents','financial-notes','handwriting','paper-documents','physical-objects'],
                        'gaming':['board-games','card-games','computer-games','gambling','military-simulations','role-playing-games'],
                        'interrogation':['business','drugs','physical','psychological','spiritual'],
                        'intimidation':['business','emotional','political','physical','spiritual','street'],
                        'languages':['any-one-language','braille','code-language','lip-reading','sign-language'],
                        'law':['civil','criminal','customs','family','international','political','real-estate'],
                        'leadership':['business','co-operative','political','spiritual','strategic','transformational'],
                        'listening':['background-noise','discrimination','eavesdropping','spiritual'],
                        'mechanics':['aeronautical','armorer','automotive','gunsmith','locksmith','nanotechnology','traps'],
                        'medical':['chiropractic','dentistry','diagnosis','emergency-response','family-practice','nursing','obstetrics','pathology','pharmacy','surgery','veterinary'],
                        'military sciences':['hardware-recognition','intelligence-analysis','logistics','strategy','tactics','teamwork'],
                        'naturopathy':['acupuncture','aromatherapy','herbalism','homoeopathy','massage-therapy','reflexology'],
                        'navigation':['air','highway','sea','space','undersea','urban','wilderness'],
                        'occult':['astrology','augury','channeling','dream-interpretation','numerology','rituals','spell-craft','spirits','tarot','voodoo','witchcraft'],
                        'occupation':['one-specific-occupation'],
                        'performing arts':['comedy','dance','drama','musical-instrument','public-speaking','singing'],
                        'persuasion':['bluffing','bribery','diplomacy','emotional','fast-talking','hypnosis','logic','mediation','rhetoric','social-networking','storytelling'],
                        'physical sciences':['alchemy','astronomy','biochemistry','chemistry','mathematics','physics'],
                        'piloting':['giant-robot','heavy-airplane','helicopter','jet-fighter','light-airplane','lighter-than-air-craft','spacecraft'],
                        'poisons':['alien','natural','synthetic','technological'],
                        'police sciences':['ballistics','community-policing','criminology','forensics','international'],
                        'power lifting':['bulky-objects','free-weights','humans','moving-objects','small-objects'],
                        'religion':['academic','dogma','congregational','context','enlightenment','guidance','interpretation','scripture'],
                        'riding':['by-species'],
                        'search':['compartments','detail-work','electronics','irregularities'],
                        'seduction':['emotional','mental','physical','political','social','spiritual','verbal'],
                        'sleight of hand':['card-sharking','lock-picking','pick-pocketing','stage-magic'],
                        'social sciences':['archaeology','anthropology','communication','education','politics','psychology','social-work','sociology'],
                        'sports':['one-specific-sport'],
                        'stealth':['camouflage','concealment','silent-movement'],
                        'street sense':['gang-activity','influential-individuals','territorial-divisions'],
                        'survival':['aquatic','arctic','desert','dimensional','forest','jungle','mountain','plains'],
                        'swimming':['aquabatics','competition','deep-sea-diving','free-diving','recreational','scuba','snorkeling'],
                        'urban tracking':['academic','corporate','political','residential','underworld'],
                        'visual arts':['animation','carving','drawing','flower-arranging','painting','photography','sculpting','video'],
                        'wilderness tracking':['aquatic','arctic','desert','forest','jungle','mountain','plains'],
                        'writing':['academic','fiction','journalistic','poetic','religious','technical']
                    };
                    query.title = `${getTranslationByKey("select-specializations")}`;
                    query.options = '';
                    for (let i = 0; i < skill_specializations[`${query.skill}`].length; i++) {
                        const bracket = query.specializations.findIndex(s => s === skill_specializations[`${query.skill}`][i]) !== -1;
                        const specialization = `${getTranslationByKey(skill_specializations[`${query.skill}`][i])}`;
                        query.options += `|${bracket ? '[ ' : ''}${specialization}${bracket ? ' ]' : ''},` +
                            `${skill_specializations[`${query.skill}`][i]}`;
                    }
                    query.options += `|${getTranslationByKey("unique-specialization")},unique_specialization` +
                        `|${getTranslationByKey("done")},skill_menu`;
                    query.last = query.next;
                break;
                case 'select_stat':
                    query.title = `${getTranslationByKey("select-stats")}`;
                    query.options = 
                        `|${getTranslationByKey("body")},body` +
                        `|${getTranslationByKey("mind")},mind` +
                        `|${getTranslationByKey("soul")},soul` +
                        `|Avg ${getTranslationByKey("body")}+${getTranslationByKey("mind")},body~mind` +
                        `|Avg ${getTranslationByKey("body")}+${getTranslationByKey("soul")},body~soul` +
                        `|Avg ${getTranslationByKey("mind")}+${getTranslationByKey("soul")},mind~soul` +
                        `|Avg ${getTranslationByKey("body")}+${getTranslationByKey("mind")}+${getTranslationByKey("soul")},body~mind~soul` +
                        `|${getTranslationByKey("variable")},variable` +
                        `|${getTranslationByKey("go-back")},skills_menu`;
                    query.last = query.next;
                break;
                default: query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.last) {
                    case 'select_task':
                        if (query.selection === 'exit') {
                            query.commit = true;
                            break;
                        } else {
                            query.task = query.selection;
                            query.next = `${query.task}_skill`;
                        }
                    break;
                    case 'add_skill':
                        query.skill = query.selection === 'select_task' ?
                            '' : query.selection;
                        query.stat = skill_stats[query.skill];
                        query.next = query.selection === 'select_task' ?
                            'select_task' : 'skill_menu';
                    break;
                    case 'edit_skill':
                        if (query.selection !== 'select_task') {
                            query.load = int(query.selection);
                            const skill = cache.attrdb.skills[cache.skill_index].individual[query.load];
                            //const skill_settings = ['config','elevel','enhancements','level','limiters','name','row_id','stat'];
                            const skill_settings = ['rank','row_id','skill','specializations','stat'];
                            for (let i = 0; i < skill_settings.length; i++) {
                                query[skill_settings[i]] = skill[skill_settings[i]];
                            }
                            query.skill_translation = query.skill.toKebobCase();
                        }
                        query.next = query.selection !== 'select_task' ?
                            'skill_menu' : query.selection;
                    break;
                    case 'remove_skill':
                        if (query.selection === 'select_task') {
                            query.next = 'select_task';
                        } else {
                            query.remove = query.selection.split('~');
                            query.next = 'remove_confirm';
                        }
                    break;
                    case 'remove_confirm':
                        if (query.selection === 'yes') {
                            cache.attrdb.skills[cache.skill_index].individual.splice(int(query.remove[1]),1);
                            setSkillsPointTotal(cache, set_values);
                            removeRepeatingRow(`repeating_skill_${query.remove[2]}`);
                            query.next = 'write_attrdb'; //=> This is used just to exit the loop, end script.
                        } else {
                            query.next = query.selection;
                        }
                    break;
                    case 'skill_menu':
                        query.selection = query.selection.split("~");
                        if (query.selection.length === 2) {
                            query.index = int(query.selection[1]);
                        }
                        query.selection = query.selection[0];
                        if (query.selection === `${query.task}_skill`) {
                            query.rank = 0;
                            query.specializations = [];
                        }
                        query.next = query.selection === 'update_skill' || query.selection === 'write_newskill' ? 
                            'done' : query.selection;
                        query.last = query.selection === 'update_skill' || query.selection === 'write_newskill' ? 
                            query.selection : query.last;
                    break;
                    case 'select_rank':
                        if (isNaN(query.selection)) {
                            query.next = 'select_rank';
                        } else {
                            query.rank = int(query.selection);
                            query.next = 'skill_menu';
                        }
                    break;
                    case 'select_specializations':
                        if (query.selection !== 'skill_menu') {
                            query.spec_index = query.specializations.findIndex(s => s === query.selection);
                            if (query.spec_index === -1) {
                                query.specializations.push(query.selection);
                            } else {
                                query.specializations.splice(query.spec_index, 1);
                            }
                        }
                        query.next = query.selection !== 'skill_menu' ? 'select_specializations' : 'skill_menu';
                    break;
                    case 'select_stat':
                        query.stat = query.selection === 'skills_menu' ? query.stat : 
                            query.selection === 'varaible' ? [] : query.selection.split("~");
                        query.next = 'skill_menu';
                    break;
                }
            } else {
                if (query.last === 'write_newskill' || query.last === 'update_skill') {
                    //-> write skill object into cache and create repeating section
                    const fields = ['cost','points','rank','skill','specializations','stat'];
                    const row_id = query.last === 'write_newskill' ? generateRowID() : query.row_id.toLowerCase();
                    const attrdb_entry = {};
                    for (let i = 0; i < fields.length; i++) {
                        let value = '';
                        switch (fields[i]) {
                            case 'cost':
                                query.cost = skills_cost[query.skill][cache.rulesdb.rules_optional_genre_status];
                                value = query.cost;
                            break;
                            case 'points':
                                value = query.cost * query.rank;
                            break;
                            case 'rank':
                                value = query.rank;
                            break;
                            case 'skill':
                                value = getTranslationByKey(query.skill.toKebobCase()).capitalize();
                            break;
                            case 'specializations':
                                const specialization_translations = query.specializations.map(s => {
                                    const translation = getTranslationByKey(`${s}`);
                                    return translation === false ? s : translation.capitalize();
                                });
                                value = '';
                                for (let i = 0; i < specialization_translations.length; i++) {
                                    value += `  ${specialization_translations[i]}\n`;
                                }
                            break;
                            case 'stat':
                                value = query.stat.length !== 1 ? 'Avg ' : '';
                                if (query.stat.length === 0) {
                                    value = 'Variable';
                                } else if (query.stat.length !== 1) {
                                    const stat_translations = query.stat.map(s => getTranslationByKey(`${s}`).capitalize());
                                    value += stat_translations.join("+");
                                } else {
                                    value += getTranslationByKey(`${query.stat[0]}`).capitalize();
                                }
                            break;
                        }
                        set_values[`repeating_skill_${row_id}_${fields[i]}`] = value;
                    }
                    attrdb_entry.points = query.cost * query.rank;
                    attrdb_entry.rank = query.rank;
                    attrdb_entry.row_id = row_id;
                    attrdb_entry.skill = query.skill;
                    attrdb_entry.specializations = query.specializations;
                    attrdb_entry.stat = query.stat;
                    if (query.last === 'write_newskill') {
                        attrdb_entry.active = true;
                        attrdb_entry.visibility = 1;
                        cache.attrdb.skills[cache.skill_index].individual.push(attrdb_entry);
                        set_values[`repeating_skill_${row_id}_active`] = 1;
                    } else {
                        const keys = Object.keys(attrdb_entry);
                        for (let i = 0; i < keys.length; i++) {
                            cache.attrdb.skills[cache.skill_index].individual[query.load][keys[i]] = attrdb_entry[keys[i]];
                        }
                    }
                    setSkillsPointTotal(cache, set_values);
                }/* else if (query.last === 'update_skill') {
                    //const fields = ['attribute','configuration','cost','enhancements','level','limiters','name','points','stat'];
                    const fields = ['cost','points','rank','skill','specializations','stat'];
                    const row_id = query.row_id.toLowerCase();
                    const attrdb_entry = {};
                    for (let i = 0; i < fields.length; i++) {
                        let value = '';
                        switch (fields[i]) {
                            case 'skill':
                                value = query.skill.capitalize();
                            break;
                            case 'cost':
                                if (query.attribute === 'skills') {
                                    const index = query.config.findIndex(c => {
                                        const skill_type = 
                                            cache.rulesdb.rules_optional_individual_status ?
                                            'skills' : 'skill group';
                                        return c.name === skill_type;
                                    });
                                    query.cost = skill_group_costs[query.config[index].rank.toLowerCase()];
                                } else {
                                    query.cost = attribute_costs[query.attribute];
                                }
                                value = query.cost;
                            break;
                            case 'enhancements':
                            case 'limiters':
                                const data = query[`${fields[i]}`];
                                for (let i = 0, n = data.length; i < n; i++) {
                                    const config = data[i].config !== undefined ? 
                                        ` (${data[i].config.capitalize()})` : '';
                                    value += `${data[i].name.capitalize()}${config}:` +
                                        ` ${data[i].rank}`;
                                    value += i < n-1 ? '\n' : '';
                                }
                            break;
                            case 'level':
                                value = `${query.level} (${query.elevel})`;
                            break;
                            case 'name':
                                value = query[fields[i]].capitalize();
                            break;
                            case 'points':
                                value = int(
                                    `${query.attribute === 'skills' ?
                                    query.cost : attribute_costs[query.attribute]}`
                                ) * query.level;
                            break;
                            case 'stat':
                                value = getTranslationByKey(`${query.stat}`).capitalize();
                            break;
                        }
                        set_values[`repeating_attribute_${row_id}_${fields[i]}`] = value;
                    }
                    attrdb_entry.config = query.config;
                    attrdb_entry.elevel = query.elevel;
                    attrdb_entry.enhancements = query.enhancements;
                    attrdb_entry.level = query.level;
                    attrdb_entry.limiters = query.limiters;
                    attrdb_entry.name = query.name;
                    attrdb_entry.stat = query.stat;
                    attrdb_entry.points = query.cost * query.level;
                    const keys = Object.keys(attrdb_entry);
                    for (let i = 0, n = keys.length; i < n; i++) {
                        cache.attrdb[query.attribute][query.load[1]][keys[i]] = attrdb_entry[keys[i]];
                    }
                    setGroupCharacterPoints(cache, set_values, cache.attrdb[query.attribute][query.load[1]].group_id);
                }*/
                //}
            }
        }
    }

    async function attributesMenu(cache, set_values) {
        const query = {} ;
        const gear_amount = {
            1:'1-2',
            2:'3-5',
            3:'6-10',
            4:'11-25',
            5:'26-50',
            6:'51-100'
        };
        clog(cache, query, 'attributesMenu()');
        query.next = 'select_type';
        cache.attribute_ids = await getSectionIDsAsync('attributes');
        query.commit = false;
        while (!query.commit) {
            switch (query.next) {
                // Attributes Menu Options
                case 'select_type':
                    query.title = getTranslationByKey(`${
                        cache.groupdb[cache.static_group_visible_id].group_type === 'standard' ?
                        "attribute-defect-group" : "attribute-group"
                    }`);
                    query.options = 
                        `|${getTranslationByKey("attribute")},attribute`;
                    query.options += cache.groupdb[cache.static_group_visible_id].group_type === 'standard' ?
                        `|${getTranslationByKey("defect")},defect` : '';
                    query.options += `|${getTranslationByKey("group")},group`;
                    query.last = query.next;
                    query.next = 'select_task';
                break;
                case 'select_task':
                    query.db = `${query.type === 'attribute' ? 'attr' : 'defect'}db`;
                    query.total = query.type === 'group' ? 1 : 0;
                    if (query.type !== 'group') {
                        const all_attributes_or_defects = query.type === 'attribute' ? all_attributes : all_defects;
                        all_attributes_or_defects.map(
                            ad => {
                                for (let i = 0; i < cache[query.db][`${ad}`].length; i++) {
                                    if (cache[query.db][`${ad}`][i].group_id === cache.static_group_visible_id) {
                                        query.total += 1;
                                    }
                                }
                            }
                        );
                    }                                                           
                    query.title = `${getTranslationByKey(query.type)}`;
                    query.options = `|${getTranslationByKey("add")},add`;
                    query.options += query.total !== 0 ? 
                        `|${getTranslationByKey("edit")},edit` : '';
                    query.options += 
                        (query.type === 'attribute' || query.type === 'defect') && 
                        query.total !== 0 &&
                        cache.groupdb[cache.static_group_visible_id].group_type !== 'power variation' ? 
                            `|${getTranslationByKey("remove")},remove` :
                        query.type === 'attribute' && 
                        query.total !== 0 &&
                        cache.groupdb[cache.static_group_visible_id].group_type === 'power variation' ? 
                            !cache.groupdb[cache.static_group_visible_id].locked ?
                            `|${getTranslationByKey("remove")},remove` : '' :
                        (
                            query.type === 'group' && 
                            cache.groupdb[cache.static_group_visible_id].attribute_ids.length === 0 &&
                            cache.groupdb[cache.static_group_visible_id].defect_ids.length === 0
                        ) ?
                            `|${getTranslationByKey("remove")},remove` :
                        '';
                    query.options += cache.groupdb[cache.static_group_visible_id].group_type === 'power variation' ?
                        (
                            query.type === 'group' && 
                            cache.groupdb[cache.static_group_visible_id].locked &&
                            cache.groupdb[cache.static_group_visible_id].attribute_ids.length !== 0 ||
                            cache.groupdb[cache.static_group_visible_id].defect_ids.length !== 0
                        ) ||//? `|${getTranslationByKey("reset-group")},reset` :
                        (
                            query.type === 'attribute' && 
                            cache.groupdb[cache.static_group_visible_id].locked
                        ) ? `|${query.type === 'group' ? getTranslationByKey("reset-group") : 
                            getTranslationByKey("reset-attribute")},reset` : '' : '';
                    query.options += `|${getTranslationByKey("go-back")},select_type`;
                    query.last = query.next;
                break;
                case 'add_attribute':
                    query.name = '';
                    query.config = [];
                    query.enhancements = [];
                    query.limiters = [];
                    query.level = 0;
                    query.elevel = 0;
                    query.title = 
                        `${getTranslationByKey(query.task)} ` +
                        `${getTranslationByKey(query.type)}`;
                    const normalized_attributes = Object.keys(normalize_attributes);
                    query.attributes = base_attributes.concat(
                        Object.values(normalize_attributes).map((v, i) => {
                            return cache.rulesdb[`rules_${normalized_attributes[i]}_status`] ? v : '';
                        }).filter(n => n)
                    );
                    const skill_index = query.attributes.findIndex(a => { return a === `${
                        cache.rulesdb.rules_optional_individual_status ? 'skill group' : 'skills'
                    }`});
                    query.attributes.splice(skill_index, 1);
                    query.attributes.sort();
                    query.attribute_translations = query.attributes.toKebobCase();
                    query.options = '';
                    for (let i = 0, n = query.attribute_translations.length; i < n; i++) {
                        query.options += `|${getTranslationByKey(query.attribute_translations[i])},${query.attributes[i]}`;
                    }
                    query.last = query.next;
                break;
                case 'add_group':
                    query.title = 
                        `${getTranslationByKey(query.task)} ` +
                        `${getTranslationByKey(query.type)}`;
                    query.options = 
                        `|${getTranslationByKey("standard")},standard` +
                        `|${getTranslationByKey("dynamic-powers")},dynamic powers` +
                        `|${getTranslationByKey("gear")},gear` +
                        `|${getTranslationByKey("power-flux")},power flux` +
                        `|${getTranslationByKey("power-variation")},power variation` + 
                        `|${getTranslationByKey("go-back")},select_type`;
                    query.last = query.next;
                break;
                case 'remove_attribute':
                    query.title = 'Remove';
                    query.options = '';
                    for (let i = 0; i < all_attributes.length; i++) {
                        for (let j = 0; j < cache.attrdb[all_attributes[i]].length; j++) {
                            const attribute = cache.attrdb[all_attributes[i]];
                            if (attribute[j].group_id === cache.static_group_visible_id) {
                                query.options +=
                                `|${attribute[j].name}` +
                                ` [${all_attributes[i].capitalize()}],` +
                                `${all_attributes[i]}~${cache.attrdb[all_attributes[i]][j].row_id}`;
                            }
                        }
                    }
                    query.options += `|${getTranslationByKey("go-back")},select_task`;
                    query.last = query.next;
                break;
                case 'remove_defect':
                    query.title = 'Remove';
                    query.options = '';
                    for (let i = 0; i < all_defects.length; i++) {
                        for (let j = 0; j < cache.defectdb[all_defects[i]].length; j++) {
                            const defect = cache.defectdb[all_defects[i]];
                            if (defect[j].group_id === cache.static_group_visible_id) {
                                query.options +=
                                `|${defect[j].name}` +
                                ` [${all_defects[i].capitalize()}],` +
                                `${all_defects[i]}~${cache.defectdb[all_defects[i]][j].row_id}`;
                            }
                        }
                    }
                    query.options += `|${getTranslationByKey("go-back")},select_task`;
                    query.last = query.next;
                    /*
                    query.title = 'Remove';
                    query.options = _.chain(cache.defectdb).keys().map(a => {
                        const length = cache.defectdb[`${a}`].length;
                        if (length !== 0) {
                            for (let i = 0; i < length; i++) {
                                return `|${cache.defectdb[`${a}`][i].name.capitalize()} [${a.capitalize()}],${a}~${cache.defectdb[`${a}`][i].row_id}`;
                            }
                        }
                    }).flatten().compact().value().sort().join('');
                    query.options += `|${getTranslationByKey("go-back")},select_task`;
                    query.last = query.next;
                    */
                break;
                case 'remove_group':
                    query.title = '';
                    query.selection = 
                        `${cache.groupdb[cache.static_group_visible_id].name}` +
                        `~${cache.static_group_visible_id}`;
                    query.last = query.next;
                break;
                case 'remove_confirm':
                    query.title = `Confirm Remove ${
                        Array.isArray(query.remove) ?
                        query.remove[0].capitalize() :
                        query.remove.capitalize()
                    }`;
                    query.options = `|No,${query.last}|Yes,yes`;
                    query.last = query.next;
                break;
                case 'reset_confirm':
                case 'reset_group':
                    query.title = query.next === 'reset_group' ?
                        `${getTranslationByKey("confirm-reset-of-all-attributes")}` :
                        `${getTranslationByKey("confirm-reset-of-attribute")}`;
                    query.options = `|No,${query.last}|Yes,yes`;
                    query.last = query.next;
                break;
                case 'edit_attribute':
                case 'reset_attribute':
                    query.title = `${query.type === 'edit' ? getTranslationByKey("edit") : getTranslationByKey("reset")}`;
                    query.options = '';
                    for (let i = 0; i < all_attributes.length; i++) {
                        for (let j = 0; j < cache.attrdb[all_attributes[i]].length; j++) {
                            //const attribute = cache.attrdb[all_attributes[i]];
                            if (cache.attrdb[all_attributes[i]][j].group_id === cache.static_group_visible_id) {
                                query.options += `|${cache.attrdb[all_attributes[i]][j].name} [${all_attributes[i].capitalize()}],` +
                                `${all_attributes[i]}~${j}`;
                            }
                        }
                    }
                    query.options += `|${getTranslationByKey("go-back")},select_task`;
                    query.last = query.next;
                break;
                case 'edit_defect':
                    query.title = `${getTranslationByKey("edit")}`;
                    query.options = '';
                    for (let i = 0, n = all_defects.length; i < n; i++) {
                        if (cache.defectdb[all_defects[i]].length !== 0) {
                            for (let j = 0; j < cache.defectdb[all_defects[i]].length; j++) {
                                //const defect = cache.defectdb[all_defects[i]];
                                query.options += `|${cache.defectdb[all_defects[i]][j].name},` +
                                `${all_defects[i]}~${j}`;
                            }
                        }
                    }
                    query.options += `|${getTranslationByKey("go-back")},select_task`;
                    query.last = query.next;
                break;
                case 'edit_group':
                    query.title = '';
                    query.selection = `${cache.groupdb[cache.static_group_visible_id].name}~${cache.static_group_visible_id}`;
                    query.last = query.next;
                break;
                case 'attribute_menu':
                    query.title = `${
                        query.attribute === 'skill group' ?
                        query.name :
                        getTranslationByKey(query.attribute_translation)
                    }`;
                    const customization_types = ['enhancements','limiters'];
                    for (let i = 0; i < 2; i++) {
                        query[`${customization_types[i]}_ranks`] = 
                            query[`${customization_types[i]}`].map(c => {
                                return c.rank || 0;
                            }).reduce((m, n) => { return m + n; }, 0) || 0;
                    }
                    query.elevel = 
                        query.level + query.limiters_ranks - query.enhancements_ranks;
                    query.options = query.attribute === 'skill group' ? '' : 
                        `|${getTranslationByKey("name")}: ${query.name},set_name`;
                    if (
                        query.attribute === 'weapon' ||
                        (
                            query.attribute === 'armor' &&
                            query.limiters.findIndex(e => {
                                return e.name === 'optimized' || e.name === 'emphasized';
                            }) !== -1
                        )
                    ) {
                        const damage_type_index = query.config.findIndex(c => {
                            return c.name === 'damage_type';
                        });
                        query.damage_type = 
                            damage_type_index !== -1 ?
                                query.config[damage_type_index].rank.capitalize() :
                                !query.damage_type ?
                                    '' : query.damage_type.capitalize();
                        query.options +=
                            `|${getTranslationByKey("damage-type")} ` +
                            `[ ${query.damage_type} ],damage_type`;
                    }
                    query.options +=
                        `|${getTranslationByKey("enhancements")} [ -${query.enhancements_ranks} ],enhancement_task`;
                    query.flare_index = query.enhancements.findIndex(f => {
                        return f.name === 'flare';
                    });
                    if (query.flare_index !== -1) {
                        query.options += `|Flare [ -${query.enhancements[query.flare_index].rank}` +
                        ` ],config_flare`;
                    }
                    query.options +=
                        `|${getTranslationByKey("level")} [ ${query.level} (${query.elevel}) ],select_level` +
                        `|${getTranslationByKey("limiters")} [ +${query.limiters_ranks} ],limiter_task`;
                    /* => Why is this code here?  What limiter requires special configuration?
                    if (query.limiters_ranks !== 0) {
                        for (let i = 0, n = query.limiters.length; i < n; i++) {
                            const config = query.limiters[i].config !== undefined ?
                                capitalize(query.limiters[i].config) : '';
                            query.options += 
                                `|${getTranslationByKey(query.limiters[i].name.toKebobCase())}` +
                                ` [ ${config} ]` +
                                `,config_customization~${i}`;
                        }
                    }
                    */
                    if (query.attribute === 'special movement') {
                        const movements = query.config.length;
                        query.options += `|${getTranslationByKey("movements")} [ ${movements} ],config_attribute`;
                    }
                    query.options +=
                        `|${getTranslationByKey("stat")} [ ${getTranslationByKey(query.stat)} ],stat_menu`;
                    if (query.attribute === 'combat technique') {
                        const techniques = query.config.map(c => {
                            return c.rank;
                        }).reduce((m, n) => {
                            return m + n;
                        }, 0);
                        query.options += `|${getTranslationByKey("techniques")} [ ${techniques} ],config_attribute`;
                    }
                    if (query.attribute === 'absorption') {
                        const index = query.config.findIndex(c => {
                            return c.name === 'transform'
                        });
                        query.transform = index === -1 ? 
                            'health points' : query.config[index].rank;
                        query.options += `|${getTranslationByKey("transform-to")} ` +
                            `[ ${query.transform.capitalize()} ],config_attribute`;
                    }
                    if (query.attribute === 'ranged defense') {
                        query.attribute_type = query.attribute_type === undefined ?
                            query.task === 'edit' ? 
                            Object.values(cache.attrdb[query.load[0]][query.load[1]].config.find(t => {
                                return t.name === 'defense type';
                            }))[1].toString() : '' : query.attribute_type;
                        query.options +=
                            `|${getTranslationByKey("defense-type")} ` +
                            `[ ${
                                !query.attribute_type === '' ? '' :
                                query.attribute_type.capitalize()
                            } ],attribute_type`;
                    }
                    if (
                        query.attribute === 'melee attack' ||
                        query.attribute === 'melee defense' ||
                        query.attribute === 'ranged attack' ||
                        query.attribute === 'weapon'
                    ) {
                        const weapon_class_index = query.config.findIndex(c => c.name === 'weapon_class');
                        query.weapon_class = 
                            weapon_class_index !== -1 ?
                                query.config[weapon_class_index].rank.capitalize() :
                                !query.weapon_class ?
                                    '' : query.weapon_class.capitalize();
                        query.options +=
                            `|${getTranslationByKey("weapon-class")} ` +
                            `[ ${query.weapon_class} ],weapon_class`;
                    }
                    query.options +=
                        `|${getTranslationByKey("go-back")},add_attribute` +
                        `|${getTranslationByKey("done")},${
                            query.task === 'edit' ? 'update_attr' : 'write_newattr'
                        }`;
                    query.last = query.next;
                break;
                case 'group_menu':
                    query.title = `${getTranslationByKey(query.attribute_translation)}`;
                    query.options = 
                    `|${getTranslationByKey("name")}: ${query.name},set_name` +
                    `|${getTranslationByKey("source")}: ${getTranslationByKey(query.source)},set_group_source`;
                    query.options += query.attribute !== 'gear' ?
                    `|${getTranslationByKey("origin")}: ${getTranslationByKey(query.origin.toKebobCase())},set_group_origin` : '';
                    if (query.group_type !== 'standard') {
                        query.enhancements_ranks = query.enhancements.map(e => e.rank || 0)
                            .reduce((m, n) => m + n, 0);
                        query.limiters_ranks = query.limiters.map(e => e.rank || 0)
                            .reduce((m, n) => m + n, 0);
                        query.elevel = 
                            query.level + query.limiters_ranks - query.enhancements_ranks;
                        query.options += 
                        `|${getTranslationByKey("enhancements")} [ -${query.enhancements_ranks} ],enhancement_task` +
                        `|${getTranslationByKey("level")} [ ${query.level} (${query.elevel}) ],select_level` +
                        `|${getTranslationByKey("limiters")} [ +${query.limiters_ranks} ],limiter_task`;
                        query.options += cache.groupdb[cache.static_group_visible_id].group_type === 'power variation' ?
                        `|${getTranslationByKey("locked")} [ ${
                            query.locked === true ? getTranslationByKey("yes") : getTranslationByKey("no")
                        } ],lock_group` : '';
                        query.options += 
                        `|${getTranslationByKey("stat")} [ ${getTranslationByKey(query.stat)} ],stat_menu`;   
                    }
                    query.options += 
                    `|${getTranslationByKey("go-back")},select_task` +
                    `|${getTranslationByKey("done")},${query.task === 'edit' ?
                        'update_group' : 'write_newgroup'}`;
                    query.last = query.next;
                break;
                case 'damage_type':
                    query.title =
                        `${getTranslationByKey("choose")} ` +
                        `${getTranslationByKey("damage-type")}`;
                    query.options = '';
                    for (let i = 0; i < damage_types.length; i++) {
                        query.options += 
                            `|${getTranslationByKey(damage_types[i])},` +
                            `${damage_types[i]}`;
                    }
                    query.options += `|${getTranslationByKey("go-back")},attribute_menu`;
                    query.last = query.next;
                break;
                case 'attribute_type':
                    query.title = `${getTranslationByKey("select-defense-type")}`;
                    query.options =
                        `|${getTranslationByKey("personal")},personal` +
                        `|${getTranslationByKey("movement")},movement` +
                        `|${getTranslationByKey("go-back")},${query.last}`;
                    query.last = query.next;
                break;
                case 'attack_type':
                    query.title = `${getTranslationByKey("choose-attack-type")}`;
                    query.options = 
                        `|${getTranslationByKey("any")},any` +
                        `|${getTranslationByKey("enemy")},enemy` +
                        `|${getTranslationByKey("melee")},melee attack` +
                        `|${getTranslationByKey("ranged")},ranged attack`;
                    query.last = query.next;
                break;
                case 'weapon_class':
                    const weapon_classes = 
                        query.attribute === 'melee attack' ||
                        query.attribute === 'melee defense' ? melee_types : 
                        query.attribute === 'ranged attack' ? ranged_types :
                        melee_types.concat(ranged_types).sort();
                    query.title = `${getTranslationByKey("choose-weapon-class")}`;
                    query.options = query[`${query.type}`] === 'inept attack' ? 
                        `|${getTranslationByKey("any")},any` : '';
                    for (let i = 0; i < weapon_classes.length; i++) {
                        query.options += 
                            `|${getTranslationByKey(weapon_classes[i].toKebobCase())},` +
                            `${weapon_classes[i]}`;
                    }
                    query.options += `|${getTranslationByKey("go-back")},${query.type}_menu`;
                    query.last = query.next;
                break;
                case 'set_skill':
                    //skill group
                    const skill_categories = ["background","field","action"];
                    const skill_groups = {
                        "background":[
                            "academic",
                            "artistic",
                            "domestic",
                            "occupation",
                        ],
                        "field":[
                            "business",
                            "social",
                            "street",
                            "technical",
                        ],
                        "action":[
                            "adventuring",
                            "detective",
                            "military",
                            "scientific",
                        ]
                    };
                    query.title = `${getTranslationByKey("skill-group")}`;
                    query.options = '';
                    for (let i = 0; i < skill_categories.length; i++) {
                        for (let j = 0; j < skill_groups[skill_categories[i]].length; j++) {
                            query.options += 
                            `|${getTranslationByKey(skill_groups[skill_categories[i]][j])} ` +
                            `(${getTranslationByKey(skill_categories[i])}),` +
                            `${skill_groups[skill_categories[i]][j]}~${skill_categories[i]}`;
                        }
                    }
                    query.options += `|${getTranslationByKey("go-back")},add_attribute`;
                    query.last = query.next;
                break;
                case 'set_name':
                    query.title = query.type === 'attribute' ?
                        `${getTranslationByKey(query.attribute_translation)} ` :
                        `${getTranslationByKey(query.type)} `;
                    query.title += `${getTranslationByKey("name")}`;
                    query.options = '';
                    query.last = query.next;
                break;
                case 'set_group_source':
                    query.title = 'Add Source';
                    query.options = '';
                    for (let i = 0, n = sources_4e.length; i < n; i++) {
                        query.options += `|${getTranslationByKey(sources_4e[i])},` +
                            `${sources_4e[i]}`;
                    }
                    query.options += `|${getTranslationByKey("go-back")},group_menu`;
                    query.last = query.next;
                break;
                case 'set_group_origin':
                    query.title = 'Origin Type';
                    query.options = 
                        `|${getTranslationByKey("innate")},innate` +
                        //`|${getTranslationByKey("gear")},gear` +
                        `|${getTranslationByKey("item")},item` +
                        //`|${getTranslationByKey("mini-object")},mini object` +
                        `|${getTranslationByKey("shield")},shield` +
                        `|${getTranslationByKey("go-back")},group_menu`;
                    query.last = query.next;
                break;
                case 'lock_group':
                    query.title = 'Lock Group';
                    query.options = 
                        `|${getTranslationByKey("no")},no` +
                        `|${getTranslationByKey("yes")},yes` +
                        `|${getTranslationByKey("go-back")},group_menu`;
                    query.last = query.next;
                break;
                case 'select_level':
                    query.title = `${getTranslationByKey(query.attribute_translation)} ` +
                        `${getTranslationByKey("level")}`;
                    query.options = '';
                    query.last = query.next;
                break;
                case 'enhancement_task':
                case 'limiter_task':
                    query.customization_type = query.selection.slice(0, query.selection.length-5);
                    query.title = `${getTranslationByKey(query.customization_type)}`;
                    query.options = `|${getTranslationByKey("add")},${query.customization_type}_add`;
                    query.options += query.customization_type.length !== 0 ?
                        `|${getTranslationByKey("remove")},${query.customization_type}_remove` : '';
                    query.options += `|${getTranslationByKey("go-back")},attribute_menu`;
                    query.last = query.selection;
                break;
                case 'enhancement_add':
                    query.title = `${getTranslationByKey("add")} ${getTranslationByKey(query.customization_type)}`;
                    let enhancements = ['potent'].concat(
                        standard_enhancements[query.attribute] || 
                        standard_enhancements['default']
                    );
                    enhancements = enhancements.concat(
                        base_custom_enhancements[query.attribute] || 
                        base_custom_enhancements['default']
                    );
                    const normalized_enhancements = {
                        'absorption':['synergistic'],
                        'cognition':['area'],
                        'conversion':['escalate'],
                        'force field':['air-tight'],
                        'power flux':['debuff'],
                        'sixth sense':['range'],
                        'size change':['modified shrinking'],
                        'summon creatures':['area'],
                        'teleport':['blind'],
                        'transfer':['area','targets'],
                        'weapon':['anemic','demoralize','lethargy']
                    }
                    if (
                        Object.keys(normalized_enhancements).indexOf(query.attribute) !== -1 &&
                        cache.rulesdb[`rules_enhancement_${query.attribute.removeWhiteSpace()}_status`]
                    ) {
                        //enhancements.push(normalized_enhancements[`${query.attribute}`]);
                        normalized_enhancements[`${query.attribute}`].forEach(e => {
                            enhancements.push(e);
                        });
                    }
                    query.current_enhancements = query.enhancements.map(e => {
                        return e.name;
                    });
                    if (query.current_enhancements.length !== 0) {
                        const test = nested_enhancements[query.attribute] || [];
                        const exists = query.current_enhancements.map(e => {
                            return test.indexOf(e) !== -1;
                        }).filter(Boolean);
                        if (test.length !== 0 && exists[0]) {
                            for (let i = 0, n = test.length; i < n; i++) {
                                query.current_enhancements.push(test[i]);   
                            }
                            query.current_enhancements = [...new Set(query.current_enhancements.sort())];
                        }
                        for (let i = 0, n = query.current_enhancements.length; i < n; i++) {
                            enhancements.splice(enhancements.indexOf(query.current_enhancements[i]), 1);
                        }
                    }
                    enhancements = enhancements.sort();
                    let enhancement_translations = enhancements.toKebobCase();
                    query.options = '';
                    for (let i = 0, n = enhancements.length; i < n; i++) {
                        query.options += `|${getTranslationByKey(enhancement_translations[i])},` +
                        `${enhancements[i]}`;
                    }
                    query.options += `|${getTranslationByKey("go-back")},${query.type}_menu`;
                    query.last = 'enhancement_add';
                break;
                case 'limiter_add':
                    query.title = `${getTranslationByKey("add")} ${getTranslationByKey("limiter")}`;
                    let limiters = [];
                    limiters = limiters.concat(
                        base_limiters,
                        base_custom_limiters[query.attribute] || 
                        base_custom_limiters['default']
                    );
                    const normalized_limiters = {
                        'absorption':['capped'],
                        'force field':['impacting'],
                        'merge':['proportional damage'],
                        'plant control':['group','species'],
                        'power flux':['skill flux'],
                        'transmute':['material category']
                    }
                    if (
                        Object.keys(normalized_limiters).indexOf(query.attribute) !== -1 &&
                        cache.rulesdb[`rules_limiter_${query.attribute.removeWhiteSpace()}_status`]
                    ) {
                        limiters.push(normalized_limiters[`${query.attribute}`]);
                    }
                    query.current_limiters = query.limiters.map(l => {
                        return l.name;
                    });
                    if (query.current_limiters.length !== 0) {
                        const test = nested_limiters[query.attribute] || [];
                        const exists = query.current_limiters.map(e => {
                            return test.indexOf(e) !== -1;
                        }).filter(Boolean);
                        if (test.length !== 0 && exists[0]) {
                            for (let i = 0, n = test.length; i < n; i++) {
                                query.current_limiters.push(test[i]);   
                            }
                            query.current_limiters = [...new Set(query.current_limiters.sort())];
                        }
                        for (let i = 0, n = query.current_limiters.length; i < n; i++) {
                            limiters.splice(limiters.indexOf(query.current_limiters[i]), 1);
                        }
                    }
                    limiters = limiters.sort();
                    let limiter_translations = limiters.toKebobCase();
                    query.options = '';
                    for (let i = 0, n = limiters.length; i < n; i++) {
                        query.options += `|${getTranslationByKey(limiter_translations[i])},` +
                        `${limiters[i]}`;
                    }
                    query.options += `|${getTranslationByKey("go-back")},${query.type}_menu`;
                    query.last = 'limiter_add';
                break;
                case 'enhancement_remove':
                case 'limiter_remove':
                    query.title = `${getTranslationByKey("remove")} ` +
                        `${getTranslationByKey(query.customization_type)}`;
                    let current_customizations = query[`${query.customization_type}s`].map(e => {
                        return e.name;
                    }).sort();
                    query.options = '';
                    for (let i = 0, n = current_customizations.length; i < n; i++) {
                        query.options +=
                        `|${getTranslationByKey(current_customizations[i].toKebobCase())},` +
                        `${current_customizations[i]}`;
                    }
                    query.options += `|${getTranslationByKey("go-back")},attribute_menu`;
                    query.last = `${query.customization_type}_remove`;
                    query.next = `${query.type}_menu`;
                break;
                case 'enhancement_rank':
                    query.title = `${getTranslationByKey("enhancement")} ${getTranslationByKey("rank")}`;
                    query.options = '';
                    query.last = 'enhancement_rank';
                break;
                case 'limiter_rank':
                    query.title = `${getTranslationByKey("limiter")} ${getTranslationByKey("rank")}`;
                    query.options = '';
                    query.last = 'limiter_rank';
                break;
                case 'config_attribute':
                    query.title = `${getTranslationByKey(query.attribute_translation)}`;
                    switch (query.attribute) {
                        case 'absorption':
                            query.title = `${getTranslationByKey("choose-how-damage-is-transformed")}`;
                            query.options = 
                                `|${getTranslationByKey("health-points")},health points` +
                                `|${getTranslationByKey("energy-points")},energy points` +
                                `|${getTranslationByKey("go-back")},attribute_menu`;
                            query.last = query.next;
                        break;
                        case 'combat technique':
                            const base_combat_techniques = ['blind fighting','blind shooting','brutal','concealment','deflection','extended range','judge opponent','lethal blow','lightning reflexes','portable armory','refelction','weapon encyclopedia'];
                            const normalize_techniques = {
                                'attribute_deathdodge':'death dodge',
                                'attribute_debilitate':'debilitate',
                                'attribute_eknockback':'enhanced knockback',
                                'attribute_flankdefense':'flank defense',
                                'attribute_hardboiled':'hardboiled',
                                'attribute_tournament':'tournament encyclopedia',
                            };
                            const normalized_techniques = Object.keys(normalize_techniques);
                            await crpGet(cache, normalized_techniques);
                            let techniques = [];
                            techniques = base_combat_techniques.concat(
                                Object.values(normalize_techniques).map((v, i) => {
                                    return cache[`rules_${normalized_techniques[i]}_status`] ? v : '';
                                })
                            );
                            if (cache.rulebook !== 'besm') {
                                techniques.push('precise aim','rush attack');
                            }
                            if (cache.rulebook.indexOf('besm') === -1) {
                                techniques.push('death dodge','flanking defense');
                            }
                            query.techniques = techniques.filter(n => n).sort();
                            query.technique_translations = query.techniques.toKebobCase();
                            query.options = '';
                            for (let i = 0, n = query.techniques.length; i < n; i++) {
                                query.bracket = false;
                                for (let j = 0, m = query.config.length; j < m; j++) {
                                    if (query.techniques[i] === query.config[j].name) {
                                        query.bracket = true;
                                        break;
                                    }
                                }
                                query.options += 
                                    `|${query.bracket ? '[' : ''}` +
                                    `${getTranslationByKey(query.technique_translations[i])}` +
                                    `${query.bracket ? ']' : ''},${query.techniques[i]}`;
                            }
                            query.options += `|${getTranslationByKey("go-back")},attribute_menu`;
                            query.last = query.next;
                        break;
                        case 'special movement':
                            await crpGet(cache, 'rules_attribute_speedburst_status');
                            const special_movements = [
                                'balance',
                                'cat-like',
                                'fast',
                                'light-footed',
                                'slithering',
                                'swinging',
                                'untrackable',
                                'wall-bouncing',
                                'wall-crawling',
                                'water-walking',
                                'zen direction'
                            ].concat(
                                cache.rules_attribute_speedburst_status ?
                                    'speedburst' : ''
                            );
                            query.movements = special_movements.filter(n => n).sort();
                            query.movement_translations = query.movements.toKebobCase();
                            query.options = '';
                            for (let i = 0, n = query.movements.length; i < n; i++) {
                                const bracket = query.config.indexOf(query.movements[i]) !== -1;
                                query.options += 
                                    `|${bracket ? '[' : ''}` +
                                    `${getTranslationByKey(query.movement_translations[i])}` +
                                    `${bracket ? ']' : ''},${query.movements[i]}`;
                            }
                            query.options += `|${getTranslationByKey("go-back")},attribute_menu`;
                            query.last = query.next;
                        break;
                    }
                break;
                case 'config_flare':
                    if (query.config_index === undefined) {
                        query.config_index = query.config.push({
                            name: 'flare',
                            rank: 0,
                            senses: [
                                {name:'hearing',rank:0},
                                {name:'sight',rank:0},
                                {name:'smell',rank:0},
                                {name:'taste',rank:0},
                                {name:'touch',rank:0}
                            ]
                        }) - 1;
                    }
                    query.title = `Flare Configuration`;
                    query.options = '';
                    for (let i = 0, n = senses.length; i < n; i++) {
                        query.options += 
                            `|${senses[i].capitalize()} ` +
                            `[${query.config[query.config_index].senses[i].rank || 0}]` +
                            `,${senses[i]}`;
                    }
                    query.options += `|Done,attribute_menu`;
                    query.last = query.next;
                break;
                case 'config_rank':
                    query.title = `${query.customization.capitalize()} ${getTranslationByKey("rank")}`;
                    query.options = '';
                    query.last = query.next;
                break;
                case 'config_customization':
                    query.title = `${getTranslationByKey(query.attribute_translation)}`;
                    switch (query.limiters[query.index].name) {
                        case 'focussed damage':
                            query.options = '';
                            const weapon_types = melee_types.concat(ranged_types).sort();
                            //const weapon_types_translations = weapon_types.toKebobCase()
                            for (let i = 0, n = weapon_types.length; i < n; i++) {
                                query.options += 
                                    //`|${getTranslationByKey(weapon_types_translations[i])}` +
                                    `|${weapon_types[i].capitalize()}` +//`|${capitalize(weapon_types[i])}` +
                                    `,${weapon_types[i]}`;
                            }
                            query.last = query.next;
                        break;
                        case 'targeted damage':
                            query.title = 'Target';
                            query.options = '';
                            query.last = query.next;
                        break;
                    }
                break;
                case 'add_defect':
                    query.config = [];
                    query.name = '';
                    query.rank = 0;
                    query.defects = cache.rulebook !== 'besm' ?
                        ['no healing'].concat(base_defects) : base_defects;
                    if (cache.rulesdb.rules_optional_sanity_status) {
                        query.defects = query.defects.concat(['unsettled']);
                    }
                    if (cache.rulesdb.rules_optional_society_status) {
                        query.defects = query.defects.concat(['demure']);
                    }
                    query.defects.sort();
                    query.title = `${getTranslationByKey("add")} ${getTranslationByKey("defect")}`;
                    query.options = '';
                    for (let i = 0, n = query.defects.length; i < n; i++) {
                        query.options += `|${query.defects[i].capitalize()},` +//`|${capitalize(query.defects[i])},` +
                        `${query.defects[i]}`;
                    }
                    query.options += `|${getTranslationByKey("go-back")},attribute_menu`;
                    query.last = 'add_defect';
                break;
                case 'defect_menu':
                    query.title = `${getTranslationByKey(query.defect.toKebobCase())}`;
                    query.options = 
                    `|${getTranslationByKey("name")}: ${query.name},set_name`;
                    query.options += query.defect === 'inept defense' ? 
                    `|Attack Type [ ${query.attack_type || ''} ],attack_type` : '';
                    query.options += query.defect === 'shortcoming' && query.task === 'add' ?
                    `|${getTranslationByKey("aspect")} [ ${
                        !query.aspect_name ? !query.aspect_stat ? "none" : 
                        query.aspect_stat.capitalize() : query.aspect_name.capitalize()
                    } ],choose_aspect_stat` : '';
                    query.options +=
                    `|${getTranslationByKey("rank")} [ ${query.rank} ],defect_rank`;
                    query.options += query.defect === 'inept attack' ?
                    `|${getTranslationByKey("weapon-class")} [ ${
                        !query.weapon_class ? '' : query.weapon_class.capitalize()
                    } ],weapon_class` : '';
                    query.options +=
                    `|${getTranslationByKey("done")},${query.task === 'edit' ?
                        'update_defect' : 'write_newdefect'}`;
                    query.last = query.next;
                break;
                case 'choose_enemy':
                    query.title = `${getTranslationByKey("choose-enemy")}`;
                    query.options = '';
                    query.last = query.next;
                break;
                case 'choose_aspect_stat':
                    query.title = `${getTranslationByKey("choose-stat")}`;
                    query.options = 
                        `|${getTranslationByKey("body")},body` +
                        `|${getTranslationByKey("mind")},mind` +
                        `|${getTranslationByKey("soul")},soul`;
                    query.last = query.next;
                break;
                case 'choose_aspect_type':
                    query.title = `${getTranslationByKey("choose-aspect-type")}`;
                    query.options = 
                        `|${getTranslationByKey("all")},all` +
                        `|${getTranslationByKey("major")},major` +
                        `|${getTranslationByKey("minor")},minor`;
                    query.last = query.next;
                break;
                case 'choose_aspect_name':
                    query.title = `${getTranslationByKey("choose-aspect")}`;
                    query.options = '';
                    for (let i = 0; i < shortcomings.length; i++) {
                        query.options +=
                            shortcomings[i].stat === query.aspect_stat &&
                            shortcomings[i].type === query.aspect_type ?
                            `|${getTranslationByKey(shortcomings[i].aspect.toKebobCase())},${shortcomings[i].aspect}` : '';
                    }
                    query.last = query.next;
                break;
                case 'defect_rank':
                    query.title = `${getTranslationByKey("defect")} ${getTranslationByKey("rank")}`;
                    query.options = '';
                    query.last = 'defect_rank';
                break;
                case 'stat_menu':
                    query.title = `${getTranslationByKey("attribute")} ${getTranslationByKey("stat")}`;
                    query.options = 
                        `|${getTranslationByKey("body")},body` +
                        `|${getTranslationByKey("mind")},mind` +
                        `|${getTranslationByKey("soul")},soul` +
                        `|${getTranslationByKey("variable")},variable` +
                        `|${getTranslationByKey("none")},none` +
                        `|${getTranslationByKey("go-back")},attribute_menu`;
                    query.last = 'stat_menu';
                break;
                // Break out of while loop when there is no query.next step
                default:
                    query.commit = true;
            }
            if (!query.commit) {
                if (query.title !== '') { await crpQuery(cache, query, query.last); }
                switch (query.last) {
                    case 'select_type':
                        query.type = query.selection;
                    break;
                    case 'select_task':
                        if (
                            query.selection === 'add' &&
                            query.type === 'attribute' &&
                            cache.groupdb[cache.static_group_visible_id].group_type === 'power variation' &&
                            cache.groupdb[cache.static_group_visible_id].locked === true
                        ) {
                            clog(cache, '', 'Cannot add Attributes or Defects to a Power Variation group when it is locked');
                            query.next = 'done';
                            break;
                        }
                        if (query.selection === 'select_type') {
                            query.next = 'select_type';
                        } else {
                            query.task = query.selection;
                            query.next = `${query.task}_${query.type}`;
                        }
                    break;
                    case 'attribute_menu':
                    case 'defect_menu':
                    case 'group_menu':
                        query.selection = query.selection.split("~");
                        if (query.selection.length === 2) {
                            query.index = int(query.selection[1]);
                        }
                        if (query.task === 'edit' && query.selection[0] === 'config_flare') {
                            query.config_index = query.config.findIndex(c => c.name === "flare");
                        }
                        query.selection = query.selection[0];
                        query.next = query.selection;
                    break;
                    case 'choose_enemy':
                        query.config_index = query.config.findIndex(c => c.name === 'attack_type'); 
                        query.config[query.config_index].enemy = query.selection;
                        query.enemy = query.selection;
                        query.next = query.selection === '' ? 'choose_enemy' : 'defect_menu';
                    break;
                    case 'add_attribute':
                        query.attribute = query.selection;
                        query.attribute_translation = query.attribute.toKebobCase();
                        query.stat = all_attributes_stats[query.attribute] || 'none';
                        query.next = query.selection === 'skill group' ? 'set_skill' : 'attribute_menu';
                    break;
                    case 'add_group':
                        query.group_id = cache.groupdb.length;
                        query.removed = false;
                        query.group_type = query.selection;
                        query.attribute = query.selection;
                        query.attribute_translation = query.attribute.toKebobCase();
                        query.origin = query.attribute === 'gear' ? 'gear' : 'innate';
                        query.name = `Group ${query.group_id}`;
                        query.source = 'high-technology';
                        if (query.selection !== 'standard') {
                            query.enhancements = [];
                            query.enhancements_ranks = 0;
                            query.level = 0;
                            query.limiters = [];
                            query.limiters_ranks = 0;
                            query.pointpool = getTranslationByKey(`${
                                query.selection === 'power flux' ? "flux-points" : 
                                query.selection === 'power variation' ? "variable-points" : 
                                query.selection === 'gear' ? "amount-of-gear" : 
                                "dynamic-powers-levels"
                            }`);
                            query.stat = query.attribute === 'gear' ? 'none' : 'variable';
                            query.elevel = 0;
                            if (query.selection === 'power variation') {
                                query.locked = 'no';
                            }
                        }
                        query.next = 'group_menu';
                    break;
                    case 'attribute_type':
                        const index = query.config.findIndex(c => {
                            return c.name === 'defense type';
                        });
                        if (index !== -1) {
                            query.config[index].rank = query.selection;
                        } else {
                            query.config.push({
                                name: 'defense type',
                                rank: query.selection
                            });
                        }
                        query.attribute_type = query.selection;
                        query.next = 'attribute_menu';
                    break;
                    case 'attack_type':
                        query.config_index = query.config.findIndex(c => c.name === 'attack_type'); 
                        if (query.config_index !== -1) {
                            query.config[query.config_index].rank = query.selection;
                        } else {
                            query.config.push({
                                name: 'attack_type',
                                rank: query.selection
                            });
                        }
                        query.attack_type = query.selection;
                        query.next = query.selection === 'enemy' ? 'choose_enemy' : 'defect_menu';
                    break;
                    case 'damage_type':
                    case 'weapon_class':
                        query.config_index = query.config.findIndex(c => c.name === query.last); 
                        if (query.config_index !== -1) {
                            query.config[query.config_index].rank = query.selection;
                        } else {
                            query.config.push({
                                name: query.last,
                                rank: query.selection
                            });
                        }
                        query[`${query.last}`] = query.selection;
                        query.next = `${query.type}_menu`;
                    break;
                    case 'set_skill':
                        if (query.selection !== 'add_attribute') {
                            const skill_and_group = query.selection.split("~");
                            query.name = `${skill_and_group[0].capitalize()}`;
                            if (query.attribute.indexOf('group') !== -1) {
                                query.config.push({
                                    name: 'skill group',
                                    rank: skill_and_group[1].capitalize()
                                });
                            }
                            query.category = skill_and_group[1];
                        }
                        query.next = query.selection !== 'add_attribute' ? `${query.type}_menu` : 'add_attribute';
                    break;
                    case 'set_name':
                        query.name = query.selection;
                        query.next = `${query.type}_menu`;
                    break;
                    case 'set_group_source':
                        query.source = query.selection;
                        query.next = 'group_menu';
                    break;
                    case 'set_group_origin':
                        query.origin = query.selection;
                        query.next = 'group_menu';
                    break;
                    case 'lock_group':
                        query.locked = query.selection === 'yes' ? true : false;
                        query.next = 'group_menu';
                    break;
                    case 'select_level':
                        if (isNaN(query.selection)) {
                            query.next = 'select_level';
                        } else {
                            query.level = int(query.selection);
                            query.next = `${query.type}_menu`;
                        }
                    break;
                    case 'enhancement_task':
                    case 'limiter_task':
                        query.next = query.selection;
                    break;
                    case 'enhancement_add':
                        if (query.selection === `${query.type}_menu`) {
                            query.next = query.selection;
                        } else {
                            query.rank = 
                                enhancement_ranks[`${query.attribute}`][`${query.selection}`] === undefined ? 0 :
                                enhancement_ranks[`${query.attribute}`][`${query.selection}`].rank;
                            query.enhancement_index = query.enhancements.push({
                                name: query.selection,
                                rank: query.rank,
                            }) - 1;
                            query.next = 
                                query.selection === 'flare' ?
                                    'attribute_menu' :
                                query.rank === 0 ? 
                                    'enhancement_rank' : `${query.type}_menu`;
                        }
                    break;
                    case 'limiter_add':
                        if (query.selection === `${query.type}_menu`) {
                            query.next = query.selection;
                        } else {
                            query.rank = 
                                limiter_ranks[`${query.attribute}`] === undefined ? 0 ://[`${query.selection}`] === undefined ? 0 :
                                limiter_ranks[`${query.attribute}`][`${query.selection}`].rank;
                            query.limiters.push({
                                name:query.selection,
                                rank: int(`${query.rank}`),
                            });
                            query.next = 
                                //query.selection === 'optimized' ?
                                //    'damage_type' :
                                query.rank === 0 ? 
                                    'limiter_rank' : `${query.type}_menu`;
                        }
                    break;
                    case 'enhancement_remove':
                    case 'limiter_remove':
                        query.index = query[`${query.customization_type}s`].findIndex(c => {
                            return query.selection === c.name;
                        });
                        query[`${query.customization_type}s`].splice(query.index, 1);
                        if (
                            query.attribute === 'armor' && (
                                query.selection === 'optimized' || 
                                query.selection === 'emphasized')
                        ) {
                            query.config_index = query.config.findIndex(c => {
                                return c.name === 'damage_type';
                            });
                            query.config.splice(query.config_index, 1);
                        } else if (query.attribute === 'weapon') {
                            query.customization_index = 
                                query[`${query.customization_type}s`].findIndex(c => {
                                    return c.name === query.selection;
                                });
                            query.config.splice(query.customization_index, 1);
                        }
                    break;
                    case 'enhancement_rank':
                        if (isNaN(query.selection)) {
                            query.next = 'enhancement_rank';
                        } else {
                            query.rank = int(query.selection);
                            query.next = `${query.type}_menu`;
                            query.enhancements[query.enhancements.length-1].rank = 
                                query.selection;
                        }
                    break;
                    case 'limiter_rank':
                        if (isNaN(query.selection)) {
                            query.next = 'limiter_rank';
                        } else {
                            query.rank = int(query.selection);
                            query.next = `${query.type}_menu`;
                            query.limiters[query.limiters.length-1].rank = 
                                query.selection;
                        }
                    break;
                    case 'remove_attribute':
                    case 'remove_defect':
                        if (query.selection === 'select_task') {
                            query.next = 'select_task';
                        } else {
                            query.remove = query.selection.split('~');
                            query.next = 'remove_confirm';
                        }
                        if (query.remove[0] === 'skills') {
                            let skills_index = -1;
                            for (let i = 0; i < cache.attrdb.skills.length; i++) {
                                if (cache.attrdb.skills[i].row_id === query.remove[1]) {
                                    skills_index = i;
                                    break;
                                }
                            }
                            if(cache.attrdb.skills[skills_index].individual.length !== 0) {
                                clog(cache, '', 'Skill Attributes with existing individual skills cannot be removed');
                                query.next = 'done';
                            }
                        } else if (query.remove[0] === 'shortcoming') {
                            const s_index = cache.defectdb.shortcoming.findIndex(s => s.row_id === query.remove[1]);
                            if (cache.defectdb.shortcoming[s_index].config[1].rank === 'all') {
                                const s_stat = cache.defectdb.shortcoming[s_index].config[0].rank;
                                delete cache.statsdb[s_stat].shortcoming;
                                set_values[`static_character_${s_stat}_remaining`] =
                                    cache.statsdb[s_stat].base +
                                    cache.statsdb[s_stat].temp -
                                    cache.statsdb[s_stat].damage || 0;
                                await setDerivedValues(cache, set_values);
                            }
                        }
                        if (cache.groupdb[cache.static_group_visible_id].locked) {
                            clog(cache, 'Attributes belonging to an active (i.e. locked) Power Variation cannot be removed', `Error Message (${query.last})`);
                            query.next = 'done';
                        }
                    break;
                    case 'remove_group':
                        if (query.selection === 'select_task') {
                            query.next = 'select_task';
                        } else {
                            query.remove = query.selection.split('~').map(s => isNaN(s) ? s : Number(s));
                            if (
                                cache.groupdb[query.remove[1]].attribute_ids.length === 0 &&
                                cache.groupdb[query.remove[1]].defect_ids.length === 0
                            ) {
                                query.next = 'remove_confirm';
                            } else {
                                clog(cache, '', 'Groups with Attributes or Defects cannot be removed');
                                query.next = 'done';
                            }
                        }
                    break;
                    case 'remove_confirm':
                        if (query.selection === 'yes') {
                            if (query.type === 'attribute') {
                                const selecteddb = cache.attrdb[`${query.remove[0]}`];
                                const remove_index = selecteddb.findIndex(a => {
                                    return a.row_id === query.remove[1];
                                });
                                if (query.remove[0] === 'skills') {
                                    //query.skillsui_id = await crpGet(cache, 'static_skills_visible_id');
                                    if(cache.attrdb.skills[remove_index].individual.length !== 0) {
                                        clog(cache, '', 'Skill Attributes with existing individual skills cannot be removed');
                                        query.next = 'done';
                                        break;
                                    }
                                }
                                const selectedgroup = cache.groupdb[selecteddb[remove_index].group_id];
                                if (selectedgroup.group_type === 'standard') {
                                    selectedgroup.group_points -= selecteddb[remove_index].points;
                                    set_values.static_attributes_group_points = selectedgroup.group_points;
                                }
                                const ids = selectedgroup.attribute_ids;
                                for (let i = 0; i < ids.length; i++) {
                                    if (ids[i] === query.remove[1]) {
                                        ids.splice(ids.indexOf(ids[i]), 1);
                                    }
                                }
                                selecteddb.splice(remove_index, 1);
                                if (query.remove[0] === 'skills') {
                                    set_values.static_skills_attribute_name = selecteddb.length !== 0 ?
                                        selecteddb[0].name : '';
                                    set_values.static_skills_points_total = selecteddb.length !== 0 ?
                                        selecteddb[0].elevel * 2 : '';
                                    set_values.static_skills_points_remaining = selecteddb.length !== 0 ?
                                        selecteddb[0].individual.map(s => s.points).reduce((m, n) => m + n, 0) : '';
                                    set_values.static_skills_visible_id = 0;
                                    cache.static_skills_visible_id = 0;
                                    setSkillUiVisibility(cache, set_values);
                                }
                                if (selectedgroup.group_type === 'power flux') {
                                    setPowerFluxPoolPoints(cache, set_values);
                                } else if (selectedgroup.group_type === 'power variation') {
                                    setPowerVariationGroupPoints(cache, set_values);
                                    setPowerVariationPoolPoints(cache, set_values);
                                } else if (selectedgroup.group_type === 'dynamic powers') {
                                    setDynamicPowersPoolLevels(cache, set_values)
                                }
                                removeRepeatingRow(`repeating_attribute_${query.remove[1]}`);
                                query.next = 'write_attrdb'; //=> This is used just to exit the loop, end script.
                            } else if (query.type === 'defect') {
                                const selecteddb = cache.defectdb[`${query.remove[0]}`];
                                const remove_index = selecteddb.findIndex(a => {
                                    return a.row_id === query.remove[1];
                                });
                                const selectedgroup = cache.groupdb[selecteddb[0].group_id];
                                selectedgroup.group_points -= selecteddb[0].points;
                                set_values.static_attributes_group_points = selectedgroup.group_points;
                                const ids = selectedgroup.defect_ids;
                                for (let i = 0; i < ids.length; i++) {
                                    if (ids[i] === query.remove[1]) {
                                        ids.splice(ids.indexOf(ids[i]), 1);
                                    }
                                }
                                selecteddb.splice(remove_index, 1);
                                removeRepeatingRow(`repeating_defect_${query.remove[1]}`);
                                query.next = 'write_defectdb'
                            } else if (query.type === 'group') {
                                if (cache.groupdb[query.remove[1]].attribute_ids.length !== 0) {
                                    clog(cache, '', 'Cannot remove groups with Attributes or Defects, remove the Attributes and Defects first');
                                    query.next = 'select_type';
                                } else {
                                    cache.groupdb[query.remove[1]].removed = true;
                                    query.next = 'removed_group';
                                }
                            }
                        } else {
                            query.next = query.selection;
                        }
                    break;
                    case 'reset_confirm':
                    case 'reset_group':
                        if (query.selection === 'yes') {
                            const customization = ['enhancements','limiters'];
                            if (query.type === 'group') {
                                for (let i = 0; i < all_attributes.length; i++) {
                                    for (let j = 0; j < cache.attrdb[all_attributes[i]].length; j++) {
                                        const attribute = cache.attrdb[all_attributes[i]];
                                        if (attribute[j].group_id === cache.static_group_visible_id) {
                                            const base_index = attribute[j].config.findIndex(c => c.name === 'base points');
                                            if (base_index !== -1) {
                                                for (k = 0; k < customization.length; k++) {
                                                    const customizations = attribute[j][customization[k]];
    
                                                    for (let l = 0; l < attribute[j][customization[k]].length; l++) {
                                                        const temp_cust = attribute[j][customization[k]][l];
                                                        const name = attribute[j][customization[k]][l].name;
                                                        const index = attribute[j].config.findIndex(c => c.name === name);
                                                        const temp_rank = attribute[j].config[index].rank;
                                                        attribute[j][customization[k]][l].rank = attribute[j].config[index].rank;
                                                    }
                                                }
                                                const enhancements = attribute[j].enhancements.map(r => r.rank).reduce((m, n) => { return m + n; }, 0);
                                                const limiters = attribute[j].limiters.map(r => r.rank).reduce((m, n) => { return m + n; }, 0);
                                                attribute[j].level = 
                                                    attribute[j].config[base_index].rank / attribute_costs[all_attributes[i]];
                                                attribute[j].elevel = 
                                                    attribute[j].level + limiters - enhancements;
                                                attribute[j].points = attribute[j].config[base_index].rank;
                                                set_values[`repeating_attribute_${attribute[j].row_id}_level`] =
                                                    `${attribute[j].level} (${attribute[j].elevel})`;
                                                set_values[`repeating_attribute_${attribute[j].row_id}_points`] = attribute[j].points;
                                            }
                                        }
                                    }
                                }
                            } else if (query.type === 'attribute') {
                                const attribute = cache.attrdb[query.load[0]][query.load[1]];
                                const base_index = attribute.config.findIndex(c => c.name === 'base points');
                                if (base_index !== -1) {
                                    for (k = 0; k < customization.length; k++) {
                                        const customizations = attribute[customization[k]];
    
                                        for (let l = 0; l < attribute[customization[k]].length; l++) {
                                            const temp_cust = attribute[customization[k]][l];
                                            const name = attribute[customization[k]][l].name;
                                            const index = attribute.config.findIndex(c => c.name === name);
                                            const temp_rank = attribute.config[index].rank;
                                            attribute[customization[k]][l].rank = attribute.config[index].rank;
                                        }
                                    }
                                    const enhancements = attribute.enhancements.map(r => r.rank).reduce((m, n) => { return m + n; }, 0);
                                    const limiters = attribute.limiters.map(r => r.rank).reduce((m, n) => { return m + n; }, 0);
                                    attribute.level = 
                                        attribute.config[base_index].rank / attribute_costs[query.load[0]];
                                    attribute.elevel = 
                                        attribute.level + limiters - enhancements;
                                    attribute.points = attribute.config[base_index].rank;
                                    set_values[`repeating_attribute_${attribute.row_id}_level`] =
                                        `${attribute.level} (${attribute.elevel})`;
                                    set_values[`repeating_attribute_${attribute.row_id}_points`] = attribute.points;
                                }
                            }
                            setPowerVariationGroupPoints(cache, set_values);
                            setPowerVariationPoolPoints(cache, set_values);
                        }
                        query.next = 'done';
                    break;
                    case 'edit_attribute':
                    case 'reset_attribute':
                        if (query.selection !== 'select_task') {
                            query.load = query.selection.split("~");
                            query.attribute = query.load[0];
                            const attribute = cache.attrdb[`${query.attribute}`];
                            const attribute_settings = ['config','elevel','enhancements','level','limiters','name','row_id','stat'];
                            for (let i = 0, n = attribute_settings.length; i < n; i++) {
                                query[attribute_settings[i]] = attribute[query.load[1]][attribute_settings[i]];
                            }
                            query.attribute_translation = query.load[0].toKebobCase();
                        }
                        query.next = query.selection === 'select_task' ? query.selection : 
                            query.task === 'reset' ? 'reset_confirm' : 'attribute_menu';
                    break;
                    case 'edit_defect':
                        query.load = query.selection.split("~");
                        query.defect = query.load[0];
                        const defect = cache.defectdb[`${query.defect}`];
                        const defect_settings = ['group_id','name','rank','row_id','visibility'];
                        for (let i = 0, n = defect_settings.length; i < n; i++) {
                            query[defect_settings[i]] = defect[query.load[1]][defect_settings[i]];
                        }
                        query.defect_translation = query.load[0].toKebobCase();
                        query.next = 'defect_menu'
                    break;
                    case 'edit_group':
                        query.load = query.selection.split('~').map(s => isNaN(s) ? s : Number(s));
                        const group_settings = ['group_points','group_type','level','name','origin','source','stat'];
                        for (let i = 0, n = group_settings.length; i < n; i++) {
                            query[group_settings[i]] = cache.groupdb[query.load[1]][group_settings[i]] || 0;
                        }
                        const group_type_settings = query.group_type !== 'standard' ?
                            ['enhancements', 'limiters', 'level'] : [];
                        for (let i = 0, n = group_type_settings.length; i < n; i++) {
                            query[group_type_settings[i]] = cache.groupdb[query.load[1]][group_type_settings[i]] || 0;
                        }
                        if (query.group_type === 'power variation') {
                            query.locked = cache.groupdb[query.load[1]].locked;
                        }
                        query.attribute = query.group_type;
                        query.attribute_translation = query.attribute.toKebobCase();
                        query.next = 'group_menu'
                    break;
                    case 'config_attribute':
                        if (query.selection === 'attribute_menu') {
                            query.next = 'attribute_menu';
                        } else if (query.attribute === 'absorption') {
                            const index = query.config.findIndex(c => {
                                return c.name === 'transform';
                            });
                            if (index === -1) {
                                query.config.push({
                                    name: 'transform',
                                    rank: query.selection
                                });
                            } else {
                                query.config[index].rank = query.selection;
                            }
                            query.next = 'attribute_menu';
                        } else {
                            const index = query.config.findIndex(c => {
                                return c.name === query.selection;
                            });
                            if (index === -1) {
                                query.customization = query.selection;
                                if (
                                    query.customization === 'hardboiled' ||
                                    query.customization === 'lightning reflexes'
                                ) {
                                    query.next = 'config_rank';
                                } else {
                                    query.config.push({
                                        name: query.customization,
                                        rank: 1
                                    });
                                }
                            } else {
                                query.config.splice(index, 1);
                            }
                        }
                    break;
                    case 'config_flare':
                        query.customization = 'flare';
                        query.sense = query.selection;
                        query.next = query.selection === 'attribute_menu' ?
                            'attribute_menu' : 'config_rank';
                    break;
                    case 'config_rank':
                        if (query.customization === 'flare') {
                            query.sense_index = query.config[query.config_index].senses.findIndex(f => {
                                return f.name === query.sense;
                            });
                            if (query.sense_index === -1) {
                                query.config[query.config_index].senses.push({
                                    name: query.sense,
                                    rank: int(query.selection)
                                });
                            } else {
                                query.config[query.config_index].senses[query.sense_index].rank = 
                                    int(query.selection);
                            }
                            query.enhancement_index = query.enhancement_index === undefined ?
                                query.enhancements.findIndex(f => {
                                    return f.name === "flare";
                                }) : query.enhancement_index;
                            query.enhancements[query.enhancement_index].rank = 
                                query.config[query.config_index].senses.map(f => {
                                    return f.rank;
                                }).reduce((m, n) => { return m + n; }, 0);
                        } else {
                            query.config.push({
                                name: query.customization,
                                rank: int(query.selection)
                            });
                        }
                        query.next = query.customization === 'flare' ?
                            'config_flare' : 'config_attribute';
                    break;
                    case 'config_customization':
                        query.limiters[query.index].config = query.selection;
                        query.next = 'attribute_menu';
                    break;
                    case 'add_defect':
                        query.defect = query.selection;
                        query.defect_translation = query.defect.toKebobCase();
                        query.next = 'defect_menu';
                    break;
                    case 'choose_aspect_stat':
                        query.aspect_stat = query.selection;
                        query.next = 'choose_aspect_type';
                    break;
                    case 'choose_aspect_type':
                        query.aspect_type = query.selection;
                        query.next = query.aspect_type === 'all' ? 'defect_menu' : 'choose_aspect_name';
                    break;
                    case 'choose_aspect_name':
                        query.aspect_name = query.selection;
                        query.next = 'defect_menu';
                    break;
                    case 'defect_rank':
                        if (isNaN(query.selection)) {
                            query.next = 'defect_rank';
                        } else {
                            query.rank = int(query.selection);
                            query.next = 'defect_menu';
                        }
                    break;
                    case 'stat_menu':
                        if (query.selection !== 'attribute_menu') {
                            query.stat = query.selection;
                        }
                        query.next = `${query.type}_menu`;
                    break;
                }
            } else {
                const skill_group_costs = {
                    'background': 1,
                    'field': 2,
                    'action': 3
                };
                if (query.next === 'write_newattr') {
                    //-> write attribute object into cache and create repeating section
                    const fields = ['attribute','cost','enhancements','level','limiters','name','points','stat','configuration'];
                    const row_id = generateRowID();
                    const attrdb_entry = {};
                    for (let i = 0; i < fields.length; i++) {
                        let value = '';
                        switch (fields[i]) {
                            case 'attribute':
                                value = getTranslationByKey(query.attribute_translation).capitalize();
                            break;
                            case 'stat':
                                value = getTranslationByKey(`${query[fields[i]]}`).capitalize();
                            break;
                            case 'configuration':
                                if (
                                    query.attribute === 'absorption' ||
                                    query.attribute === 'armor' ||
                                    query.attribute === 'conversion' ||
                                    query.attribute === 'force field'
                                ) {
                                    query.config.push({
                                        name: `${
                                            query.attribute === 'absorption' ? 'absorb' :
                                            query.attribute === 'conversion' ? 'convert' :
                                                'armor rating'
                                        }`,
                                        rank: int(`${query.elevel * (
                                            query.attribute === 'absorption' ||
                                            query.attribute === 'armor' ? 
                                                5 :
                                            query.attribute === 'conversion' ||
                                            query.attribute === 'force field' ? 
                                                10 : 0
                                        )}`)
                                    });
                                    if (
                                        query.attribute === 'absorption' &&
                                        query.config.findIndex(c => {
                                            return c.name === 'transform'
                                        }) === -1
                                    ) {
                                        query.config.push({
                                            name: 'transform',
                                            rank: query.transform
                                        });
                                    }
                                } else if (query.attribute === 'ranged defense') {
                                    query.config.push({
                                        name: 'defense type',
                                        rank: query.attribute_type
                                    })
                                } else if (query.attribute === 'skills') {
                                    query.config.push({
                                        name: 'skill points',
                                        rank: query.elevel * 10
                                    });
                                }
                                if (cache.groupdb[cache.static_group_visible_id].group_type === 'power variation') {
                                    query.config.push({
                                        name: 'base points',
                                        rank: query.cost * query.level
                                    });
                                    const customizations = ['enhancements', 'limiters'];
                                    for (let j = 0; j < customizations.length; j++) {
                                        for (let k = 0; k < query[customizations[j]].length; k++) {
                                            query.config.push({
                                                name: query[customizations[j]][k].name,
                                                rank: query[customizations[j]][k].rank
                                            });
                                        }
                                    }
                                }
                                const length = query.config.length;
                                if (length !== 0) {
                                    query.config.sort();
                                    for (let i = 0; i < length; i++) {
                                        if (query.config[i].name === 'flare') {
                                            value += `Flare\n`;
                                            for (let j = 0; j < senses.length; j++) {
                                                value += query.config[i].senses[j].rank ?
                                                    `   ${query.config[i].senses[j].name.capitalize()} (` +
                                                    `${query.config[i].senses[j].rank === 1 ?
                                                        'minor' : 'major'} obstacle)\n` : '';
                                            }
                                        } else {
                                            value += `${query.config[i].name.capitalize()}`;
                                            value += `${
                                                query.config[i].name === 'absorb' ? ' up to ' :
                                                query.config[i].name === 'convert' ? 
                                                    query.elevel !== 1 ? ' 10 to ' : ' ' :
                                                ' ('
                                            }`;
                                            value += `${
                                                isNaN(query.config[i].rank) ?
                                                query.config[i].rank.capitalize() : 
                                                int(query.config[i].rank)
                                            }`;
                                            value += `${
                                                query.config[i].name === 'absorb' ? ' damage' :
                                                query.config[i].name === 'convert' ? ' damage into character points' :
                                                ')'
                                            }`;
                                            value += '\n';
                                        }
                                    }
                                }
                            break;
                            case 'cost':
                                query.cost = query.attribute === 'skill group' ?
                                    skill_group_costs[query.category] :
                                    attribute_costs[query.attribute];
                                value = query.cost;
                            break;
                            case 'enhancements':
                            case 'limiters':
                                const data = query[`${fields[i]}`];
                                for (let i = 0; i < data.length; i++) {
                                    const config = data[i].config !== undefined ?
                                        ` [${data[i].config.capitalize()}]` : '';
                                    value += `${data[i].name.capitalize()}${config}: ${data[i].rank}`;
                                    value += i < data.length - 1 ? '\n' : '';
                                }
                            break;
                            case 'level':
                                value = `${query.level} (${query.elevel})`;
                            break;
                            case 'name':
                                value = `${query[fields[i]].capitalize()}${query.attribute === 'skill group' ?
                                    ' (' + query.attribute.capitalize() + ')' : ''}`;
                            break;
                            case 'points':
                                value = query.cost * query.level;
                            break;
                        }
                        set_values[`repeating_attribute_${row_id}_${fields[i]}`] = value;
                    }
                    attrdb_entry.active = true;
                    attrdb_entry.config = query.config;
                    attrdb_entry.elevel = query.elevel;
                    attrdb_entry.enhancements = query.enhancements;
                    attrdb_entry.group_id = cache.static_group_visible_id;
                    attrdb_entry.level = query.level;
                    attrdb_entry.limiters = query.limiters;
                    attrdb_entry.name = query.name;
                    attrdb_entry.row_id = row_id;
                    attrdb_entry.stat = query.stat;
                    attrdb_entry.points = query.cost * query.level;
                    attrdb_entry.visibility = 1;
                    cache.attrdb[query.attribute].push(attrdb_entry);
                    cache.groupdb[cache.static_group_visible_id].attribute_ids.push(row_id);
                    //cache.groupdb[attrdb_entry.group_id].points += 
                    //    cache.groupdb[attrdb_entry.group_id].group_type === 'power flux' ? 0 : attrdb_entry.points;
                    if (cache.groupdb[attrdb_entry.group_id].group_type === 'power flux') {
                        setPowerFluxPoolPoints(cache, set_values);
                    } else if (cache.groupdb[attrdb_entry.group_id].group_type === 'power variation') {
                        setPowerVariationGroupPoints(cache, set_values);
                        setPowerVariationPoolPoints(cache, set_values);
                        //cache.groupdb[cache.static_group_visible_id].group_points += attrdb_entry.points;
                        //set_values.static_attributes_group_points += attrdb_entry.points;
                    } else if (cache.groupdb[attrdb_entry.group_id].group_type === 'dynamic powers') {
                        setDynamicPowersPoolLevels(cache, set_values);
                    } else {
                        setGroupCharacterPoints(cache, set_values, attrdb_entry.group_id);
                    }
                    if (query.attribute === 'skills') {
                        cache.attrdb.skills[cache.attrdb.skills.length - 1].individual = [];
                        set_values.static_skills_attribute_name = query.name;
                        set_values.static_skills_points_total = query.config[0].rank;
                        set_values.static_skills_points_remaining = query.config[0].rank;
                        set_values.static_skills_visible_id = cache.attrdb.skills.length - 1;
                        setSkillUiVisibility(cache, set_values);
                    }
                    set_values[`repeating_attribute_${row_id}_active`] = 1;
                } else if (
                    query.next === 'write_newdefect' ||
                    query.next === 'update_defect'
                ) {
                    const fields = ['defect','name','points','rank'];
                    if (query.task === 'add') {
                        fields.push('configuration');
                    }
                    const row_id = query.next === 'update_defect' ?
                        query.row_id : generateRowID();
                    for (let i = 0; i < fields.length; i++) {
                        let value = '';
                        switch (fields[i]) {
                            case 'configuration':
                                if (query.defect === 'shortcoming') {
                                    const aspect_fields = ['stat','type'];
                                    if (query.aspect_type !== 'all') {
                                        aspect_fields.push('name');
                                    }
                                    for (let j = 0; j < aspect_fields.length; j++) {
                                        query.config.push({
                                            name: `aspect_${aspect_fields[j]}`,
                                            rank: query[`aspect_${aspect_fields[j]}`]
                                        });
                                    }
                                }
                                if (query.config.length !== 0) {
                                    query.config.sort();
                                    for (let i = 0; i < query.config.length; i++) {
                                        if (query.defect === 'shortcoming') {
                                            value += query.aspect_type !== 'all' ?
                                                `${query.aspect_stat.capitalize()} ` +
                                                `${query.aspect_type.capitalize()} ` +
                                                `Aspect: ${query.aspect_name.capitalize()}\n` :
                                                `${query.aspect_stat.capitalize()} ` +
                                                `Aspect: ${query.aspect_type.capitalize()}\n`;
                                                break;
                                        } else {
                                            value += `${query.config[i].name.capitalize()}`;
                                            value += ' (';
                                            value += `${
                                                isNaN(query.config[i].rank) ?
                                                query.config[i].rank.capitalize() : 
                                                int(query.config[i].rank)
                                            }`;
                                            value += query.defect === 'inept defense' && query.enemy !== undefined ?
                                                `: ${query.enemy}` : '';
                                            value += ')';
                                        }
                                        if (i !== query.config.length - 1) {
                                            value += '\n';
                                        }
                                    }
                                }
                                if (query.next === 'write_newdefect') {
                                    set_values[`repeating_defect_${row_id}_active`] = 1;
                                }
                            break;
                            case 'defect':
                                value = getTranslationByKey(query.defect_translation).capitalize();
                            break;
                            case 'name':
                                value = query[fields[i]].capitalize();
                            break;
                            case 'points':
                                value = (defect_costs[query.defect] * query.rank) * -1;
                            break;
                            case 'rank':
                                value = query.rank;
                            break;
                        }
                        set_values[`repeating_defect_${row_id}_${fields[i]}`] = value;
                    }
                    const defectdb_entry = {};
                    defectdb_entry.active = true;
                    defectdb_entry.config = query.config;
                    defectdb_entry.group_id = query.next === 'update_defect' ?
                        query.group_id : cache.static_group_visible_id;
                    defectdb_entry.rank = query.rank;
                    defectdb_entry.name = query.name;
                    defectdb_entry.row_id = row_id;
                    defectdb_entry.points = (defect_costs[query.defect] * query.rank) * -1;
                    defectdb_entry.visibility = query.next === 'update_defect' ?
                        query.visibility : 1;
                    if (query.defect === 'shortcoming') {
                        if (query.aspect_type === 'all') {
                            cache.statsdb[query.aspect_stat].shortcoming = query.rank;
                            set_values[`static_character_${query.aspect_stat}_remaining`] =
                                cache.statsdb[query.aspect_stat].base +
                                cache.statsdb[query.aspect_stat].temp -
                                cache.statsdb[query.aspect_stat].damage -
                                (cache.statsdb[query.aspect_stat].shortcoming || 0);
                            await setDerivedValues(cache, set_values);
                        }
                    }
                    if (query.next === 'write_newdefect') {
                        const groupdb = cache.groupdb[cache.static_group_visible_id];
                        groupdb.defect_ids.push(row_id);
                        cache.defectdb[query.defect].push(defectdb_entry);
                    } else {
                        for (let i = 1; i < fields.length; i++) {
                            cache.defectdb[query.defect][query.load[1]][`${fields[i]}`] = defectdb_entry[`${fields[i]}`];
                        }
                    }
                    cache.groupdb[defectdb_entry.group_id].points += defectdb_entry.points;
                    setGroupCharacterPoints(cache, set_values, defectdb_entry.group_id);
                } else if (query.next === 'update_attr') {
                    const fields = ['attribute','cost','enhancements','level','limiters','name','points','stat','configuration'];
                    const row_id = query.row_id.toLowerCase();
                    const attrdb_entry = {};
                    for (let i = 0; i < fields.length; i++) {
                        let value = '';
                        switch (fields[i]) {
                            case 'attribute':
                                value = query.attribute.capitalize();
                            break;
                            case 'configuration':
                                if (
                                    query.attribute === 'absorption' ||
                                    query.attribute === 'armor' ||
                                    query.attribute === 'conversion' ||
                                    query.attribute === 'force field'
                                ) {
                                    query.armor_rating = int(`${query.elevel * (
                                        query.attribute === 'absorption' ||
                                        query.attribute === 'armor' ? 
                                            5 :
                                        query.attribute === 'conversion' ||
                                        query.attribute === 'force field' ? 
                                            10 : 0
                                    )}`);
                                    const ar_index = query.config.findIndex(c => {
                                        return c.name === 'armor rating' || c.name === 'absorb' || c.name === 'convert';
                                    });
                                    if (ar_index !== -1) {
                                        query.config[ar_index].rank = query.armor_rating;
                                    } else {
                                        query.config.push({
                                            name: `${
                                                query.attribute === 'absorption' ? 'absorb' :
                                                query.attribute === 'conversion' ? 'convert' :
                                                    'armor rating'
                                            }`,
                                            rank: query.armor_rating
                                        });
                                    }
                                    if (
                                        query.attribute === 'absorption' &&
                                        query.config.findIndex(c => {
                                            return c.name === 'transform'
                                        }) === -1
                                    ) {
                                        query.config.push({
                                            name: 'transform',
                                            rank: query.transform
                                        });
                                    }
                                } else if (query.attribute === 'ranged defense') {
                                    query.config.push({
                                        name: 'defense type',
                                        rank: query.attribute_type
                                    })
                                }
                                if (
                                    cache.groupdb[cache.static_group_visible_id].group_type === 'power variation' &&
                                    cache.groupdb[cache.static_group_visible_id].locked === false
                                ) {
                                    const base_index = query.config.findIndex(c => c.name === 'base points');
                                    if (base_index === -1) {
                                        query.config.push({
                                            name: 'base points',
                                            rank: query.cost * query.level
                                        });
                                    } else {
                                        query.config[base_index].rank = query.cost * query.level;
                                    }
                                }
                                if (query.config.length !== 0) {
                                    query.config.sort();
                                    for (let i = 0; i < query.config.length; i++) {
                                        if (query.config[i].name === 'flare') {
                                            value += `Flare\n`;
                                            for (let j = 0; j < senses.length; j++) {
                                                value += query.config[i].senses[j].rank ?
                                                    `   ${query.config[i].senses[j].name.capitalize()} (` +
                                                    `${query.config[i].senses[j].rank === 1 ?
                                                        'minor' : 'major'} obstacle)\n` : '';
                                            }
                                        } else if (query.config[i].name === 'skill points') {
                                            query.config[i].rank = query.elevel * 10;
                                        } else {
                                            value += `${query.config[i].name.capitalize()}`;
                                            value += `${
                                                query.config[i].name === 'absorb' ? ' up to ' :
                                                query.config[i].name === 'convert' ? 
                                                    query.elevel !== 1 ? ' 10 to ' : ' ' :
                                                ' ('
                                            }`;
                                            value += `${
                                                isNaN(query.config[i].rank) ?
                                                query.config[i].rank.capitalize() : 
                                                int(query.config[i].rank)
                                            }`;
                                            value += `${
                                                query.config[i].name === 'absorb' ? ' damage' :
                                                query.config[i].name === 'convert' ? ' damage into character points' :
                                                ')'
                                            }`;
                                            value += '\n';
                                        }
                                    }
                                }
                                //updateAttributeConfiguration(cache, query);

                            break;
                            case 'cost':
                                if (query.attribute === 'skills') {
                                    
                                } else if (query.attribute === 'skill group') {
                                    const index = query.config.findIndex(c => {
                                        const skill_type = 
                                            cache.rulesdb.rules_optional_individual_status ?
                                            'skills' : 'skill group';
                                        return c.name === skill_type;
                                    });
                                    query.cost = skill_group_costs[query.config[index].rank.toLowerCase()];
                                } else {
                                    query.cost = attribute_costs[query.attribute];
                                }
                                value = query.cost;
                            break;
                            case 'enhancements':
                            case 'limiters':
                                const data = query[`${fields[i]}`];
                                for (let i = 0; i < data.length; i++) {
                                    const config = data[i].config !== undefined ? 
                                        ` (${data[i].config.capitalize()})` : '';
                                    value += `${data[i].name.capitalize()}${config}:` +
                                        ` ${data[i].rank}`;
                                    value += i < data.length - 1 ? '\n' : '';
                                }
                            break;
                            case 'level':
                                value = `${query.level} (${query.elevel})`;
                            break;
                            case 'name':
                                value = `${query[fields[i]].capitalize()}${query.attribute === 'skill group' ?
                                    ' (' + query.attribute.capitalize() + ')' : ''}`;
                            break;
                            case 'points':
                                value = int(
                                    `${query.attribute === 'skills' ?
                                    query.cost : attribute_costs[query.attribute]}`
                                ) * query.level;
                            break;
                            case 'stat':
                                value = getTranslationByKey(`${query.stat}`).capitalize();
                            break;
                        }
                        set_values[`repeating_attribute_${row_id}_${fields[i]}`] = value;
                    }
                    attrdb_entry.config = query.config;
                    attrdb_entry.elevel = query.elevel;
                    attrdb_entry.enhancements = query.enhancements;
                    attrdb_entry.level = query.level;
                    attrdb_entry.limiters = query.limiters;
                    attrdb_entry.name = `${query.name}${query.attribute === 'skill group' ?
                        ' (' + query.attribute.capitalize() + ')' : ''}`;
                    attrdb_entry.stat = query.stat;
                    attrdb_entry.points = query.cost * query.level;
                    const keys = Object.keys(attrdb_entry);
                    for (let i = 0, n = keys.length; i < n; i++) {
                        cache.attrdb[query.attribute][query.load[1]][keys[i]] = attrdb_entry[keys[i]];
                    }
                    //const group_id = cache.attrdb[query.attribute][query.load[1]].group_id;
                    if (cache.groupdb[cache.static_group_visible_id].group_type === 'power flux') {
                        setPowerFluxPoolPoints(cache, set_values);
                    } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'power variation') {
                        setPowerVariationGroupPoints(cache, set_values);
                        setPowerVariationPoolPoints(cache, set_values);
                    } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'dynamic powers') {
                        setDynamicPowersPoolLevels(cache, set_values);
                    } else {
                        setGroupCharacterPoints(cache, set_values, attrdb_entry.group_id);
                    }
                    /*
                    if (cache.groupdb[group_id].group_type === 'power flux') {
                        setPowerFluxPoolPoints(cache, set_values);
                    } else {
                        setGroupCharacterPoints(cache, set_values, group_id);
                    }
                    */
                    //setGroupCharacterPoints(cache, set_values, cache.attrdb[query.attribute][query.load[1]].group_id);
                    if (query.attribute === 'skills') {
                        query.skill_index = int(cache.static_skills_visible_id);
                        setSkillsPointTotal(cache, set_values);
                    }
                } //else if (query.next === 'update_defect') {}
                // Save changes to attrdb when changes to attrdb are made
                /*
                if (
                    query.next === 'write_newattr' ||
                    query.next === 'update_attr' ||
                    query.next === 'write_attrdb'
                ) {
                    set_values.attrdb = JSON.stringify(cache.attrdb);
                // Save changes to defectdb when changes to defectdb are made
                } else if (
                    query.next === 'write_newdefect' ||
                    query.next === 'update_defect' ||
                    query.next === 'write_defectdb'
                ) {
                    set_values.defectdb = JSON.stringify(cache.defectdb);
                }
                */
                // Create and display new group
                if (query.next === 'write_newgroup') {
                    const groupdb_entry = {};
                    groupdb_entry.group_id = query.group_id;
                    groupdb_entry.group_type = query.group_type;
                    groupdb_entry.attribute_ids = [];
                    groupdb_entry.defect_ids = [];
                    groupdb_entry.origin = query.origin;
                    groupdb_entry.name = query.name;
                    groupdb_entry.group_points = 0;
                    groupdb_entry.source = query.source;
                    if (groupdb_entry.group_type !== 'standard') {
                        cache.group_cost = attribute_costs[query.attribute];
                        groupdb_entry.elevel = query.elevel;
                        groupdb_entry.enhancements = query.enhancements;
                        groupdb_entry.level = query.level;
                        groupdb_entry.limiters = query.limiters;
                        groupdb_entry.stat = query.stat;
                        groupdb_entry.points = attribute_costs[query.attribute] * query.level;
                        groupdb_entry.pool_points = query.elevel * int(`${
                            query.attribute === 'power flux' ? 5 : 
                            query.attribute === 'dynamic powers' ? 2 :
                            query.attribute === 'gear' ? 1 : 0
                        }`);
                        if (query.attribute === 'gear') {
                            set_values.static_group_pointpool_points = 
                                gear_amount[query.elevel] || 'unsupported';
                        }
                        groupdb_entry.pool_name = query.pointpool;
                        if (query.attribute === 'power variation') {
                            groupdb_entry.locked = false;
                        }
                        groupdb_entry.group_points = groupdb_entry.points;
                        set_values.static_attributes_group_points = groupdb_entry.points;
                    }
                    cache.groupdb.push(groupdb_entry);
                    cache.static_group_visible_id = query.group_id;
                    showDynamicGroupFields(cache);
                    setAttributeGroupVisibility(cache, set_values);
                    set_values.static_group_visible_id = query.group_id;
                // Update group details when group details are changed
                } else if (query.next === 'update_group') {
                    cache.groupdb[query.load[1]].origin = query.origin;
                    cache.groupdb[query.load[1]].name = query.name;
                    cache.groupdb[query.load[1]].group_points = query.group_points;
                    cache.groupdb[query.load[1]].source = query.source;
                    if (query.type !== 'standard') {
                        cache.groupdb[query.load[1]].elevel = query.elevel;
                        cache.groupdb[query.load[1]].enhancements = query.enhancements;
                        cache.groupdb[query.load[1]].level = query.level;
                        cache.groupdb[query.load[1]].limiters = query.limiters;
                        cache.groupdb[query.load[1]].stat = query.stat;
                        cache.groupdb[query.load[1]].points = attribute_costs[query.attribute] * query.level;
                        if (query.attribute === 'power variation') {
                            cache.groupdb[query.load[1]].locked = query.locked;
                            setPowerVariationGroupPoints(cache, set_values);
                        } else if (query.attribute === 'power flux') {
                            cache.groupdb[query.load[1]].pool_points = query.elevel * 5;
                        } else if (query.attribute === 'dynamic powers') {
                            cache.groupdb[query.load[1]].pool_points = query.elevel * 2;
                        } else if (query.attribute === 'gear') {
                            set_values.static_group_pointpool_points = 
                                gear_amount[query.elevel] || 'unsupported';
                        }
                    }
                    setAttributeGroupVisibility(cache, set_values);
                // Dispay default group when group is removed
                } else if (query.next === 'removed_group') {
                    cache.static_group_visible_id = 
                        cache.static_group_visible_id === query.remove[1] ? 0 : cache.static_group_visible_id;
                    showDynamicGroupFields(cache);
                    setAttributeGroupVisibility(cache, set_values);
                    if (cache.groupdb[cache.static_group_visible_id].group_type === 'power flux') {
                        //setPowerFluxPoolPoints(cache, set_values);
                        cache.statsdb.cp.spent = cache.groupdb.map((g, i) => 
                            i !== cache.static_group_visible_id ? g.group_points : 0
                        ).reduce((m, n) => m + n, 0);
                        //set_values.static_character_points_spent = cache.statsdb.cp.spent;
                        //setCharacterPointsRemaining(cache, set_values);
                    }
                    set_values.static_group_visible_id = cache.static_group_visible_id;
                }
                // Update total character points spent and remaining
                setCharacterPointsRemaining(cache, set_values);
                /*
                const spent = getSpentCharacterPoints(cache);
                set_values.static_character_points_spent = spent;
                set_values.static_character_points_remaining = 
                (
                    cache.statsdb.cp.base + 
                    cache.statsdb.cp.gained + 
                    cache.statsdb.cp.temp
                ) - spent;
                */
            }
        }
    }

    async function journalSavePage(cache, set_values) {
        const temp = {};
        clog(cache, temp, 'journalSavePage()');
        temp.journal_index = int(cache.static_journal_visible_id);
        temp.page_index = int(cache.static_journal_page_number) - 1;
        cache.journaldb[temp.journal_index].entries[temp.page_index] =
            cache.static_journal_page_entry;
        set_values.journaldb = cache.journaldb;
    }

    async function journalSelectMenu(cache, set_values) {
        cache.static_journal_visible_id = int(cache.static_journal_visible_id);
        cache.static_journal_page_number = int(cache.static_journal_page_number);
        const query = {};
        clog(cache, query, 'journalSelectMenu()');
        query.next = 'select_menu';
        query.commit = false;
        query.db_length = cache.journaldb.length;
        query.pages = cache.journaldb[cache.static_journal_visible_id].entries.length;
        while (!query.commit) {
            switch (query.next) {
                case 'select_menu':
                    query.title = getTranslationByKey("choose");
                    query.options = 
                        `|> Next Page,next_page` +
                        `|< Previous Page,previous_page` +
                        `|>> Next Journal,next_journal` +
                        `|<< Previous Journal,previous_journal` +
                        `|Jump to Journal,jump_journal` +
                        `|Jump to Page,jump_page`;
                    query.last = query.next;
                break;
                case 'select_journal':
                    query.title = getTranslationByKey("journal");
                    query.options = '';
                    for (let i = 0; i < query.db_length; i++) {
                        query.options += `|${cache.journaldb[i].name},${cache.journaldb[i].journal_id}`;
                    }
                    query.options += `|${getTranslationByKey("go-back")},select_menu`;
                    query.last = query.next;
                break;
                case 'select_page':
                    query.title = getTranslationByKey("page");
                    query.options = '';
                    for (let i = 0; i < query.pages; i++) {
                        query.options += `|${i + 1},${i}`;
                    }
                    query.options += `|${getTranslationByKey("go-back")},select_menu`;
                    query.last = query.next;
                break;
                default: query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.next) {
                    case 'select_menu':
                        const selection = query.selection.split('_');
                        query.task = selection[0];// next, previous, jump
                        query.type = selection[1];// journal, page
                        query.next = 
                            `${query.task === 'jump' ? 'select' : 'set'}_${query.type}`;
                    break;
                    case 'select_journal':
                    case 'select_page':
                        query.id = query.selection;
                        query.next = `set_${query.type}`;
                    break;
                }
            } else {
                switch (query.next) {
                    case 'set_journal':
                        query.new_journal = 
                            query.task === 'next' ?
                                cache.static_journal_visible_id < query.db_length - 1 ?
                                cache.static_journal_visible_id + 1 : 0 :
                            query.task === 'previous' ?
                                cache.static_journal_visible_id === 0 ?
                                query.db_length - 1 : cache.static_journal_visible_id - 1 :
                            query.id;
                        query.save_journal = cache.journaldb[cache.static_journal_visible_id];
                        query.set_journal = cache.journaldb[query.new_journal];
                        query.save_journal.entries[query.save_journal.last_index] = 
                            cache.static_journal_page_entry;
                        set_values.static_journal_title_name = query.set_journal.name;
                        set_values.static_journal_page_entry = query.set_journal.entries[query.set_journal.last_index];
                        set_values.static_journal_page_number = query.set_journal.last_index + 1;
                        set_values.static_journal_visible_id = query.new_journal;
                    break;
                    case 'set_page':
                        query.new_page = 
                            query.task === 'next' ?
                                cache.static_journal_page_number < query.pages ?
                                cache.static_journal_page_number + 1 : 1 :
                            query.task === 'previous' ?
                                cache.static_journal_page_number === 1 ?
                                query.pages : cache.static_journal_page_number - 1 :
                            query.id + 1;
                        query.new_index = query.new_page - 1;
                        query.save_index = cache.static_journal_page_number - 1;
                        query.journal = cache.journaldb[cache.static_journal_visible_id];
                        query.journal.entries[query.save_index] =
                            cache.static_journal_page_entry;
                            query.journal.last_index = query.new_index;
                        set_values.static_journal_page_entry = query.journal.entries[query.new_index];
                        set_values.static_journal_page_number = query.new_page;
                    break;
                }
            }
        }
    }

    async function groupSelectMenu(cache, set_values) {
        const query = {};
        clog(cache, query, 'groupSelectMenu()');
        query.next = 'select_group';
        query.commit = false;
        if (cache.groupdb[cache.static_group_visible_id].type !== 'standard') {
            cache.groupdb[cache.static_group_visible_id].description =
            cache.static_group_type_description;
        }
        while (!query.commit) {
            switch (query.next) {
                case 'select_group':
                    query.group_names = cache.groupdb.map((g, i) => {
                        const name = g.name || `Group ${i}`;
                        return name;
                    });
                    query.title = getTranslationByKey("switch-to-group");
                    query.options = '';
                    for (let i = 0, n = query.group_names.length; i < n; i++) {
                        if (!cache.groupdb[i].removed) {
                            query.options += `|${query.group_names[i]},${i}`;
                        }
                    }
                    query.options += '|Exit,done';
                    query.last = query.next;
                break;
                // Break out of while loop when there is no query.next step
                default:
                    query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.next) {
                    case 'select_group':
                        cache.static_group_visible_id = int(query.selection);    
                        showDynamicGroupFields(cache);
                        setAttributeGroupVisibility(cache, set_values);
                        query.next = 'done';
                    break;
                }
            }
        }
        set_values.static_group_visible_id = cache.static_group_visible_id;
    }

    async function skillsUiSelectMenu(cache, set_values) {
        const query = {};
        clog(cache, query, 'skillsUiSelectMenu()');
        query.next = 'select_skillsui';
        query.commit = false;
        while (!query.commit) {
            switch (query.next) {
                case 'select_skillsui':
                    query.skillsui_names = cache.attrdb.skills.map((s, i) => s.name || `Group ${i}`);
                    query.title = getTranslationByKey("switch-to-group");
                    query.options = query.skillsui_names.map(((n, i) => `|${n},${i}`)).join('');
                    /*
                    query.options = '';
                    for (let i = 0; i < query.skillsui_names.length; i++) {
                        query.options += `|${query.skillsui_names[i]},${i}`;
                    }
                    */
                    query.options += '|Exit,done';
                    query.last = query.next;
                break;
                // Break out of while loop when there is no query.next step
                default:
                    query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.next) {
                    case 'select_skillsui':
                        cache.static_skills_visible_id = int(query.selection);
                        setSkillUiVisibility(cache, set_values);
                        query.next = 'done';
                    break;
                }
            }
        }
        set_values.static_skills_visible_id = cache.static_skills_visible_id;
    }

    async function groupToggleMenu(cache, set_values) {
        const query = {};
        clog(cache, query, 'groupToggleMenu()');
        query.next = 'select_operation';
        query.commit = false;
        while (!query.commit) {
            switch (query.next) {
                case 'select_operation':
                    query.title = 'Select Operation';
                    query.options = 
                        '|Enable All,enable' +
                        '|Disable All,disable';
                break;
                default:
                    query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.next) {
                    case 'select_operation':
                        query.state = query.selection === 'enable' ? true : false;
                        const index = cache.static_group_visible_id;
                        const length = cache.groupdb[index].attribute_ids.length;
                        const attributes_length = all_attributes.length;
                        cache.attribute = [];
                        for (let i = 0; i < length; i++) {
                            const row_id = cache.groupdb[index].attribute_ids[i];
                            for (let j = 0; j < attributes_length; j++) {
                                const attribute_length = cache.attrdb[all_attributes[j]].length;
                                for (let h = 0; h < attribute_length; h++) {
                                    const check_id = cache.attrdb[all_attributes[j]][h].row_id;
                                    if (check_id === row_id) {
                                        cache.attrdb[all_attributes[j]][h].active = query.state;
                                        cache.attribute.push(all_attributes[j]);
                                        set_values[`repeating_attribute_${row_id.toLowerCase()}_active`] =
                                            query.state === true ? 1 : 0;
                                    }
                                }
                            }
                        }
                        if (cache.attribute.length !== 0) {
                            //setActiveAttribute(cache, set_values);
                        }
                        query.next = 'done';
                    break;
                }
            }
        }
    }

    async function skillsUiToggleMenu(cache, set_values) {
        const query = {};
        clog(cache, query, 'skillsUiToggleMenu()');
        query.next = 'select_operation';
        query.commit = false;
        while (!query.commit) {
            switch (query.next) {
                case 'select_operation':
                    query.title = 'Select Operation';
                    query.options = 
                        '|Enable All,enable' +
                        '|Disable All,disable';
                break;
                default:
                    query.commit = true;
            }
            if (!query.commit) {
                await crpQuery(cache, query, query.last);
                switch (query.next) {
                    case 'select_operation':
                        query.state = query.selection === 'enable' ? true : false;
                        for (let i = 0; i < cache.attrdb.skills[cache.static_skills_visible_id].individual.length; i++) {
                            const row_id = cache.attrdb.skills[cache.static_skills_visible_id].individual[i].row_id;
                            cache.attrdb.skills[cache.static_skills_visible_id].individual[i].active = query.state;
                            set_values[`repeating_skill_${row_id.toLowerCase()}_active`] = query.state === true ? 1 : 0;
                        }
                        query.next = 'done';
                    break;
                }
            }
        }
    }

    async function setStat(cache, query, set_values) {
        // external variables required in query object:
        // .stat = body, mind, or soul,
        // .point_type = base, temp, or damage,
        // .point_method = add, remove, or set,
        // .answer = a positive integer.
        const stats = ['body', 'mind', 'soul'];
        const stats_points = ['base', 'temp', 'damage'];
        //const cp_spent = [0];
        const temp = {};
        clog(cache, temp, 'setStat()');
        Object.assign(temp, query);
        for (let i = 0; i < stats.length; i++) {
            temp[stats_points[i]] = int(cache.statsdb[`${temp.stat}`][stats_points[i]]);
        }
        // Adjust Character Points if stat base changes
        temp.answer = int(temp.answer);
        for (let i = 0; i < stats.length; i++) {
            const stat = temp.stat === stats[i] ?
                temp.point_method === "set" ?
                    temp.answer :
                    temp.point_method === "add" ? 
                        cache.statsdb[stats[i]].base + temp.answer :
                        cache.statsdb[stats[i]].base - temp.answer :
                cache.statsdb[stats[i]].base;
            cache.statsdb[stats[i]].base = stat;
        }
        cache.statsdb.cp.spent = getSpentCharacterPoints(cache);
        if (temp.point_method === 'add') {
            temp[temp.point_type] += temp.answer;
        } else if (temp.point_method === 'remove') {
            temp[temp.point_type] -= temp.answer;
        } else { // temp.point_method === 'set'
            temp[temp.point_type] = temp.answer;
        }
        temp[temp.point_type] = Math.max(temp[temp.point_type], 0);
        set_values[`static_character_${temp.stat}_remaining`] =
            temp.base + temp.temp - temp.damage;
        if (temp.point_type === 'base') {
            temp.cp_spent =
                getSpentCharacterPoints(cache);
            set_values.static_character_points_spent = temp.cp_spent;
            set_values.static_character_points_remaining =
                cache.statsdb.cp.base +
                cache.statsdb.cp.gained +
                cache.statsdb.cp.temp -
                temp.cp_spent;
        }
        for (let i = 0; i < 9; i++) {
            let stat_index = Math.floor(i / 3);
            let point_index = i % 3;
            set_values[`static_character_${stats[stat_index]}_${stats_points[point_index]}`] = (
                stat_index === stats.indexOf(temp.stat) &&
                point_index === stats_points.indexOf(temp.point_type)
            ) ?
                temp[temp.point_type] :
                int(cache.statsdb[stats[stat_index]][stats_points[point_index]]);
        }
        set_values = _.compact(set_values);
        cache.stat = temp.stat;
        cache.point_type = temp.point_type;
    }

    async function setDerivedValues(cache, set_values) {
        const derived_values = [
            'acv',
            'dcv',
            'scv',
            'shockvalue',
        ];
        const derived_values_points = [
            'energy',
            'health',
            'sanity',
            'society',
        ];
        const derived_attributes = {
            'acv':'attack mastery',
            'dcv':'defense mastery',
            'scv':'social mastery',
            'shockvalue':'hardboiled',
            'energy':'energized',
            'health':'tough',
            'sanity':'unassailable',
        };
        const defects = {
            'acv':'inept attack',
            'dcv':'inept defense',
            'scv':'demure',
            'health':'fragile',
            'sanity':'unsettled'
        };
        for (let i = 0; i < derived_values_points.length; i++) {
            derived_values.push(derived_values_points[i]);
        }
        clog(cache, '', `setDerivedValues()`);
        for (let i = 0; i < all_stats.length; i++) {
            cache[all_stats[i]] = 
            cache.statsdb[all_stats[i]].base +
            cache.statsdb[all_stats[i]].temp -
            cache.statsdb[all_stats[i]].damage -
            (cache.statsdb[all_stats[i]].shortcoming || 0);
            /*
            query.defect !== undefined ?
                all_stats[i] === query.apsect_stat && query.defect === 'shortcoming' ?
                query.task === 'add' || cache.defectdb.shortcoming[query.load[1]].active ? 
                query.rank : 0 : 0 : 0;
            */
        }
        cache.energy = (cache.mind + cache.soul) * 5;
        cache.health = (cache.body + cache.soul) * 5;
        cache.sanity = (cache.mind + cache.soul) * int(cache.rulesdb.rules_optional_sanity_status);
        cache.society = Math.round((cache.mind + cache.soul) / 2) * int(cache.rulesdb.rules_optional_society_status);
        cache.shockvalue = (cache.body + cache.soul) * int(cache.rulesdb.rules_optional_shockvalue_status);
        for (let i = 0; i < all_stats.length; i++) {
            cache[all_stats[i]] -= cache.statsdb[all_stats[i]].damage;
        }
        // Calculate base combat values
        cache.acv = Math.round((cache.body + cache.mind + cache.soul) / 3);
        cache.dcv = Math.round((cache.body + cache.mind + cache.soul) / 3);
        cache.scv = Math.round((cache.mind + cache.soul) / 2) * int(cache.rulesdb.rules_optional_society_status);
        cache.attribute = [];
        for (let i = 0; i < derived_values.length; i++) {
            if (cache[derived_values[i]] !== 0) {
                cache.attribute.push(derived_attributes[derived_values[i]]);
            }
        }
        // Apply defects
        // Apply attributes to combat values
        await setActiveAttribute(cache, set_values);
        // Record new values
        for (let i = 0; i < derived_values.length; i++) {
            if (derived_values_points.indexOf(derived_values[i]) !== -1) {
                cache.statsdb[derived_values[i]][cache.point_type] = cache[derived_values[i]];
                set_values[`static_character_${derived_values[i]}_${cache.point_type}`] = cache[derived_values[i]];
                const point_max = 
                    cache.statsdb[derived_values[i]].base +
                    cache.statsdb[derived_values[i]].temp;
                const point_loss = 
                    cache.statsdb[derived_values[i]].damage +
                    cache.statsdb[derived_values[i]].stun || 0;
                setStatusStateDescription(cache, set_values, derived_values[i], point_max, point_loss);
            } else {
                cache.statsdb[derived_values[i]].base = cache[derived_values[i]];
                set_values[`static_character_${derived_values[i]}_base`] = cache[derived_values[i]];
            }
        }
        // Set Movement and Strength Capabilities
        const movements = [
            'walk',
            'jog',
            'run',
            'sprint',
            'swim',
            'sprintswim',
            'jump',
            'leap',
            'runningleap'
        ];
        const movement_ratios = {
            'walk': 1,
            'jog': 1.5,
            'run': 2,
            'sprint': 4,
            'swim': 0.5,
            'sprintswim': 1,
            'jump': 0.125,
            'leap': 0.25,
            'runningleap': 1
        };
        const strengths = [
            'carry',
            'lift'
        ];
        const strength_ratios = {
            'carry': 12.5,
            'lift': 25
        };
        for (let i = 0; i < movements.length; i++) {
            const unit = i > 5 ? 'm' : 'kph';
            const distance = cache.body * movement_ratios[movements[i]];
            const result = distance % 1 === 0 ? distance : Number(distance).toFixed(1);
            set_values[`static_character_capabilities_${movements[i]}`] = 
                `${result} ${unit}`;
        }
        for (let i = 0; i < strengths.length; i++) {
            set_values[`static_character_capabilities_${strengths[i]}`] = 
                `${Math.round(cache.body * strength_ratios[strengths[i]])} kg`;
        }
    }

    function setStatusStateDescription(cache, set_values, point_section, point_max, point_loss) {
        const temp = {};
        clog(cache, temp, `setStatusStateDescription(${point_section})`);
        temp.point_max = point_max;
        temp.point_loss = point_loss;
        temp.status_math = Math.floor((int(point_loss)*10)/int(point_max)) || 0;
        temp.status = temp.status_math > 10 ? 10 : temp.status_math;
        temp.remaining = point_max - point_loss;
        cache.statsdb[point_section].remaining = temp.remaining;
        set_values[`static_character_${point_section}_remaining`] = temp.remaining;
        set_values[`static_character_${point_section}_status`] = 
            getStatusDescription(cache, point_section, temp.status);
        set_values[`static_sheet_${point_section}_state`] = temp.status;
    }

    function setNewAttributeConfiguration(cache, set_values, query) {
        clog(cache, query, 'setNewAttributeConfiguration()');
        if (
            query.attribute === 'absorption' ||
            query.attribute === 'armor' ||
            query.attribute === 'conversion' ||
            query.attribute === 'force field'
        ) {
            if (query.type === 'add') {
                query.config.push({
                    name: `${
                        query.attribute === 'absorption' ? 'absorb' :
                        query.attribute === 'conversion' ? 'convert' :
                            'armor rating'
                    }`,
                    rank: int(`${query.elevel * (
                        query.attribute === 'absorption' ||
                        query.attribute === 'armor' ? 
                            5 :
                        query.attribute === 'conversion' ||
                        query.attribute === 'force field' ? 
                            10 : 0
                    )}`)
                });
            } else if (query.type === 'edit') {
                query.armor_rating = int(`${query.elevel * (
                    query.attribute === 'absorption' ||
                    query.attribute === 'armor' ? 
                        5 :
                    query.attribute === 'conversion' ||
                    query.attribute === 'force field' ? 
                        10 : 0
                )}`);
            }
            
            const ar_index = query.config.findIndex(
                c => c.name === 'armor rating' || c.name === 'absorb' || c.name === 'convert'
            );
            if (ar_index !== -1) {
                query.config[ar_index].rank = query.armor_rating;
            } else {
                query.config.push({
                    name: `${
                        query.attribute === 'absorption' ? 'absorb' :
                        query.attribute === 'conversion' ? 'convert' :
                            'armor rating'
                    }`,
                    rank: query.armor_rating
                });
            }

            if (
                query.attribute === 'absorption' &&
                query.config.findIndex(c => c.name === 'transform') === -1
            ) {
                query.config.push({
                    name: 'transform',
                    rank: query.transform
                });
            }

        } else if (query.attribute === 'ranged defense') {
            query.config.push({
                name: 'defense type',
                rank: query.attribute_type
            })
        } else if (query.attribute === 'skills' && query.type === 'add') {
            query.config.push({
                name: 'skill points',
                rank: query.elevel * 10
            });
        }

        if (
            cache.groupdb[cache.static_group_visible_id].group_type === 'power variation' &&
            cache.groupdb[cache.static_group_visible_id].locked === false
        ) {
            const base_index = query.config.findIndex(c => c.name === 'base points');
            if (base_index === -1) {
                query.config.push({
                    name: 'base points',
                    rank: query.cost * query.level
                });
            } else {
                query.config[base_index].rank = query.cost * query.level;
            }
        }
        if (query.config.length !== 0) {
            query.config.sort();
            for (let i = 0; i < query.config.length; i++) {
                if (query.config[i].name === 'flare') {
                    value += `Flare\n`;
                    for (let j = 0; j < senses.length; j++) {
                        value += query.config[i].senses[j].rank ?
                            `   ${query.config[i].senses[j].name.capitalize()} (` +
                            `${query.config[i].senses[j].rank === 1 ?
                                'minor' : 'major'} obstacle)\n` : '';
                    }
                } else if (query.config[i].name === 'skill points') {
                    query.config[i].rank = query.elevel * 10;
                } else {
                    value += `${query.config[i].name.capitalize()}`;
                    value += `${
                        query.config[i].name === 'absorb' ? ' up to ' :
                        query.config[i].name === 'convert' ? 
                            query.elevel !== 1 ? ' 10 to ' : ' ' :
                        ' ('
                    }`;
                    value += `${
                        isNaN(query.config[i].rank) ?
                        query.config[i].rank.capitalize() : 
                        int(query.config[i].rank)
                    }`;
                    value += `${
                        query.config[i].name === 'absorb' ? ' damage' :
                        query.config[i].name === 'convert' ? ' damage into character points' :
                        ')'
                    }`;
                    value += '\n';
                }
            }
        }
    }

    function updateAttributeConfiguration(cache, query) {
        clog(cache, query, 'setNewAttributeConfiguration()');
        if (
            query.attribute === 'absorption' ||
            query.attribute === 'armor' ||
            query.attribute === 'conversion' ||
            query.attribute === 'force field'
        ) {
            query.armor_rating = int(`${query.elevel * (
                query.attribute === 'absorption' ||
                query.attribute === 'armor' ? 
                    5 :
                query.attribute === 'conversion' ||
                query.attribute === 'force field' ? 
                    10 : 0
            )}`);
            const ar_index = query.config.findIndex(c => {
                return c.name === 'armor rating' || c.name === 'absorb' || c.name === 'convert';
            });
            if (ar_index !== -1) {
                query.config[ar_index].rank = query.armor_rating;
            } else {
                query.config.push({
                    name: `${
                        query.attribute === 'absorption' ? 'absorb' :
                        query.attribute === 'conversion' ? 'convert' :
                            'armor rating'
                    }`,
                    rank: query.armor_rating
                });
            }
            if (
                query.attribute === 'absorption' &&
                query.config.findIndex(c => {
                    return c.name === 'transform'
                }) === -1
            ) {
                query.config.push({
                    name: 'transform',
                    rank: query.transform
                });
            }
        } else if (query.attribute === 'ranged defense') {
            query.config.push({
                name: 'defense type',
                rank: query.attribute_type
            })
        }
        if (
            cache.groupdb[cache.static_group_visible_id].group_type === 'power variation' &&
            cache.groupdb[cache.static_group_visible_id].locked === false
        ) {
            const base_index = query.config.findIndex(c => c.name === 'base points');
            if (base_index === -1) {
                query.config.push({
                    name: 'base points',
                    rank: query.cost * query.level
                });
            } else {
                query.config[base_index].rank = query.cost * query.level;
            }
        }
        if (query.config.length !== 0) {
            query.config.sort();
            for (let i = 0; i < query.config.length; i++) {
                if (query.config[i].name === 'flare') {
                    value += `Flare\n`;
                    for (let j = 0; j < senses.length; j++) {
                        value += query.config[i].senses[j].rank ?
                            `   ${query.config[i].senses[j].name.capitalize()} (` +
                            `${query.config[i].senses[j].rank === 1 ?
                                'minor' : 'major'} obstacle)\n` : '';
                    }
                } else if (query.config[i].name === 'skill points') {
                    query.config[i].rank = query.elevel * 10;
                } else {
                    value += `${query.config[i].name.capitalize()}`;
                    value += `${
                        query.config[i].name === 'absorb' ? ' up to ' :
                        query.config[i].name === 'convert' ? 
                            query.elevel !== 1 ? ' 10 to ' : ' ' :
                        ' ('
                    }`;
                    value += `${
                        isNaN(query.config[i].rank) ?
                        query.config[i].rank.capitalize() : 
                        int(query.config[i].rank)
                    }`;
                    value += `${
                        query.config[i].name === 'absorb' ? ' damage' :
                        query.config[i].name === 'convert' ? ' damage into character points' :
                        ')'
                    }`;
                    value += '\n';
                }
            }
        }
    }

    /* Regsiter event listeners */
    function getEvents() {
        const temp = {};
        clog({},temp,'getEvents()','event');
        // Input names
        temp.change_events = [
            'rules_optional_variable_status',
            'rules_optional_criticalhits_status',
            'rules_optional_criticalfailures_status',
            'rules_optional_dice_status',
            'rules_optional_genre_status',
            'static_sheet_settings_theme',
            'static_rules_base_default',
            'repeating_attribute:active',
            'repeating_defect:active',
            'repeating_skill:active'
        ];
        temp.event_string = `change:${temp.change_events.join(" change:")}`;
        // Button names
        temp.button_events = [
            'static_screen_help_button',
            'static_screen_edit_button',
            'static_screen_accordion_button',
            'static_screen_rolls_button',
            'static_status_update_button',
            'static_status_edit_button',
            'static_status_accordion_button',
            'static_stats_edit_button',
            'static_stats_accordion_button',
            'static_capabilities_accordion_button',
            'static_journal_accordion_button',
            'static_journal_edit_button',
            'static_journal_save_button',
            'static_journal_select_button',
            'static_gmscreen_edit_button',
            'static_rules_accordion_button',
            'react_button_roll_defense',
            'react_button_roll_skill',
            'react_button_roll_stat',
            'rules_optional_shockvalue_button',
            'rules_optional_knockout_button',
            'rules_optional_seriousinjury_button',
            'rules_optional_maneuvers_button',
            'rules_optional_individual_button',
            'rules_optional_mos_button',
            'rules_optional_sanity_button',
            'rules_optional_movementpenalties_button',
            'rules_optional_knockback_button',
            'rules_optional_society_button',
            'rules_optional_shield_button',
            'rules_optional_rangepenalties_button',
            'rules_optional_extradamage_button',
            'rules_optional_enhancedrecovery_button',
            'rules_optional_spreadinitiative_button',
            'rules_attribute_extradefenses_button',
            'rules_attribute_deathdodge_button',
            'rules_attribute_debilitate_button',
            'rules_attribute_eknockback_button',
            'rules_attribute_flankdefense_button',
            'rules_attribute_hardboiled_button',
            'rules_attribute_tournament_button',
            'rules_attribute_expertise_button',
            'rules_attribute_miniobject_button',
            'rules_attribute_speedburst_button',
            'rules_attribute_taunt_button',
            'rules_enhancement_cognition_button',
            'rules_enhancement_sixthsense_button',
            'rules_enhancement_summoncreatures_button',
            'rules_enhancement_transfer_button',
            'rules_enhancement_absorption_button',
            'rules_enhancement_conversion_button',
            'rules_enhancement_forcefield_button',
            'rules_enhancement_powerflux_button',
            'rules_enhancement_sizechange_button',
            'rules_limiter_transmute_button',
            'static_attributes_accordions_button',
            'rules_homebrew_ammotracking_button',
            'rules_homebrew_depletereserve_button',
            'rules_homebrew_disperse_button',
            'rules_homebrew_specificlimiter_button',
            'rules_defect_nohealing_button',
            'rules_enhancement_teleport_button',
            'rules_enhancement_weapon_button',
            'rules_enhancement_absorption_button',
            'rules_enhancement_conversion_button',
            'rules_limiter_teleport_button',
            'rules_limiter_absorption_button',
            'rules_limiter_merge_button',
            'rules_limiter_plantcontrol_button',
            'rules_limiter_powerflux_button',
            'rules_limiter_timed_button',
            'static_attributes_edit_button',
            'static_attributes_groupselect_button',
            'static_attributes_grouptoggle_button',
            'static_skills_uitoggle_button',
            'static_skills_uiselect_button',
            'static_skills_edit_button',
            'static_skills_accordions_button',
            'repeating_attribute:accordion',
            'repeating_defect:accordion',
            'repeating_skill:accordion'
        ];
        temp.event_string += ` clicked:${temp.button_events.join(" clicked:")}`;
        // Repeating sections
        temp.removed_events = [
            'repeating_attr',
            'repeating_defect'
        ];
        temp.event_string += ` remove:${temp.removed_events.join(" remove:")}`;
        return temp.event_string;
    }

    /* Event Listeners */
    on("sheet:opened", async (eventInfo) => {
        const cache = {}; // contains all sheet values, is updated on value changes.
        const set_values = {}; // contains changes to sheet values for setAttr().
        let getAttrsArray = [
            "character_default_value_points",
            "character_name",
            "groupdb",
            "static_group_visible_id",
            "static_sheet_settings_debug",// read each time sheetworker runs
            "static_sheet_settings_gm",// need static_rules_base_default
            "static_sheet_settings_initialized",// read on open only
            "static_sheet_settings_player",// need
            "static_sheet_settings_rules",// read each time sheetworker runs
            "static_sheet_settings_theme",// need
            "static_sheet_settings_type",
            "static_sheet_settings_version",// only needed on open
            "static_rules_base_default"
        ];
        const status_sections = ['energy','health','sanity','society'];
        for (let i = 0, n = status_sections.length; i < n; i++) {
            getAttrsArray = getAttrsArray.concat([
                `static_character_${status_sections[i]}_remaining`,
                `static_character_${status_sections[i]}_base`
            ]);
        }
        setTimer(cache);
        clog(cache, '', 'Sheet Open', 'start');
        clog(cache, cache, 'cache');
        clog(cache, eventInfo, 'eventInfo');
        cache.is_sheetopened = true;
        const values = await getAttrsAsync(getAttrsArray);
        Object.assign(cache, values);
        // Setup sheet theme and rules base logo
        initializeTheme(cache);
        initializeStatusBars(cache, status_sections);
        await setSheetLogo(cache);
        if (
            cache.static_sheet_settings_type !== 'GM' && 
            cache.static_sheet_settings_gm !== ''
        ) {
            cache.rulebook = await crpGet(cache, 'static_rules_base_default') || 'besm';
            cache.rulesdb = await crpGet(cache, 'rulesdb');
            cache.rulesdb = JSON.parse(cache.rulesdb);
            updateSheetRulesSummary(cache, set_values);
            set_values.static_skills_show_state = 
                cache.rulesdb.rules_optional_individual_status === 1 ? 1 : 0;
        }
        if (cache.static_sheet_settings_initialized !== 1) {
            // Create databases
            // Attributes database
            const attrdb = createDatabase(cache, all_attributes);
            set_values.attrdb = JSON.stringify(attrdb);
            // Conditions database
            const conditiondb = createDatabase(cache, all_conditions);
            set_values.conditiondb = JSON.stringify(conditiondb);
            // Defects database
            const defectdb = createDatabase(cache, all_defects);
            set_values.defectdb = JSON.stringify(defectdb);
            // Groups database
            const groupdb = [
                {
                    attribute_ids: [],
                    defect_ids: [],
                    group_id: 0,
                    group_points: 0,
                    group_type: 'standard',
                    name: 'Default Group',
                    origin: 'innate',
                    removed: false,
                    source: 'high-technology',
                },
            ];
            const journaldb = [
                {
                    entries: [],
                    journal_id: 0,
                    last_index: 0,
                    name: 'Default Journal Entry',
                    removed: false,
                },
            ];
            const statsdb = {
                acv: {base:0},
                body:{
                    base:0,
                    damage:0,
                    temp:0
                },
                dcv: {base:0},
                mind:{
                    base:0,
                    damage:0,
                    temp:0
                },
                scv: {base:0},
                shockvalue: {base:0},
                soul:{
                    base:0,
                    damage:0,
                    temp:0
                },
                energy:{
                    base:0,
                    damage:0,
                    temp:0
                },
                health:{
                    base:0,
                    damage:0,
                    stun:0,
                    temp:0
                },
                sanity:{
                    base:0,
                    damage:0,
                    temp:0
                },
                society:{
                    base:0,
                    damage:0,
                    temp:0
                },
                cp:{
                    base:cache.character_default_value_points || 0,
                    gained:0,
                    spent:0,
                    temp:0
                }
            };            
            cache.static_group_visible_id = 0;
            cache.groupdb = groupdb;
            cache.journaldb = journaldb;
            cache.statsdb = statsdb;
            showDynamicGroupFields(cache);
            setAttributeGroupVisibility(cache, set_values);
            set_values.static_character_points_total = cache.character_default_value_points || 0;
            set_values.static_character_points_base = cache.character_default_value_points || 0;
            set_values.static_character_points_remaining = cache.character_default_value_points || 0;
            set_values.static_group_visible_id = 0;
            set_values.groupdb = JSON.stringify(groupdb);
            set_values.static_journal_page_number = 1;
            set_values.static_journal_title_name = 'Default Journal Entry';
            set_values.journaldb = JSON.stringify(journaldb);
            set_values.static_sheet_settings_initialized = 1;
            set_values.statsdb = JSON.stringify(statsdb);
        } else {
            cache.groupdb = JSON.parse(cache.groupdb);
            showDynamicGroupFields(cache);
            cache.static_group_visible_id = cache.static_group_visible_id || 0;
            setAttributeGroupVisibility(cache, set_values);
        }
        set_values.static_character_details_name = cache.character_name;
        setAttrsAsync(set_values,{silent:true});
        clog(cache, set_values, 'setAttrs()');
        clog(cache, '', 'End Script', 'end');
    });

    on(getEvents(), async (event_info) => {
        const set_values = {}; // all value changes to be written
        const cache = {}; // cache of all databases and values required by event
        setTimer(cache);
        clog(cache, cache, 'cache', 'info');
        // Set event values to align with standard formatting
        doEventTasks(cache, event_info);
        clog(cache, event_info, 'doEventTasks()', 'info');
        getSourceAttributes(cache, event_info.sourceAttribute);
        const attrs_keys = getAttrKeys(cache);
        const rules_index = attrs_keys.indexOf('rulesdb');
        if (rules_index !== -1) {
            attrs_keys.splice(rules_index, 1);
        }
        const values = await getAttrsAsync(attrs_keys);
        clog(cache, values, 'getAttrs()', 'info');
        Object.assign(cache, values, event_info);
        for (let i = 0; i < 6; i++) {
            if (cache[dbs[i]] !== undefined) {
                cache[dbs[i]] = JSON.parse(cache[dbs[i]]);
            }
        }
        if (rules_index !== -1) {
            cache.rulesdb = await crpGet(cache, 'rulesdb');
            cache.rulesdb = JSON.parse(cache.rulesdb);
            set_values.static_skills_show_state = 
                cache.rulesdb.rules_optional_individual_status === 1 ? 1 : 0;
        }
        cache.rulebook = !cache.static_sheet_settings_gm ? 'besm' : await crpGet(cache, 'static_rules_base_default');
        updateSheetRulesSummary(cache, set_values);
        cache.silent = true;
        switch (cache.source_type) {
            case 'repeating':
                switch (cache.source_section) {
                    case 'attribute':
                    case 'defect':
                        switch (cache.source_attribute) {
                            case 'accordion':
                                setAccordion(cache, set_values);
                            break;
                            case 'active':
                                const attr_to_value = {
                                    'attack mastery': ['acv'],
                                    'defense mastery': ['dcv'],
                                    'energized': ['energy'],
                                    'extra actions': ['actions'],
                                    'extra defenses': ['defenses'],
                                    'hardboiled': ['shockvalue'],
                                    'massive damage':['dm'],
                                    'social mastery': ['scv','society'],
                                    'tough': ['health'],
                                    'unassailable': ['sanity'],
                                };
                                const db = cache.source_section === 'attribute' ? 'attrdb' : 'defectdb';
                                cache.attribute = 
                                    cache[`${cache.source_path}_${cache.source_section}`].toLowerCase();
                                cache.index =
                                    cache[db][cache.attribute].findIndex(a => {
                                        return a.row_id.toLowerCase() === cache.source_id;
                                    });
                                cache.active = cache.newValue === 1 ? true : false;
                                cache[db][cache.attribute][cache.index].active = 
                                    cache.active;
                                await setActiveAttribute(cache, set_values);
                                if (Object.keys(attr_to_value).indexOf(cache.attribute[0]) !== -1) {
                                    set_values[`static_character_${attr_to_value[cache.attribute[0]][0]}_base`] = 
                                        cache[attr_to_value[cache.attribute[0]][0]];
                                    if (cache.attribute[0] === 'social mastery') {
                                        set_values[`static_character_${attr_to_value[cache.attribute[0]][1]}_base`] = 
                                        cache[attr_to_value[cache.attribute[0]][1]];
                                    }
                                }
                                if (cache.groupdb[cache.static_group_visible_id].group_type === 'power flux') {
                                    setPowerFluxPoolPoints(cache, set_values);
                                } else if (cache.groupdb[cache.static_group_visible_id].group_type === 'dynamic powers') {
                                    setDynamicPowersPoolLevels(cache, set_values);
                                }
                            break;
                        }
                    break;
                    case 'skill':
                        switch (cache.source_attribute) {
                            case 'accordion':
                                setAccordion(cache, set_values);
                            break;
                        }
                    break;
                }
            break;
            case 'react':
                await actionRoll(cache, set_values);
            break;
            case 'rules':
                await toggleRuleSetting(cache, set_values);
            break;
            case 'static':
                switch (cache.source_section) {
                    case 'attributes':
                        switch (cache.source_attribute) {
                            case 'button':
                                switch (cache.source_id) {
                                    case 'accordion':
                                        setAccordion(cache, set_values);
                                    break;
                                    case 'accordions':
                                        cache.attribute_ids = await getSectionIDsAsync('attribute');
                                        cache.defect_ids = await getSectionIDsAsync('defect');
                                        setAttributeAccordions(cache, set_values);
                                    break;
                                    case 'edit':
                                        await attributesMenu(cache, set_values);
                                    break;
                                    case 'groupselect':
                                        await groupSelectMenu(cache, set_values);
                                    break;
                                    case 'grouptoggle':
                                        await groupToggleMenu(cache, set_values);
                                    break;
                                }
                            break;
                        }
                    break;
                    case 'screen':
                    case 'status':
                    case 'stats':
                    case 'gmscreen':
                    case 'capabilities':
                        switch (cache.source_attribute) {
                            case 'button':
                                switch (cache.source_id) {
                                    case 'accordion':
                                        setAccordion(cache, set_values);
                                    break;
                                    case 'edit':
                                    case 'update':
                                        await openMenu(cache, set_values);
                                    break;
                                    case 'help':
                                        await displayHelp(cache);
                                    break;
                                    case 'rolls':
                                        await actionRoll(cache, set_values);
                                    break;
                                }
                            break;
                        }
                    break;
                    case 'sheet':
                        switch (cache.source_id) {
                            case 'settings':
                                switch (cache.source_attribute) {
                                    case 'theme':
                                        setTheme(cache);
                                        cache.silent = false;
                                    break;
                                }
                            break;
                        }
                    break;
                    case 'skills':
                        switch (cache.source_id) {
                            case 'accordions':
                                cache.skill_ids = await getSectionIDsAsync('skill');
                                setSkillAccordions(cache, set_values);
                            break;
                            case 'edit':
                                await skillsMenu(cache, set_values);
                            break;
                            case 'uiselect':
                                await skillsUiSelectMenu(cache, set_values);
                            break;
                            case 'uitoggle':
                                await skillsUiToggleMenu(cache, set_values);
                            break;
                        }
                    break;
                    case 'journal':
                        switch (cache.source_id) {
                            case 'accordion':
                                setAccordion(cache, set_values);
                            break;
                            case 'edit':
                                await journalMenu(cache, set_values);
                            break;
                            case 'save':
                                await journalSavePage(cache, set_values);
                            break;
                            case 'select':
                                await journalSelectMenu(cache, set_values);
                            break;
                        }
                    break;
                    case 'rules':
                        switch (cache.source_id) {
                            case 'accordion':
                                setAccordion(cache, set_values);
                            break;
                            case 'base':
                                await changeSheetLogo(cache);
                                await setBaseRules(cache, set_values);
                            break;
                            default:
                                await toggleRuleSetting(cache, set_values);
                        }
                    break;
                }
            break;
        }
        for (let i = 0; i < dbs.length; i++) {
            if (cache[dbs[i]] !== undefined) {
                set_values[dbs[i]] = JSON.stringify(cache[dbs[i]]);
            }
        }
        setAttrsAsync(set_values,cache.silent);
        clog(cache, set_values, 'set_values()', 'info');
        clog(cache, '', 'Sheet Worker End', 'end');
    });
</script>