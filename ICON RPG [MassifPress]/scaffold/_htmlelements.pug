-
  const varObjects = {
    repeatingSectionDetails:[],
    actionAttributes:[],
    cascades:{
      attr_character_name:{
        name:'character_name',
        type:'text',
        defaultValue:'',
        affects:[],
        triggeredFuncs:['setActionCalls'],
        listenerFunc:'accessSheet',
        listener:'change:character_name'}
      }
  };
- let selectName = null;
- let selectTitle = null;
- let repeatingPrefix = '';
//- Element shortcut mixins

//- @pugdoc
  name: input
  description: A generic mixin to create an input. The mixin will replace spaces in the attribute name with underscores and will add a title property if one isn't supplied that will inform the user what the attribute call for the attribute is.
  arguments:
    - {object} inputObj - An object describing the properties of the input just like they would be in a PUG or HTML element declaration, but in JS Object syntax. May also include a trigger property
  attributes:
  example: |
    include _htmlelements.pug
    +input({name:'my attribute',type:'text',class:'some-class',trigger:{affects:['other_attribute']}})
mixin input(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - obj.name = replaceSpaces(obj.name);
  - obj.title = obj.title || attrTitle(obj.name);
  - obj.name = `attr_${obj.name}`;
  - const elementObj = makeElementObj(obj);
  - addFieldToFieldsetObj(obj);
  - storeTrigger(obj);
  input&attributes(elementObj)&attributes(attributes)
//-End Mixin
//- @pugdoc
  name: text
  description: An alias for {@link input} that specifies the input type as text. See {@link input} for arguments.
  arguments:
  attributes:
  example: |
    include _htmlelements.pug
    +text({name:'my attribute',class:'some-class',trigger:{affects:['other_attribute']}})
mixin text(obj)
  - obj.type = 'text';
  +input(obj)
//-End Mixin
//- @pugdoc
  name: checkbox
  description: An alias for {@link input} that specifies the input type as checkbox. See {@link input} for arguments.
  arguments:
  attributes:
  example: |
    include _htmlelements.pug
mixin checkbox(obj)
  - obj.type = 'checkbox';
  +input(obj)&attributes(attributes)
//-End Mixin
//- @pugdoc
  name: collapse
  description: Alias for {@link checkbox} that creates a checkbox for us in collapse/expanding a section. Sets the checkbox to unchecked with a checked value of `1` and a class of `collapse`. Additional classes/ids can be applied by applying them inline to the mixin call.
  arguments:
    - {string} [name=collapse] - The name to use for the collapse element. Defaults to `collapse`
  attributes:
  example: |
    include _htmlelements.pug
    +collapse()
mixin collapse(name='collapse')
  +checkbox({name,value:1,class:'collapse'})&attributes(attributes)
//- @pugdoc
  name: radio
  description: Alias for {@link input} that specifies `radio` as the input type. See {@link input} for arguments.
  arguments:
  attributes:
  example: |
    include _htmlelements.pug
mixin radio(obj)
  - obj.type = 'radio';
  +input(obj)
//-End Mixin
//- @pugdoc
  name: number
  description: Alias for {@link input} that makes a number input. See {@link input} for arguments.
  arguments:
  attributes:
  example: |
    include _htmlelements.pug
    +number({name:'my number',class:'some-class',trigger:{affects:['other_attribute']}})
mixin number(obj)
  - obj.type = 'number';
  +input(obj)
//-End Mixin
//- @pugdoc
  name: range
  description: Alias for {@link input} that makes a range input. See {@link input} for arguments.
  arguments:
  attributes:
  example: |
    include _htmlelements.pug
    +range({name:'my range',class:'some-class'})
mixin range(obj)
  - obj.type = 'range';
  +input(obj)
//-End Mixin
//- @pugdoc
  name: hidden
  description: Alias for {@link input} that makes a hidden input. See {@link input} for arguments.
  arguments:
  attributes:
  example: |
    include _htmlelements.pug
    +hidden({name:'my hidden attribute',class:'some-class',trigger:{triggeredFuncs:['someFunction']}})
mixin hidden(obj)
  - obj.type = 'hidden';
  +input(obj)
//-End Mixin
mixin radioGroup(objArray)
  each obj in objArray
    - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
    - obj.type='radio';
    +input(obj)
//-End Mixin
//- @pugdoc
  name: fillLeft
  description: A mixin that creates an html construction ready to be styled for use as a [fill-to-left section](https://wiki.roll20.net/CSS_Wizardry#Fill_Radio_Buttons_to_the_Left).
  arguments:
    - {object} radioObj - The object containing the details of the radio input to create. Similar to the {@link radio}, but the value property passed is used as the default checked value.
    - {object} [divObj] - Optional object containing any details of the div to be applied such as class, id, or other properties. Class and ID can also be supplied by attaching them to the mixin invocation just like with a regular div.
    - {array} valueArray - Array containing the values to be used for the fill to left construction. These should be in the order that they should be displayed left to right.
    - {boolean} [noClear] - Optional argument that tells the mixin whether or not to apply the `fill-left__radio--clearer` class to the first radio button value. If falsy (or not passed), the class is applied. If truthy, the class is not applied.
  example: |
    include _htmlelements.pug
    +fillLeft({
      radioObj:{name:'my radio'},
      divObj:{class:'some-custom-class'},
      valueArray:[1,2,3,4,5]
    })
mixin fillLeft({radioObj,divObj,valueArray,noClear})
  - divObj = divObj || {};
  .fill-left&attributes(divObj)&attributes(attributes)
    each value,index in valueArray
      - const usedObj = {...radioObj,value};
      -
        usedObj.class = usedObj.class ? 
          `${usedObj.class} fill-left__radio` :
          `fill-left__radio`;
      if value === radioObj.value
        - usedObj.checked = '';
      if !noClear && index === 0
        - usedObj.class = `${usedObj.class} radio-clearer`;
      
      +radio(usedObj)
//- End Mixin
//- @pugdoc
  name: textarea
  description: A mixin to create K-scaffold compatible textareas. 
  arguments:
    - {object} textObj - See {@link input} for information on valid properties of the textObj.
  attributes:
  example: |
    include _htmlelements.pug
    +textarea({name:'my textarea',class:'some-class',trigger:{affects:['an_attribute']}})
mixin textarea(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - obj.name = replaceSpaces(obj.name);
  - obj.title = obj.title || attrTitle(obj.name);
  - obj.name = `attr_${obj.name}`;
  - addFieldToFieldsetObj(obj);
  - storeTrigger(obj);
  - const elementObj = makeElementObj(obj);
  textarea&attributes(elementObj)
//-End Mixin
//- @pugdoc
  name: option
  description: A mixin to create an option for use in a select. This mixin must be used within the block of a {@link select} mixin. The K-scaffold will associate the option's values and trigger with the select parent. See the {@link select} for example usage.
  arguments:
    - {object} optionObj - The object describing the option element
    - {block} block - The contents of the option element
  attributes:
mixin option(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - const triggerObj = {...obj,name:selectName,title:selectTitle,type:'select'};
  - const elementObj = makeElementObj(obj);
  - storeTrigger(triggerObj);
  option&attributes(elementObj)
    block
//-End Mixin
//- @pugdoc
  name: select
  description: A mixin to create a select element. Uses K-scaffold global variables to control how {@link option} mixins within the select's block behave.
  arguments:
    - {object} inputObj - The object describing the select
    - {block} block - The content within the select
  attributes:
  example: |
    include _htmlelements.pug
    +select({name:'my select'})
      +option({value:'a value','data-i18n':'a translation key',trigger:{affects:['some_attribute']}})
      +option({value:'value 2','data-i18n':'translation 2'})
      +option({value:'value 3'})
        |Some Text we include via the option's block
mixin select(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - obj.name = replaceSpaces(obj.name);
  - obj.title = obj.title || attrTitle(obj.name);
  - obj.name = `attr_${obj.name}`;
  - selectName = obj.name;
  - selectTitle = obj.title;
  - addFieldToFieldsetObj(obj);
  select&attributes(obj)
    if block
      block
    else
      +option({value:'empty select, PEBKAC',selected:true})
//-End Mixin
//- @pugdoc
  name: img
  description: A mixin to create a sheet image element. Particularly useful when using the image attribute syntax.
  arguments:
  attributes:
  example: |
    include _htmlelements.pug
    +img({name:'my image',class:'some-class'})
mixin img(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - obj['data-i18n-alt'] = obj['data-i18n-alt'] || obj.name;
  - obj.name = replaceSpaces(obj.name);
  - obj.title = obj.title || attrTitle(obj.name);
  - obj.name = `attr_${obj.name}`;
  img&attributes(obj)
//-End Mixin
//- @pugdoc
  name: span
  description: Creates a span element and formats the name of the span for compatibility with the Roll20 attribute system.
  arguments:
    - {object} attrObj - The object describing the span itself.
    - {block} block - What is contained within the span
  attributes:
  example: |
    include _htmlelements.pug
    +span({name:'attribute backed span',trigger:{calculation:'calculateAttribute'}})
mixin span(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  if obj.name
    - obj.name = replaceSpaces(obj.name);
    - obj.title = obj.title || attrTitle(obj.name);
    - obj.name = `attr_${obj.name}`;
    - addFieldToFieldsetObj(obj);
  - const elementObj = makeElementObj(obj);
  span&attributes(elementObj)
    block
  if obj.name
    - obj.type = 'span';
    - storeTrigger(obj);
//-End Mixin
//- @pugdoc
  name: div
  description: Creates a div element and will properly format the name attribute of the div if it is provided
  arguments:
    - {object} divObj - The object describing the div
    - {block} block - The contents of the div
  attributes:
  example: |
    include _htmlelements.pug
    +div({name:'background image'})
mixin div(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  if obj.name
    - obj.name = replaceSpaces(obj.name);
    - obj.title = obj.title || attrTitle(obj.name);
    - obj.name = `attr_${obj.name}`;
  div&attributes(obj)
    block
//-End Mixin
mixin h1(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  h1&attributes(obj)
    block
//-End Mixin
mixin h2(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  h2&attributes(obj)
    block
//-End Mixin
mixin h3(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  h3&attributes(obj)
    block
//-End Mixin
mixin h4(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  h4&attributes(obj)
    block
//-End Mixin
mixin h5(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  h5&attributes(obj)
    block
//-End Mixin
mixin h6(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  h6&attributes(obj)
    block
//-End Mixin
mixin p(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  p&attributes(obj)
    block
//-End Mixin
//- @pugdoc
  name: button
  description: Creates a button element. Valid types are `roll` or `action`. If a type is not specified in the object argument, a roll button is created. If an action button is created, spaces in the name are replaced with dashes instead of underscores.
  arguments:
    - {object} buttonObj - The object describing the button
    - {block} block - The contents of the button element
  attributes:
  example: |
    include _htmlelements.pug
    //A basic roll button
    +button({name:'my button',value:'/r 3d10'})
    //An action button
    +button({name:'my button',type:'action','data-i18n':'action button',trigger:{triggeredFuncs:['doSomethingOnClick']}})
mixin button(obj, _attributes)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - obj.name = replaceSpaces(obj.name);
  - obj.title = obj.title || buttonTitle(obj.name);
  if obj.type === 'action'
    - obj.name = `act_${obj.name}`;
  else
    - obj.type = 'roll';
    - obj.name = `roll_${obj.name}`;
  - const elementObj = makeElementObj(obj);
  if obj.type !== 'roll'
    - storeTrigger(obj);
  button&attributes(elementObj)&attributes(attributes)
    block
//-End Mixin
//- @pugdoc
  name: action
  description: Alias for {@link button} that creates a button element with a type of `action`. Spaces in the name are replaced with dashes instead of underscores.
  arguments:
  attributes:
  example: |
    include _htmlelements.pug
    +action({name:'my button','data-i18n':'action button',trigger:{triggeredFuncs:['doSomethingOnClick']}})
mixin action(obj, _attributes)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - obj.type = 'action';
  - obj.name = obj.name.replace(/\s+/g,'-');
  +button(obj)&attributes(attributes)
    block
//- End Mixin
//- @pugdoc
  name: navButton
  description: Alias for {@link button} that creates a button element with a type of `action` for use in nav buttons. Spaces in the name are replaced with dashes instead of underscores. The name is prefixed with `nav_`. A {@link trigger} object should be passed
  arguments:
  attributes:
  example: |
    include _htmlelements.pug
    +navButton({name:'my button','data-i18n':'action button'})
mixin navButton(obj)
  - addIfUnique(obj.name,'navButtons');
  - obj.name = `nav ${obj.name}`;
  +action(obj)&attributes(attributes)
    block
//- End Mixin
mixin rollerExtras(obj)
  - obj.class = obj.class ? `${replaceProblems(obj.class)} roller` : 'roller';
  - let attrName = replaceSpaces(actionInputName(obj.name));
  - let actionName = actionButtonName(attrName);
  - obj.value = `@{${attrName}}`;
  - actionObj = {name:actionName,hidden:''};
  - actionObj.trigger = obj.trigger || {listenerFunc:'initiateRoll'};
  block
  - addIfUnique(`${repeatingPrefix}${attrName}`,'actionAttributes');
  +action(actionObj)
  +hidden({name:attrName})
//- End Mixin
//- @pugdoc
  name: roller
  description: Creates a multi element construction made of a hidden input, a roll button, and a hidden action button. On sheet load, or character sheet name change, the hidden input is updated with an ability call to the action button. The roll button refers to the hidden input as its value. This allows for an action button to be used to call custom roll parsing (or other sheet functionality) while retaining the ability to drag the button to the macro bar. Uses the same arguments as {@link button}. A trigger should be passed, and will be associated with the action button's name.
  arguments:
  attributes:
  example: |
    include _htmlelements.pug
    +roller({name:'my button','data-i18n':'action button',trigger:{triggeredFuncs:['doSomethingOnClick']}})
mixin roller(obj)
  +rollerExtras(obj)
    - let rollObj = {...obj};
    - delete rollObj.trigger;
    +button(obj)
      block
mixin section(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  section&attributes(obj)
    block
//-End Mixin
mixin main(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  main&attributes(obj)
    block
//-End Mixin
mixin header(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  header&attributes(obj)
    block
//-End Mixin
mixin footer(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  footer&attributes(obj)
    block
//-End Mixin
mixin details(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  details&attributes(obj)
    block
//-End Mixin
mixin summary(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  summary&attributes(obj)
    block
//-End Mixin
mixin label(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  label&attributes(obj)
    block
//-End Mixin
//- @pugdoc
  name: fieldset
  description: A mixin that creates a fieldset for the creation of a repeating section. The mixin prefixes the name with `repeating_` and replaces problem characters (e.g. spaces are replaced with dashes). Additionally, the auto-generated title properties from the K-scaffold\'s mixins will include the proper repeating section information.
  arguments:
    - {string} name - The name of the repeating section. Will be prefixed with `repeating_` and spaces will be replaced with dashes (`-`).
    - {object} [trigger] - Trigger that defines how to handle the removal of a row from the fieldset. `Optional`
    - {string} addClass - Any additional classes that should be used for the repeating section. Note that these are not added to the fieldset itself as adding additional classes to the fieldset itself interferes with calling action buttons from chat, but are added to a span that precedes the fieldset. This allows styling of the repcontainer via a css declaration like `.bonus-class + fieldset + .repcontainer`.
  attributes:
  example: |
    include _htmlelements.pug
    //A basic fieldset declaration with a trigger
    +fieldset({
      name:'fieldset',
      trigger:{triggeredFuncs:['doWhenRemoved']}
    })
      +text({name:'name'})
    
    //A Fieldset with an added class
    +fieldset({
      name:'fieldset',
      trigger:{triggeredFuncs:['doWhenRemoved']},
      addClass:'some-class'
    })
      +text({name:'name'})
mixin fieldset({name,trigger,addClass})
  - name = name.replace(/\s+/g,'-');
  - let section = `repeating_${name}`;
  - repeatingPrefix = `${section}_$X_`;
  - createFieldsetObj(section)
  if trigger
    - storeTrigger({name:section,type:'fieldset',trigger})
  if addClass
    span(hidden="" class=addClass)
  fieldset(class=`${section}`)
    block
  - repeatingPrefix = '';
//-End Mixin
//- @pugdoc
  name: customControlFieldset
  description: Alias for {@link fieldset} that creates to custom action buttons to add/remove rows to the repeating section. Useful when you need to trigger a sheetworker when a row is added. This also prevents the occassional error of a new row disappearing immediately after the user has clicked the button to create one. Proper use of this will require css to hide the default buttons that fieldsets create automatically. Note that currently this assumes the existence of an addItem and editSection sheetworker function.
  arguments:
    - {string} name - The name of the repeating section. Will be prefixed with `repeating_` and spaces will be replaced with dashes (`-`).
    - {object} [trigger] - Trigger that defines how to handle the removal of a row from the fieldset. `Optional`
    - {string} addClass - Any additional classes that should be used for the repeating section. Note that these are not added to the fieldset itself as adding additional classes to the fieldset itself interferes with calling action buttons from chat, but are added to a span that precedes the fieldset. This allows styling of the repcontainer via a css declaration like `.bonus-class + fieldset + .repcontainer`.
  attributes:
  example: |
    include _htmlelements.pug
    //A basic customControlfieldset declaration with a trigger
    +customControlfieldset({
      name:'fieldset',
      trigger:{triggeredFuncs:['doWhenRemoved']}
    })
    
    //A customControlfieldset with an added class
    +customControlfieldset({
      name:'fieldset',
      trigger:{triggeredFuncs:['doWhenRemoved']},
      addClass:'some-class'
    })
mixin customControlFieldset({name,trigger,addClass})
  +action({name:`add ${name}`,class:'repcontrol-button repcontrol-button--add',trigger:{listenerFunc:'addItem'}})
  +action({name:`edit ${name}`,class:'repcontrol-button repcontrol-button--edit',trigger:{listenerFunc:'editSection'}})
  +fieldset({name,trigger,addClass})
    block
//- End Mixin
//- @pugdoc
  name: repeating_section
  description: A mixin that creates a section element with an h2, a space for column headers, and a {@link customcontrolfieldset} which can be styled to fit those column headers. The h2 labels the section via `aria-labelledby`.
  arguments:
    - {string} name - The name of the section as per {@link fieldset}. This name will also be added to the section's class list as `repeating-container--NAME`. If no id argument is passed, this is also used as the id of the section.
    - {string} header - The translation key for the h2 element in the section
    - {array} columnArr - Array of translation keys to use as column headers. These are added as h5's.
    - {string} id - An id to use for the section element.
  attributes:
  example: |
    include _htmlelements.pug
    +repeating_section('attacks','weapons',['name','bonus','damage','property'],'atk')
      +text({name:'name'})
      +number({name:'bonus'})
      +text({name:'damage'})
      +text({name:'properties'})
mixin repeating_section(name,header,columnArr,id)
  section(class=`repeating-container--${name} repeating-container section` id=`${(id||name).replace(/\s+/g,'-')}`)
    if header
      h2(data-i18n=header)
    if columnArr
      .repeat-columns
        each head in columnArr
          h5(data-i18n=head)
    +customControlFieldset(name)
      block
//- End Mixin
//- @pugdoc
  name: inlineFieldset
  description: An alias for {@link fieldset} that creates a fieldset with an added class that can be easily hooked into via CSS to style the fieldset for inline display.
  arguments:
    - {string} name - The name of the repeating section. Will be prefixed with `repeating_` and spaces will be replaced with dashes (`-`).
    - {object} [trigger] - Trigger that defines how to handle the removal of a row from the fieldset. `Optional`
    - {string} addClass - Any additional classes that should be used for the repeating section. Note that these are not added to the fieldset itself as adding additional classes to the fieldset itself interferes with calling action buttons from chat, but are added to a span that precedes the fieldset. This allows styling of the repcontainer via a css declaration like `.bonus-class + fieldset + .repcontainer`.
  attributes:
  example: |
    include _htmlelements.pug
    +inlineFieldset({
      name:'fieldset',
      trigger:{triggeredFuncs:['doWhenRemoved']},
      addClass:'some-class'
    })
mixin inlineFieldset({name,trigger,addClass})
  - addClass = addClass ? `${addClass} inline-fieldset` : 'inline-fieldset';
  - varObjects.inlineFieldsets = varObjects.inlineFieldsets || [];
  - varObjects.inlineFieldsets.push(name);
  +fieldset({name,trigger,addClass})
    +radio({name:'display state',class:'display-control',value:'short-display',hidden:''})
    .inline-fieldset__summary.display-target
      label.pointer
        +checkbox({name:'collapse',value:1,hidden:'',trigger:{triggeredFuncs:['collapseSection']}})
        +span({name:'name',class:'inline-fieldset__summary__text'})
    +radio({name:'display state',class:'display-control',value:'display',checked:'',hidden:''})
    .inline-fieldset__detail.display-target
      +collapse
      block
  +action({name:`add ${name}`,class:'repcontrol-button repcontrol-button--add repcontrol-button--inline',trigger:{listenerFunc:'sectionInteract'}})
  +action({name:`edit ${name}`,class:'repcontrol-button repcontrol-button--edit repcontrol-button--inline',trigger:{listenerFunc:'sectionInteract'}})
//- End Mixin
//- @pugdoc
  name: button-label
  description: A mixin to create a combined button and input that are within the same container. Similar to {@link input-label}, but does not use a label.
  arguments:
    - {object} inputObj - An object describing the input to be paired with the button. This is the same object that you would pass to {@link input}.
    - {object} buttonObj - An object describing the button to be paired with the input. This is the same object that you would pass to {@link button}.
    - {object} divObj - An object describing the container div. Similar to the first two objects, but will most likely only have a `class` property if it is passed at all.
  attributes:
  example: |
    include _htmlelements.pug
    +button-label({
      inputObj:{name:'strength',type:'number',class:'underlined',value:10,trigger:{affects:['athletics']}},
      buttonObj:{name:'strength_roll',type:'roll',value:'/r 1d20+@{strength}'},
      divObj:{class:'strength'}
    })
mixin button-label({inputObj,buttonObj,divObj})
  if divObj
    - divObj.class = divObj.class ? replaceProblems(divObj.class) : undefined;
  - inputObj.class = inputObj.class ? replaceProblems(inputObj.class) : undefined;
  - buttonObj.class = buttonObj.class ? replaceProblems(buttonObj.class) : undefined;
  - inputObj.name = inputObj.name.replace(/\s+/g,'_');
  - buttonObj.name = (buttonObj.name || inputObj.name).replace(/\s+/g,'_');
  .input-label.input-label--button&attributes(divObj)
    - inputObj.class = inputObj.class ? `${inputObj.class} input-label__input` : 'input-label__input';
    if spanObj
      - buttonObj.class = buttonObj.class ? `${buttonObj.class} input-label__text` : 'input-label__text';
    +button(buttonObj)
    +input(inputObj)
//-End Mixin
//- @pugdoc
  name: roller-label
  description: Similar to the construction created by {@link button-label}, except that it creates a {@link roller} construction instead of just a straight button.
  arguments:
    - {object} inputObj - An object describing the input to be paired with the button. This is the same object that you would pass to {@link input}.
    - {object} buttonObj - An object describing the button to be paired with the input. This is the same object that you would pass to {@link button}.
    - {object} divObj - An object describing the container div. Similar to the first two objects, but will most likely only have a `class` property if it is passed at all.
  attributes:
  example: |
    include _htmlelements.pug
    +roller-label({
      inputObj:{name:'strength',type:'number',class:'underlined',value:10,trigger:{affects:['athletics']}},
      buttonObj:{name:'strength_roll',type:'roll',value:'/r 1d20+@{strength}'},
      divObj:{class:'strength'}
    })
mixin roller-label({inputObj,buttonObj,divObj})
  +rollerExtras(buttonObj)
    +button-label({inputObj,buttonObj,divObj})
//-End Mixin
//- @pugdoc
  name: action-label
  description: Similar to the construction created by {@link button-label}, except that it specifcally creates an [action button](https://wiki.roll20.net/Button#Action_Button) as per {@link action}.
  arguments:
    - {object} inputObj - An object describing the input to be paired with the button. This is the same object that you would pass to {@link input}.
    - {object} buttonObj - An object describing the button to be paired with the input. This is the same object that you would pass to {@link button}.
    - {object} divObj - An object describing the container div. Similar to the first two objects, but will most likely only have a `class` property if it is passed at all.
  attributes:
  example: |
    include _htmlelements.pug
    +roller-label({
      inputObj:{name:'strength',type:'number',class:'underlined',value:10,trigger:{affects:['athletics']}},
      buttonObj:{name:'strength_roll',type:'roll',value:'/r 1d20+@{strength}'},
      divObj:{class:'strength'}
    })
mixin action-label({inputObj,buttonObj,divObj})
  - buttonObj.type = 'action';
  +button-label(inputObj,buttonObj,divObj)
//-End Mixin
//- @pugdoc
  name: select-label
  description: Similar to the construction created by {@link input-label}, except that the input is replaced with a select.
  arguments:
    - {string} label - The translation key to use for the span. If not passed, then the spanObj must be passed with a translation key
    - {object} inputObj - An object describing the select to be paired with the button. This is the same object that you would pass to {@link select}.
    - {object} [divObj] - An object describing the container label. Similar to the inputObj, but will most likely only have a `class` property if it is passed at all.
    - {object} [spanObj] - An object describing the span to be paired with the input. This is the same object that you would pass to {@link span}.
    - {block} block - The mixin uses the pug block as the content of the select.
  attributes:
  example: |
    include _htmlelements.pug
    +select-label({
      label:'Whisper to GM',
      inputObj:{name:'whisper'},
      divObj:{class:'div-class'},
      spanObj:{class:'span-class'}
    })
      +option({value:'','data-i18n':'never',selected:''})
      +option({value:'/w gm ','data-i18n':'always'})
mixin select-label({label,inputObj,divObj,spanObj})
  if divObj
    - divObj.class = divObj.class ? replaceProblems(divObj.class) : undefined;
  if inputObj
    - inputObj.class = inputObj.class ? replaceProblems(inputObj.class) : undefined;
  if spanObj
    - spanObj.class = spanObj.class ? replaceProblems(spanObj.class) : undefined;
  label.input-label&attributes(divObj)
    - inputObj.name = inputObj.name.replace(/\s+/g,'_');
    - inputObj.class = inputObj.class ? `${inputObj.class} input-label__input` : 'input-label__input';
    if spanObj
      - spanObj.class = spanObj.class ? `${spanObj.class} input-label__text` : 'input-label__text';
    span(data-i18n=label)&attributes(spanObj)
    +select(inputObj)
      block
//-End Mixin
//- @pugdoc
  name: input-label
  description: 
  arguments:
    - {string} label - The translation key to use for the span. If not passed, then the spanObj must be passed with a translation key
    - {object} inputObj - An object describing the input to be paired with the button. This is the same object that you would pass to {@link input}.
    - {object} [divObj] - An object describing the container label. Similar to the inputObj, but will most likely only have a `class` property if it is passed at all.
    - {object} [spanObj] - An object describing the span to be paired with the input. This is the same object that you would pass to {@link span}.
  attributes:
  example: |
    include _htmlelements.pug
    +input-label({
      label:'strength',
      inputObj:{name:'strength',type:'number'},
      divObj:{class:'div-class'},
      spanObj:{class:'span-class'}
    })
mixin input-label({label,inputObj,divObj,spanObj})
  if divObj
    - divObj.class = divObj.class ? replaceProblems(divObj.class) : undefined;
  if inputObj
    - inputObj.class = inputObj.class ? replaceProblems(inputObj.class) : undefined;
  if spanObj
    - spanObj.class = spanObj.class ? replaceProblems(spanObj.class) : undefined;
  label.input-label&attributes(divObj)
    - inputObj.name = inputObj.name.replace(/\s+/g,'_');
    - inputObj.class = inputObj.class ? `${inputObj.class} input-label__input` : 'input-label__input';
    if spanObj
      - spanObj.class = spanObj.class ? `${spanObj.class} input-label__text` : 'input-label__text';
    span(data-i18n=label)&attributes(spanObj)
    +input(inputObj)
//-End Mixin
mixin dual-input-label({label,inputArr,divObj,spanObj})
  if divObj
    - divObj.class = divObj.class ? replaceProblems(divObj.class) : undefined;
  if spanObj
    - spanObj.class = spanObj.class ? replaceProblems(spanObj.class) : undefined;
  .input-label.input-label--dual&attributes(divObj)
    span(data-i18n=label)&attributes(spanObj)
    each inputObj,i in inputArr
      if inputObj
        - inputObj.class = inputObj.class ? replaceProblems(inputObj.class) : undefined;
      - inputObj.name = inputObj.name.replace(/\s+/g,'_');
      +input(inputObj)
      if i<1
        span(class='slash h2')='/'
//-End Mixin
//- @pugdoc
  name: headedTextarea
  description: Creates a construction for pairing a header with a textarea. Currently is locked to creating an `h3`.  This mixin also accepts classes and IDs appended directly to it (see the second example)
  arguments:
    - {object} textObj - The object describing the textarea as per {@link textarea}
    - {string} header - The `data-i18n` translation key to use for the header
  attributes:
  example: |
    include _htmlelements.pug
    +headedTextarea({textObj:{name:'character description','data-i18n-placeholder':'The description of your character'},header:'description'})
    //With class appended to the mixin itself
    +headedTextarea({textObj:{name:'character description','data-i18n-placeholder':'The description of your character'},header:'description'}).character-description
mixin headedTextarea({textObj,header})
  .headed-textarea&attributes(attributes)
    - textObj.class = textObj.class ? `${textObj.class} headed-textarea__textarea` : 'headed-textarea__textarea';
    +h3({'data-i18n':header,class:'headed-textarea__header'})
    +textarea(textObj)
//-End Mixin
//- @pugdoc
  name: adaptiveTextarea
  description: Creates an html construction for creating a [content-scaled](https://wiki.roll20.net/CSS_Wizardry#Content-scaled_Inputs) textarea. You can apply classes and IDs to the container div by appending them to the mixin call (see the second example).
  arguments:
    - {object} textObj - The object describing the textarea as per the {@link textarea} mixin.
  attributes:
  example: |
    include _htmlelements.pug
    +adaptiveTextarea({name:'character description'})

    //Appending the class directly to the mixin
    +adaptiveTextarea({name:'character description'}).custom-class
mixin adaptiveTextarea(textObj)
  .adaptive.adaptive--text&attributes(attributes)
    - let spanObj = {name:textObj.name,class:'adaptive--text__span'};
    - textObj.class = textObj.class ? `${textObj.class} adaptive--text__textarea` : 'adaptive--text__textarea';
    +span(spanObj)
    +textarea(textObj)
//- End Mixin
//- @pugdoc
  name: adaptiveInput
  description: Creates an html construction for creating a [content-scaled](https://wiki.roll20.net/CSS_Wizardry#Content-scaled_Inputs) input. You can apply classes and IDs to the container div by appending them to the mixin call (see the second example).
  arguments:
    - {object} inputObj - The object describing the input as per the {@link input} mixin. You can apply classes and IDs to the container div by appending them to the mixin call (see the second example).
  attributes:
  example: |
    include _htmlelements.pug
    +adaptiveInput({name:'character description',type:'text'})

    //Appending class directly to the mixin
    +adaptiveInput({name:'character description',type:'text'}).custom-class
mixin adaptiveInput(textObj)
  .adaptive.adaptive--input&attributes(attributes)
    - let spanObj = {name:textObj.name,class:'adaptive--input__span','max-width':maxWidth};
    - textObj.class = textObj.class ? `${textObj.class} adaptive--input__input` : 'adaptive--input__input';
    +span(spanObj)
    +input(textObj)
//- End Mixin
//- @pugdoc
  name: compendiumAttributes
  description: Creates a set of compendium drop target attributes. Defaults to creating target attributes for the `Name` and `data` compendium attributes.
  arguments:
    - {string} [prefix] - A prefix to attach to the default attribute names.
    - {array} [lookupAttributes = ['Name','data']] - An array of the lookup attributes to create targets for. The target attributes are named based on the compendium attribute they are for.
    - {string} [triggerAccept = 'Name'] - The compendium attribute that should trigger the sheetworkers to handle the compendium drop.
    - {object} [trigger] - The trigger object.
  attributes:
  example: |
    include _htmlelements.pug
    //Using just defaults
    +compendiumAttributes({})

    //Specifying a prefix
    +compendiumAttributes({prefix:'prefix'})

    //Specifying lookupAttributes and a prefix
    +compendiumAttributes({lookupAttributes:['Name','data','Category'],prefix:'prefix'})
mixin compendiumAttributes({prefix,lookupAttributes = ['Name','data'],triggerAccept = 'Name',trigger = {triggeredFuncs:["handleCompendiumDrop"]}})
  - prefix = prefix ? `${prefix} ` : '';
  each accept in lookupAttributes
    - let inputObj = {name:`${prefix}drop ${accept.toLowerCase()}`,accept,value:''};
    if accept === triggerAccept
      - inputObj.trigger = trigger;
    +hidden(inputObj)
//- End Mixin

include tabs/_tabs.pug

//- Functions
//- @pugdoc
  name: script
  description: Creates a generic [Roll20 script block](https://wiki.roll20.net/Building_Character_Sheets#JavaScript_2) for use with the sheetworker system.
  arguments:
  attributes:
  example: |
    include _htmlelements.pug
    +script
mixin script
  script(type='text/worker')
    block
//-End Mixin
//- @pugdoc
  name: kscript
  description: Similar to {@link script}, but includes the K-scaffold\'s javascript function library.
  arguments:
  attributes:
  example: |
    include _htmlelements.pug
    +kscript
mixin kscript
  +script
    |const k = (function(){
    |const kFuncs = {};
    //- The below declarations import variables from the pug file and mixins into the sheetworker code
    - const propArray = ['cascades','repeatingSectionDetails'];
    each prop in propArray
      |
      |const !{prop} = !{JSON.stringify(varObjects[prop])};
      |
      |kFuncs.!{prop} = !{prop};
      - delete varObjects[prop];
    |
    |
    include kvariables.js
    include utility.js
    include attribute_proxy.js
    include accessSheet.js
    include parse_cascade.js
    include sheetworker_aliases.js
    include listeners.js
    include tabs/tabs.js
    |
    |return kFuncs;
    |}());
    |
    each content,prop in varObjects
      |
      if typeof content === 'object'
        |const !{prop} = !{JSON.stringify(content)};
      else
        |let !{prop} = !{content};
      |
    |
    block
//- End Mixin
//- @pugdoc
  name: attrTitle
  description: Converts an attribute name into an attribute call for that attribute. Converts `_max` attribute names to the proper attribute call syntax for `_max` attributes (see second example). If called from inside the block of a {@link fieldset} mixin, will also add the appropriate information for calling a repeating attribute.
  arguments:
    - {string} attrName - The attribute name to create an attribute call for.
  attributes:
  example: |
    include _htmlelements.pug
    //Basic attribute name
    +input({name:'hidden name',type:'text',title:attrTitle('user accessible name')})

    //Max attribute name
    +input({name:'hidden max',type:'number',title:attrTitle('user accessible max')})

    //fieldset attrTitle
    +fieldset({name:'equipment'})
      +input({name:'name',type:'text',title:attrTitle('user accessible name')})
- const attrTitle = (string) => `@{${repeatingPrefix}${replaceSpaces(string).replace(/_max$/,'|max')}}`;
//- @pugdoc
  name: buttonTitle
  description: Converts an ability name into an ability call for that attribute. If called from inside the block of a {@link fieldset} mixin, will also add the appropriate information for calling a repeating attribute.
  arguments:
    - {string} abilityName - The ability name to create a call for.
  attributes:
  example: |
    include _htmlelements.pug
    //Basic attribute name
    +button({name:'hidden button',type:'text',title:buttonTitle('user accessible name')})

    //fieldset attrTitle
    +fieldset({name:'equipment'})
      +button({name:'button',type:'text',title:buttonTitle('user accessible name')})
- const buttonTitle = (string) => `%{${repeatingPrefix}${replaceSpaces(string)}}`;
//- @pugdoc
  name: replaceSpaces
  description: Replaces spaces in a string with underscores (`_`).
  arguments:
    - {string} string - The string to work on
  attributes:
- const replaceSpaces = (string) => string.replace(/\s+/g,'_');
//- @pugdoc
  name: replaceProblems
  description: Escapes problem characters in a string for use as a regex.
  arguments:
    - {string} string - The string to work on
  attributes:
- const replaceProblems = (string) => string.replace(/[\(\)\[\]\|\/\\]/g,'-');
//- @pugdoc
  name: capitalize
  description: Capitalizes the first let of words in a string.
  arguments:
    - {string} string - The string to work on
  attributes:
-
  const capitalize = (string)=> string.replace(/(?:^|\s+|\/)[a-z]/ig,(letter)=>letter.toUpperCase());

- const actionButtonName = (name) => `${name.replace(/_|\s+/g,'-')}`;
- const actionInputName = (name) => `${name}_action`.replace(/roll_action/,'action');
- const titleToName = (string) => string.replace(/[@%]\{|\}/g,'');
-
  const addIfUnique = (item,arrName) => {
    varObjects[arrName] = varObjects[arrName] || [];
    if(varObjects[arrName].indexOf(item) === -1){
      varObjects[arrName].push(item);
    }
  };
-
  const storeTrigger = function(element){
    let trigger = element.trigger || {};
    const namePrefix = {
      roll:'roll_',
      action:'act_',
      fieldset:'fieldset_'
    };
    const typeDefs = {
      select:'',
      radio:0,
      checkbox:0,
      number:0,
      text:'',
      span:''
    };
    const eventTypes = {
      roll:'clicked',
      action:'clicked',
      fieldset:'remove'
    };
    let elementName = element.title ?
      titleToName(element.title) :
      element.name;
    trigger.name = elementName.replace(/\|/g,'_');
    let cascName = `${namePrefix[element.type] || 'attr_'}${trigger.name}`;
    let match = trigger.name.match(/(repeating_[^_]+)_[^_]+_(.+)/);
    let [,section,field] = match || [,,trigger.name];
    let eventType = eventTypes[element.type] || 'change';
    if(!varObjects.cascades[cascName]){
      if(trigger.listener || trigger.triggeredFuncs || trigger.listenerFunc || trigger.initialFunc || trigger.affects){
        trigger.listener = trigger.listener || `${eventType}:${section ? `${section}:` : ''}${field}`;
        trigger.listenerFunc = trigger.listenerFunc || 'accessSheet';
      }
      trigger.type = element.type;
      if(!namePrefix[element.type]){
        trigger.defaultValue = trigger.hasOwnProperty('defaultValue') ?
          trigger.defaultValue :
          (element.type === 'checkbox' && !element.hasOwnProperty('checked')) ?
            0 :
            element.hasOwnProperty('value') ?
              element.value :
              typeDefs.hasOwnProperty(element.type) ?
                typeDefs[element.type] :
                '';
        trigger.triggeredFuncs = trigger.triggeredFuncs || [];
        if(trigger.affects){
          trigger.affects = trigger.affects.map((affect)=>replaceSpaces(affect));
        }else{
          trigger.affects = [];
        }
      }
      varObjects.cascades[cascName] = {...trigger};
    }else{
      if(!namePrefix[varObjects.cascades[cascName].type]){
        varObjects.cascades[cascName].triggeredFuncs = trigger.triggeredFuncs ?
          [...new Set([...varObjects.cascades[cascName].triggeredFuncs,...trigger.triggeredFuncs])] :
          varObjects.cascades[cascName].triggeredFuncs;
        varObjects.cascades[cascName].affects = trigger.affects ?
          [...new Set([...varObjects.cascades[cascName].affects,...trigger.affects])] : 
          varObjects.cascades[cascName].affects;
        varObjects.cascades[cascName].calculation = varObjects.cascades[cascName].calculation || 
          trigger.calculation;
      }
      if(trigger.listenerFunc || trigger.triggeredFuncs || trigger.affects){
        varObjects.cascades[cascName].listener = varObjects.cascades[cascName].listener || trigger.listener || `${eventType}:${section ? `${section}:` : ''}${field}`;
        varObjects.cascades[cascName].listenerFunc = varObjects.cascades[cascName].listenerFunc || trigger.listenerFunc || 'accessSheet';
      }
    }
  };
-
  const getSectionDetails = function(section){
    return varObjects.repeatingSectionDetails.find((obj)=>obj.section === section);
  };
-
  const createFieldsetObj = function(section){
     !getSectionDetails(section) ? 
      varObjects.repeatingSectionDetails.push({section,fields:[]}) :
      null;
  };
-
  const addFieldToFieldsetObj = function(obj){
    let section = repeatingPrefix.replace(/_[^_]+_$/,'');
    let sectionDetails = getSectionDetails(section);
    let name = obj.name.replace(/^attr_/,'');
    if(sectionDetails && sectionDetails.fields.indexOf(name) < 0){
      sectionDetails.fields.push(name);
    }
  };
-
  const makeElementObj = function(obj){
    const newObj = {...obj};
    delete newObj.trigger;
    return newObj;
  };