<input type="text" class="invisible" name="attr_speed" value="0" />
<input type="text" class="invisible" name="attr_streetwise" value="0" />
<input type="text" class="invisible" name="attr_persuasion" value="0" />
<input type="text" class="invisible" name="attr_leadership" value="0" /> 
<input type="text" class="invisible" name="attr_diplomacy" value="0" />
<input type="text" class="invisible" name="attr_intimidation" value="0" />
<input type="text" class="invisible" name="attr_claws" value="0" />
<input type="text" class="invisible" name="attr_shapeshift_skill_modifier" value="0" />
<input type="text" class="invisible" name="attr_job_skill_score" value="0" />
<input type="text" class="invisible" name="attr_business" value="0"/>
<input type="text" class="invisible" name="attr_humanity_rolled" value="50"/>
<input type="text" class="invisible" name="attr_initiative_rules_normal" value="1"/>
<input type="text" class="invisible" name="attr_initiative_rules_streetvelocity" value="0"/>
<input type="text" class="invisible" name="attr_initiative_rules_houseruled" value="0"/>

<div class="absposhelper">
    <button type="action" class="settingbutton"><input type="checkbox" class="buttonfixer" name="attr_settings_toggle"/></button>
    <input type="checkbox" class="hidesothers1 invisible" name="attr_settings_toggle"/>
    <div class="hideifhidesothers1notchecked settingswindow">
        <h2 style ="overflow: hidden; text-overflow: ellipsis;">Street Velocity</h2>
        <br>
        <h5 style = "height: inherit;">Use street velocity initiative rules</h5><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_initiative_rules" value="1" ></span>
        <br>
        <h2 style ="overflow: hidden; text-overflow: ellipsis;">Houserules</h2>
        <br>
        <h5 style = "height: inherit;">Temporary changes to FIT/Luck impact Survival Points</h5><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_changes_impact_survival_points" value="1" ></span>
        <h5 style = "height: inherit;">Initiative = Dexterity + Perception + 1d100 + Speed Edge</h5><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_initiative_rules" value="2" ></span>
        <br>
        <div class="comment">Interested in more houserules?  I’ve uploaded all of mine <button type="roll" name="roll_none" class="hyperlink" title="This will post a URL in the chat" value="[More Houserules: https://github.com/Foemass/RPG-House-Rules/wiki/NightLife-Quick-and-Painless-Ruleset](https://github.com/Foemass/RPG-House-Rules/wiki/NightLife-Quick-and-Painless-Ruleset)"></button>!</div>
    </div>
    <h1 class="title">Nightlife Kin Control Sheet</h1><br>
    <div class="table">
        <div class="col">
            <div class="cel">
                <h5>Name:</h5><span class="tfc"><input type="text" class="tf" name="attr_character_name" /></span>
            </div>
            <div class="cel">
                <h5>Race:</h5><span class="tfc"><input type="text" class="tf" name="attr_race" /></span>
            </div>
            <div class="cel">
                <h5>Faction:</h5><span class="tfc"><input type="text" class="tf" name="attr_faction" /></span>
            </div>
            <div class="cel">
                <h5>Age:</h5><span class="tfc"><input type="text" class="tf" name="attr_age" /></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>Physical Description:</h5>
            </div>
            <div class="bcel">
                <textarea class="ta" name="attr_physical_description"></textarea>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>Favored Mode of Dress:</h5>
            </div>
            <div class="bcel">
                <textarea class="ta" name="attr_favored_mode_of_dress"></textarea>
            </div>
        </div>
    </div>
    <br><h1>Abilities</h1><br>
    <div class="table">
        <div class="col">
            <div class="abilitycel"><div class="abilityvertlines"><div>changed</div></div>
                <h5>Strength (STR)</h5><span></span><input type="text" name="attr_strength" value="~" /><span class ="space"></span><input type="text" name="attr_strength_max" /><input type="text" class="previewinput2" name="attr_strength_tempmax" required="required" novalidate /><button class="ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{strength_rolled}+@{speed}+0)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{strength_rolled}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=Strength}} {{score=@{strength_rolled}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=0}}'></button><button type='roll' value='&{template:main} {{character_name=@{character_name}}} {{score_name=Strength}} {{score=[[@{strength_rolled}]]}} {{inc_dm=[[0]]}} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}}]]}}'></button>
            </div>
            <div class="abilitycel">
                <h5>Dexterity (DEX)</h5><span></span><input type="text" name="attr_dexterity" value="~" /><span class ="space"></span><input type="text" name="attr_dexterity_max" /><input type="text" class="previewinput2" name="attr_dexterity_tempmax" required="required" novalidate /><button class="ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{dexterity_rolled}+@{speed}+0)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{dexterity_rolled}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=Dexterity}} {{score=@{dexterity_rolled}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=0}}'></button><button type='roll' value='&{template:main} {{character_name=@{character_name}}} {{score_name=Dexterity}} {{score=[[@{dexterity_rolled}]]}} {{inc_dm=[[0]]}} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}}]]}}'></button>
            </div>
            <div class="abilitycel">
                <h5>Fitness (FIT)</h5><span></span><input type="text" name="attr_fitness" value="~" /><span class ="space"></span><input type="text" name="attr_fitness_max" /><input type="text" class="previewinput2" name="attr_fitness_tempmax" required="required" novalidate /><button class="ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{fitness_rolled}+@{speed}+0)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{fitness_rolled}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=Fitness}} {{score=@{fitness_rolled}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=0}}'></button><button type='roll' value='&{template:main} {{character_name=@{character_name}}} {{score_name=Fitness}} {{score=[[@{fitness_rolled}]]}} {{inc_dm=[[0]]}} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}}]]}}'></button>
            </div>
            <div class="abilitycel">
                <h5>Intellect (INT)</h5><span></span><input type="text" name="attr_intellect" value="~" /><span class ="space"></span><input type="text" name="attr_intellect_max" /><input type="text" class="previewinput2" name="attr_intellect_tempmax" required="required" novalidate /><button class="ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{intellect_rolled}+@{speed}+0)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{intellect_rolled}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=Intellect}} {{score=@{intellect_rolled}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=0}}'></button><button type='roll' value='&{template:main} {{character_name=@{character_name}}} {{score_name=Intellect}} {{score=[[@{intellect_rolled}]]}} {{inc_dm=[[0]]}} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}}]]}}'></button>
            </div>
            <p>&nbsp;</p>
        </div>
        <div class="col">
            <div class="abilitycel"><div class="abilityvertlines"><div>changed</div></div>
                <h5>Will</h5><span></span><input type="text" name="attr_will" value="~" /><span class ="space"></span><input type="text" name="attr_will_max" /><input type="text" class="previewinput2" name="attr_will_tempmax" required="required" novalidate /><button class="ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{will_rolled}+@{speed}+0)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{will_rolled}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=Will}} {{score=@{will_rolled}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=0}}'></button><button type='roll' value='&{template:main} {{character_name=@{character_name}}} {{score_name=Will}} {{score=[[@{will_rolled}]]}} {{inc_dm=[[0]]}} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}}]]}}'></button>
            </div>
            <div class="abilitycel">
                <h5>Perception (PER)</h5><span></span><input type="text" name="attr_perception" value="~" /><span class ="space"></span><input type="text" name="attr_perception_max" /><input type="text" class="previewinput2" name="attr_perception_tempmax" required="required" novalidate /><button class="ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{perception_rolled}+@{speed}+0)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{perception_rolled}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=Perception}} {{score=@{perception_rolled}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=0}}'></button><button type='roll' value='&{template:main} {{character_name=@{character_name}}} {{score_name=Perception}} {{score=[[@{perception_rolled}]]}} {{inc_dm=[[0]]}} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}}]]}}'></button>
            </div>
            <div class="abilitycel">
                <h5>Attractiveness (ATT)</h5><span></span><input type="text" name="attr_attractiveness" value="~" /><span class ="space"></span><input type="text" name="attr_attractiveness_max" /><input type="text" class="previewinput2" name="attr_attractiveness_tempmax" required="required" novalidate /><button class="ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{attractiveness_rolled}+@{speed}+0)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{attractiveness_rolled}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=Attractiveness}} {{score=@{attractiveness_rolled}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=0}}'></button><button type='roll' value='&{template:main} {{character_name=@{character_name}}} {{score_name=Attractiveness}} {{score=[[@{attractiveness_rolled}]]}} {{inc_dm=[[0]]}} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}}]]}}'></button>
            </div>
            <div class="abilitycel">
                <h5>Luck</h5><span></span><input type="text" name="attr_luck" value="~" /><span class ="space"></span><input type="text" name="attr_luck_max" /><input type="text" class="previewinput2" name="attr_luck_tempmax" required="required" novalidate /><button class="ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{luck_rolled}+@{speed}+0)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{luck_rolled}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=Luck}} {{score=@{luck_rolled}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=0}}'></button><button type='roll' value='&{template:main} {{character_name=@{character_name}}} {{score_name=Luck}} {{score=[[@{luck_rolled}]]}} {{inc_dm=[[0]]}} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}}]]}}'></button>
            </div>
            <p>&nbsp;</p>
        </div>
        <div class="col">
            <div class="abilitycel"><div class="abilityvertlines"><div>changed</div></div>
                <h5>Magic Ability (MA)</h5><span></span><input type="text" name="attr_magic_ability" value="~" /><span class ="space"></span><input type="text" name="attr_magic_ability_max" /><input type="text" class="previewinput2" name="attr_magic_ability_tempmax" required="required" novalidate /><button class="ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{magic_ability_rolled}+@{speed}+0)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{magic_ability_rolled}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=Magic Ability}} {{score=@{magic_ability_rolled}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=0}}'></button><button type='roll' value='&{template:main} {{character_name=@{character_name}}} {{score_name=Magic Ability}} {{score=[[@{magic_ability_rolled}]]}} {{inc_dm=[[0]]}} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}}]]}}'></button>
            </div>
            <div class="abilitycel">
                <h5>Street Face</h5><span></span><input type="text" name="attr_street_face" value="~" /><span class ="space"></span><input type="text" name="attr_street_face_max" readonly/><button class="ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{street_face_rolled}+@{speed}+0)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{street_face_rolled}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=Street Face}} {{score=@{street_face_rolled}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=0}}'></button><button type='roll' value='&{template:main} {{character_name=@{character_name}}} {{score_name=Street Face}} {{score=[[@{street_face_rolled}]]}} {{inc_dm=[[0]]}} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}}]]}}'></button>
            </div>
            <div class="abilitycel">
                <h5>Humanity | Max</h5><span></span><input type="text" name="attr_humanity" value="50" /><input type="text" class="previewinput1" name="attr_humanity_temp" required="required" /><span class ="space"></span><input type="text" name="attr_humanity_max" value="100" /><span class ="buttonspace"></span><button type='roll' value='&{template:main} {{character_name=@{character_name}}} {{score_name=Humanity}} {{score=[[@{humanity_rolled}]]}} {{inc_dm=[[0]]}} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}}]]}}'></button>
            </div>
            <div class="abilitycel">
                <h5>Survival Points</h5><span></span><input type="text" name="attr_survival_points" /><span class ="space"></span><input type="text" name="attr_survival_points_max" readonly/><span class ="doublebuttonspace"></span>
            </div>
            <div class="abilitycel">
                <h5>Base HTH Damage</h5><span></span><input type="text" name="attr_base_hth_damage" value="0" readonly/><span class ="doublebuttonspace"></span>
            </div>
        </div>
    </div>
    <br><h1>Edges and Flaws</h1><br>
    <div class="table">
        <div class="col">
            <h2>Edges</h2>
            <div class="absposhelper">
                <fieldset class="repeating_edges">
                    <div class="row">
                        <input type="checkbox" class="invisible hidesothers1" name="attr_edge_shapeshift_form_exists"/>
                        <input type="checkbox" class="invisible hidesothers2" name="attr_edge_speed_exists"/>
                        <input type="checkbox" class="barbutton0 hideifhidesothers1and2notchecked" name="attr_edge_shapeshift_form_activity"/>
                        <button class="ib barbutton1" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{edge_score}+@{speed}+1000)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{edge_score}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=@{name}}} {{score=@{edge_score}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=1000}}'></button>
                        <button class="barbutton2" type='roll' value='&{template:main} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}+@{edge_ability_loss_modifier}}]]}} {{character_name=@{character_name}}} {{score_name=@{name}}} {{score=[[@{edge_score}]]}} {{inc_dm=[[0]]}} {{ability_loss_modifier=[[@{edge_ability_loss_modifier}]]}} {{shapeshift_skill_modifier=[[0]]}} '></button>
                        <input type="text" class="invisible" name="attr_edge_ability_loss_modifier" value="0" />
                        <input type="text" class="invisible" name="attr_edge_roll_dp" value="0" />
                        <input type="text" class="invisible" name="attr_edge_roll_inc_hth" value="0" />
                        <input type="text" class="invisible" name="attr_edge_roll_inc_dm" value="0" />
                        <div>
                            <input type="checkbox" class="edgebartouch" name="attr_edge_maximized" />
                            <div class="edgebarvisual"><input type="text" class="edgebarltf bar-score" name="attr_edge_score" value="" readonly/><input type="text" class="edgebarltf bar-header" name="attr_name" value="Click to edit" readonly/><input type="text" class="edgebarltf bar-cost" name="attr_edge_use_cost" readonly/><span class="edgebarltf bar-doublebuttonspace"></span></div>
                            <div class="edgebarcontent">
                                <h5>Name:</h5><span class="tfc"><input type="checkbox" class="invisible greenborderothers1" name="attr_name_keyname"/><input type="text" class="tf greenborderifgreenborderothers1checked" name="attr_name" /></span>
                                <h5>Score:</h5><span class="tfc"><input type="text" class="tf" name="attr_edge_score" value="0" /></span>
                                <h5>Base:</h5><span class="tfc"><select name="attr_edge_base" class="tf"> 
                                <option value="NONE">NONE</option>
                                <option value="STR">STR</option>
                                <option value="DEX">DEX</option>
                                <option value="FIT">FIT</option>
                                <option value="INT">INT</option>
                                <option value="WILL">WILL</option>
                                <option value="PER">PER</option>
                                <option value="ATT">ATT</option>
                                <option value="LUCK">LUCK</option>
                                <option value="MA">MA</option>
                                <option value="5">5</option>
                                </select></span>
                                <h5>Target:</h5><span class="tfc"><input type="text" class="tf" name="attr_edge_target" /></span>
                                <span>
                                    <input type="checkbox" class="expandbox"/><div class="expandbox expandboxvisual expandboxopened">&minus;</div><div class="expandbox expandboxvisual expandboxclosed">&plus;</div><h5>Humanity Costs:</h5><span class="tfc"><input type="text" class="ltf" name="attr_edge_humanity_costs" value="?•?•?" readonly /></span>
                                    <div class="expandboxopened">
                                        <h6>Acquisition Cost:</h6><span class="tfc"><input type="text" class="tf" name="attr_edge_acquisition_cost" value="?" /></span>
                                        <h6>Cost Ratio:</h6><span class="tfc"><input type="text" class="tf" name="attr_edge_cost_ratio" value="?" /></span>
                                        <h6>Use Cost:</h6><span class="tfc"><input type="text" class="tf" name="attr_edge_use_cost" value="?" /></span>
                                    </div>
                                </span>
                                <span>
                                    <input type="checkbox" class="expandbox"/><div class="expandbox expandboxvisual expandboxopened">&minus;</div><div class="expandbox expandboxvisual expandboxclosed">&plus;</div><h5>Range:</h5><span class="tfc"><input type="text" class="ltf" name="attr_edge_range" value="n/a" readonly /></span>
                                    <div class="expandboxopened">
                                        <input type="checkbox" class="invisible hidesothers3" name="attr_edge_range_touch" />
                                        <input type="checkbox" class="invisible hidesothers4" name="attr_edge_range_distance" />
                                        <input type="checkbox" class="invisible hidesothers5" name="attr_edge_range_described" />
                                        <h6 class ="hideifhidesothers4checked">Touch:</h6><span class="tfc hideifhidesothers4checked"><input type="checkbox" class="edgecheckbox" name="attr_edge_range_touch" /></span>
                                        <h6 class="hideifhidesothers3checked">Distance:</h6><span class="tfc hideifhidesothers3checked"><input type="checkbox" class="edgecheckbox" name="attr_edge_range_distance" /></span>
                                        <h6 class="hideifhidesothers3checked hideifhidesothers4notchecked"><span class ="indent"></span>Value:</h6><span class="tfc hideifhidesothers3checked hideifhidesothers4notchecked"><select name="attr_edge_range_value" class="tf"> 
                                        <option value="Score">Score</option>
                                        <option value="STR">STR</option>
                                        <option value="DEX">DEX</option>
                                        <option value="FIT">FIT</option>
                                        <option value="INT">INT</option>
                                        <option value="WILL">WILL</option>
                                        <option value="PER">PER</option>
                                        <option value="ATT">ATT</option>
                                        <option value="LUCK">LUCK</option>
                                        <option value="MA">MA</option>
                                        <option value="1">1</option>
                                        </select></span>
                                        <h6 class="hideifhidesothers3checked hideifhidesothers4notchecked"><span class ="indent"></span>Multiplied by:</h6><span class="tfc hideifhidesothers3checked hideifhidesothers4notchecked"><input type="text" class="tf" name="attr_edge_range_multiplier" value="1" /></span>
                                        <h6 class="hideifhidesothers3checked hideifhidesothers4notchecked"><span class ="indent"></span>Measurement:</h6><span class="tfc hideifhidesothers3checked hideifhidesothers4notchecked"><select name="attr_edge_range_measurement" class="tf"> 
                                        <option value="Feet">Feet</option>
                                        <option value="Yards">Yards</option>
                                        <option value="Miles">Miles</option>
                                        </select></span>
                                        <h6>Line of sight:</h6><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_edge_range_lineofsight" /></span>
                                        <h6>Eye contact:</h6><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_edge_range_eyecontact" /></span>
                                        <h6>Voice:</h6><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_edge_range_voice" /></span>
                                        <h6>Other:</h6><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_edge_range_described" /></span>
                                        <span class ="indent hideifhidesothers5notchecked"></span><span class="tfc hideifhidesothers5notchecked"><input type="text" class="tf" name="attr_edge_range_description"/></span>
                                    </div>
                                </span>
                                <span>
                                    <input type="checkbox" class="expandbox"/><div class="expandbox expandboxvisual expandboxopened">&minus;</div><div class="expandbox expandboxvisual expandboxclosed">&plus;</div><h5>Escape Roll:</h5><span class="tfc"><input type="text" class="ltf" name="attr_edge_escape_roll" value="none" readonly /></span> 
                                    <div class="expandboxopened">
                                        <h6>Ability:</h6><span class="tfc"><select name="attr_edge_escape_roll_ability" class="tf"> 
                                        <option value="none">none</option>
                                        <option value="STR">STR</option>
                                        <option value="DEX">DEX</option>
                                        <option value="FIT">FIT</option>
                                        <option value="INT">INT</option>
                                        <option value="WILL">WILL</option>
                                        <option value="PER">PER</option>
                                        <option value="ATT">ATT</option>
                                        <option value="LUCK">LUCK</option>
                                        <option value="MA">MA</option>
                                        </select></span>
                                        <h6>Success Effect:</h6><span class="tfc"><input type="text" class="tf" name="attr_edge_escape_roll_success_effect" /></span>
                                    </div>
                                </span>
                                <span>
                                    <input type="checkbox" class="expandbox"/><div class="expandbox expandboxvisual expandboxopened">&minus;</div><div class="expandbox expandboxvisual expandboxclosed">&plus;</div><h5>Speed:</h5><span class="tfc"><input type="text" class="ltf" name="attr_edge_speed" value="n/a" readonly /></span>
                                    <div class="expandboxopened">
                                        <span class="tfc"><select name="attr_edge_speed_feet_measure" class="fptf"> 
                                        <option value="feet">Feet/BT:</option>
                                        <option value="yards">Yards/BT:</option>
                                        </select><select name="attr_edge_speed_feet_option" class="fptf">
                                        <option value="n/a">n/a</option>
                                        <option value="multiply">score ×</option>
                                        <option value="divide">score ÷</option>
                                        </select><input type="text" class="tptf" name="attr_edge_speed_feet_value" value="1" /></span>
                                        <h6>MPH:</h6><span class="tfc"><select name="attr_edge_speed_mph_option" class="htf"> 
                                        <option value="n/a">n/a</option>
                                        <option value="multiply">score ×</option>
                                        <option value="divide">score ÷</option>
                                        </select><input type="text" class="htf" name="attr_edge_speed_mph_value" value="1" /></span>
                                        <h6>Movement Name:</h6><span class="tfc"><input type="text" class="tf" name="attr_edge_speed_movement_type" value="Edge" /></span>
                                    </div>
                                </span>
                                <span>
                                    <input type="checkbox" class="expandbox"/><div class="expandbox expandboxvisual expandboxopened">&minus;</div><div class="expandbox expandboxvisual expandboxclosed">&plus;</div><h5>Shapeshift:</h5><span class="tfc"></span>
                                    <div class="expandboxopened">
                                        <h6 style="width:45px">STR:</h6><span class="tfc"><select name="attr_edge_shapeshift_str_option" class="htf"> 
                                        <option value="+">+</option>
                                        <option value="-">-</option>
                                        <option value="=">=</option>
                                        </select><input type="text" class="htf" name="attr_edge_shapeshift_str_value" value="0" /></span>
                                        <h6 style="width:45px">DEX:</h6><span class="tfc"><select name="attr_edge_shapeshift_dex_option" class="htf"> 
                                        <option value="+">+</option>
                                        <option value="-">-</option>
                                        <option value="=">=</option>
                                        </select><input type="text" class="htf" name="attr_edge_shapeshift_dex_value" value="0" /></span>
                                        <h6 style="width:45px">FIT:</h6><span class="tfc"><select name="attr_edge_shapeshift_fit_option" class="htf"> 
                                        <option value="+">+</option>
                                        <option value="-">-</option>
                                        <option value="=">=</option>
                                        </select><input type="text" class="htf" name="attr_edge_shapeshift_fit_value" value="0" /></span>
                                        <h6 style="width:45px">INT:</h6><span class="tfc"><select name="attr_edge_shapeshift_int_option" class="htf"> 
                                        <option value="+">+</option>
                                        <option value="-">-</option>
                                        <option value="=">=</option>
                                        </select><input type="text" class="htf" name="attr_edge_shapeshift_int_value" value="0" /></span>
                                        <h6 style="width:45px">WILL:</h6><span class="tfc"><select name="attr_edge_shapeshift_will_option" class="htf"> 
                                        <option value="+">+</option>
                                        <option value="-">-</option>
                                        <option value="=">=</option>
                                        </select><input type="text" class="htf" name="attr_edge_shapeshift_will_value" value="0" /></span>
                                        <h6 style="width:45px">PER:</h6><span class="tfc"><select name="attr_edge_shapeshift_per_option" class="htf"> 
                                        <option value="+">+</option>
                                        <option value="-">-</option>
                                        <option value="=">=</option>
                                        </select><input type="text" class="htf" name="attr_edge_shapeshift_per_value" value="0" /></span>
                                        <h6 style="width:45px">ATT:</h6><span class="tfc"><select name="attr_edge_shapeshift_att_option" class="htf"> 
                                        <option value="+">+</option>
                                        <option value="-">-</option>
                                        <option value="=">=</option>
                                        </select><input type="text" class="htf" name="attr_edge_shapeshift_att_value" value="0" /></span>
                                        <h6 style="width:45px">LUCK:</h6><span class="tfc"><select name="attr_edge_shapeshift_luck_option" class="htf"> 
                                        <option value="+">+</option>
                                        <option value="-">-</option>
                                        <option value="=">=</option>
                                        </select><input type="text" class="htf" name="attr_edge_shapeshift_luck_value" value="0" /></span>
                                        <h6 style="width:45px">MA:</h6><span class="tfc"><select name="attr_edge_shapeshift_ma_option" class="htf"> 
                                        <option value="+">+</option>
                                        <option value="-">-</option>
                                        <option value="=">=</option>
                                        </select><input type="text" class="htf" name="attr_edge_shapeshift_ma_value" value="0" /></span>
                                        <h6>Skill Modifier:</h6><span class="tfc"><input type="text" class="tf" name="attr_edge_shapeshift_skill_modifier" value="0" /></span>
                                    </div>
                                </span>
                                <h5>Active:</h5><span class="tfc"><input type="checkbox" class="invisible hidesothers1" name="attr_edge_shapeshift_form_exists"/><input type="checkbox" class="invisible hidesothers2" name="attr_edge_speed_exists"/><input type="text" class="ltf hideifhidesothers1checked hideifhidesothers2checked" value="n/a" readonly /><input type="checkbox" name="attr_edge_shapeshift_form_activity" class="edgecheckbox hideifhidesothers1and2notchecked" /></span>
                                <h5>Description:</h5>
                                <textarea class="ta" name="attr_edge_description"></textarea>
                            </div>
                        </div>   
                    </div>
                </fieldset>
            </div>
        </div>
        <div class="col">
            <h2>Spells</h2>
            <div class="absposhelper">
                <fieldset class="repeating_spells">
                    <div class="row">
                        <div>
                            <input type="checkbox" class="edgebartouch" name="attr_edge_maximized" />
                            <div class="edgebarvisual"><input type="text" class="edgebarltf bar-header" name="attr_name" value="Click to edit" readonly/></div>
                            <div class="edgebarcontent">
                                <h5>Name:</h5><span class="tfc"><input type="text" class="tf" name="attr_name" /></span>
                                <h5>Description:</h5>
                                <textarea class="ta" name="attr_description" placeholder="Ideally, I will eventually revisit & expand how this sheet handles spells & magic.  As things stand, magic support is currently “bare bones”."></textarea>
                            </div>
                        </div>   
                    </div>
                </fieldset>
            </div>
        </div>
        <div class="col">
            <h2>Flaws</h2>
            <div class="absposhelper">
                <fieldset class="repeating_flaws">
                    <div class="row">
                        <input type="text" class="invisible" name="attr_flaw_roll_ability_score" value="0" />
                        <input type="text" class="invisible" name="attr_flaw_roll_modifier" value="0" />
                        <input type="checkbox" class="invisible hidesothers1" name="attr_flaw_roll_set"/>
                        <input type="text" class="edgebarst" name="attr_bar_flaw_damage" value="" readonly />
                        <button class="barbutton2 hideifhidesothers1notchecked" type='roll' value='&{template:main} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}+@{flaw_roll_modifier}}]]}} {{character_name=@{character_name}}} {{score_name=@{flaw_name}}} {{score=[[@{flaw_roll_ability_score}]]}} {{inc_dm=[[0]]}}'></button>
                        <input type="checkbox" class="edgebartouch" name="attr_flaw_maximized" />
                        <div class="edgebarvisual"><textarea class="edgebarlta bar-header" name="attr_flaw_name" value="Click to edit" wrap="soft" readonly/></textarea><span class="edgebarltf bar-flawdataspace"></span></div>
                        <div class="edgebarcontent">
                            <h5>Name:</h5><span class="tfc"><input type="text" class="tf" name="attr_flaw_name" /></span>
                            <span>
                                <input type="checkbox" class="expandbox"/><div class="expandbox expandboxvisual expandboxopened">&minus;</div><div class="expandbox expandboxvisual expandboxclosed">&plus;</div><h5>Roll:</h5><span class="tfc"><input type="text" class="ltf" name="attr_flaw_roll" value="none" readonly /></span> 
                                <div class="expandboxopened">
                                    <h6>Ability:</h6><span class="tfc"><select name="attr_flaw_roll_ability" class="tf"> 
                                    <option value="none">none</option>
                                    <option value="WILL">WILL</option>
                                    <option value="Humanity<50">Amount Humanity is below 50</option>
                                    <option value="STR">STR</option>
                                    <option value="DEX">DEX</option>
                                    <option value="FIT">FIT</option>
                                    <option value="INT">INT</option>
                                    <option value="PER">PER</option>
                                    <option value="ATT">ATT</option>
                                    <option value="LUCK">LUCK</option>
                                    <option value="MA">MA</option>
                                    </select></span>
                                    <h6>Modify using Humanity:</h6><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_flaw_roll_modified" /></span>
                                </div>
                            </span>
                            <span>
                                <input type="checkbox" class="expandbox"/><div class="expandbox expandboxvisual expandboxopened">&minus;</div><div class="expandbox expandboxvisual expandboxclosed">&plus;</div><h5>Damage:</h5><span class="tfc"><input type="text" class="ltf" name="attr_flaw_damage" value="none" readonly /></span> 
                                <div class="expandboxopened">
                                    <h6>Value:</h6><span class="tfc"><input type="text" class="tf" name="attr_flaw_damage_value" /></span>
                                    <h6>+/- per 10 Humanity:</h6><span class="tfc"><input type="text" class="tf" name="attr_flaw_damage_modifier" /></span>
                                </div>
                            </span>
                            <h5>Description:</h5>
                            <textarea class="ta" name="attr_flaw_description"></textarea>
                        </div>
                    </div>
                </fieldset>
            </div>
        </div>
    </div>
    <br><h1>Skills</h1><br>
    <div class="table">
        <div class="col">
            <div class="row">
                <div class="repemulator">
                    <button class="barbutton1 ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{luck_as_a_skill}+@{speed}+0)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{luck_as_a_skill}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=Luck As A Skill}} {{score=@{luck_as_a_skill}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=0}}'></button>
                    <button class="barbutton2" type='roll' value='&{template:main} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}}]]}} {{character_name=@{character_name}}} {{score_name=Luck As A Skill}} {{score=[[@{luck_as_a_skill}]]}} {{inc_dm=[[0]]}}'></button>
                    <div class="edgebarvisual"><input type="text" class="edgebarltf bar-score" name="attr_luck_as_a_skill" value="0" readonly/><input type="text" class="edgebarltf bar-header" value="Luck As A Skill" readonly/><span class="edgebarltf bar-doublebuttonspace"></span></div>
                </div>
            </div>
        </div>
        <div class="col">
            <div class="row">
                <div class="repemulator">
                    <button class="barbutton1 ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{dexterity_rolled}+@{speed}+1000)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{dexterity_rolled}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=Hand-To-Hand}} {{score=@{dexterity_rolled}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=1000}}'></button>
                    <button class="barbutton2" type='roll' value='&{template:main} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}+@{shapeshift_skill_modifier}}]]}} {{character_name=@{character_name}}} {{score_name=Hand-To-Hand}} {{score=[[@{dexterity_rolled}]]}} {{inc_dm=[[0]]}} {{ability_loss_modifier=[[0]]}} {{shapeshift_skill_modifier=[[@{shapeshift_skill_modifier}]]}}'></button>
                    <div class="edgebarvisual"><input type="text" class="edgebarltf bar-score" name="attr_dexterity_rolled" value="0" readonly/><input type="text" class="edgebarltf bar-header" value="Hand-To-Hand" readonly/><span class="edgebarltf bar-doublebuttonspace"></span></div>
                </div>
            </div>
        </div>
        <div class="col">
            <div class="row">
                <div class="repemulator">
                    <button class="barbutton1 ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{language_native_score}+@{speed}+0)*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{language_native_score}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=@{language_native_name}}} {{score=@{language_native_score}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=0}}'></button>
                    <button class="barbutton2" type='roll' value='&{template:main} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}+@{intellect_loss_modifier}+@{shapeshift_skill_modifier}}]]}} {{character_name=@{character_name}}} {{score_name=@{language_native_name}}} {{score=[[@{language_native_score}]]}} {{inc_dm=[[0]]}} {{ability_loss_modifier=[[@{intellect_loss_modifier}]]}} {{shapeshift_skill_modifier=[[@{shapeshift_skill_modifier}]]}}'></button>
                    <input type="checkbox" class="edgebartouch" name="attr_language_native_maximized" />
                    <div class="edgebarvisual"><input type="text" class="edgebarltf bar-score" name="attr_language_native_score" value="30" readonly/><input type="text" class="edgebarltf bar-header" name="attr_language_native_name" value="Language (Native)" readonly/><span class="edgebarltf bar-doublebuttonspace"></span></div>
                    <div class="edgebarcontent">
                        <h5>Language:</h5><span class="tfc"><input type="text" class="tf" name="attr_language_native_brackets" value="Native" /></span>
                        <h5>Score:</h5><span class="tfc"><input type="text" class="tf" name="attr_language_native_score" value="30"/></span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="table">
        <div class="absposhelper">
            <fieldset class="repeating_skills">
                <div class="row">
                    <input type="text" class="invisible" name="attr_ability_loss_modifier" value="0" />
                    <div>
                        <input type="checkbox" class="invisible hidesothers1" name="attr_damage_included_in_roll" />
                        <button class="barbutton1 ib" type='roll' value='&{template:individualinitiative} {{initiative=[[(@{skill_score}+@{speed}+@{skill_combat_skill})*@{initiative_rules_normal} + ((1d10cs<0cf>11*10)+@{skill_score}+@{speed})*@{initiative_rules_streetvelocity} + (1d100cs<0cf>101+@{dexterity_rolled}+@{perception_rolled}+@{speed})*@{initiative_rules_houseruled} &{tracker}]]}} {{dexterity_rolled=@{dexterity_rolled}}} {{perception_rolled=@{perception_rolled}}} {{initiative_rules=[[@{initiative_rules}]]}} {{character_name=@{character_name}}} {{score_name=@{name}}} {{score=@{skill_score}}} {{speed_edge=@{speed}}} {{edge_or_combat_skill=@{skill_combat_skill}}}'></button>
                        <button class="barbutton2" type='roll' value='&{template:main} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}+@{ability_loss_modifier}+@{shapeshift_skill_modifier}}]]}} {{character_name=@{character_name}}} {{score_name=@{name}}} {{score=[[@{skill_score}]]}} {{inc_dm=[[0]]}} {{ability_loss_modifier=[[@{ability_loss_modifier}]]}} {{shapeshift_skill_modifier=[[@{shapeshift_skill_modifier}]]}}'></button>
                        <input type="checkbox" class="edgebartouch" name="attr_skill_maximized" />
                        <div class="edgebarvisual"><input type="text" class="edgebarltf bar-score" name="attr_skill_score" value="" readonly/><input type="text" class="edgebarltf bar-header" name="attr_name" value="Click to edit" readonly/><span class="edgebarltf bar-doublebuttonspace"></span></div>
                        <div class="edgebarcontent">
                            <h5>Name:</h5><span class="tfc"><input type="checkbox" class="invisible greenborderothers1" name="attr_name_keyname"/><input type="text" class="tf greenborderifgreenborderothers1checked" name="attr_name" /></span>
                            <h5>Score:</h5><span class="tfc"><input type="text" class="tf" name="attr_skill_score" value="0" /></span>
                            <h5>Base:</h5><span class="tfc"><select name="attr_skill_base" class="tf"> 
                            <option value="NONE">NONE</option>
                            <option value="STR">STR</option>
                            <option value="DEX">DEX</option>
                            <option value="(STR+DEX)÷2">(STR+DEX)÷2</option>
                            <option value="FIT">FIT</option>
                            <option value="INT">INT</option>
                            <option value="WILL">WILL</option>
                            <option value="PER">PER</option>
                            <option value="ATT">ATT</option>
                            <option value="LUCK">LUCK</option>
                            <option value="MA">MA</option>
                            </select></span>
                            <h5>Is a combat skill:</h5><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_skill_combat_skill" value="1000" /></span>
                            <span class="invisible"><h6>Linked Weapon:</h6><span class="tfc"><input type="text" class="tf" name="attr_linked_weapon" readonly/></span></span>
                            <h5>Notes:</h5>
                            <textarea class="ta" name="attr_skill_notes"></textarea>
                            <button type="action" class="longactionbutton">Make Job Skill<input type="checkbox" class="buttonfixer" name="attr_setjobskillbutton"/></button>
                        </div>
                    </div>   
                </div>
            </fieldset>
        </div>
    </div>
    <br><h1>Inventory</h1><br>
    <div class="table">
        <div class="col">
            <h2>Weapons (Attacks)</h2>
            <div class="absposhelper">
                <fieldset class="repeating_weapons">
                    <div class="row">
                        <input type="checkbox" class="invisible hidesothers1" name="attr_show_ammo" />
                        <input type="checkbox" class="invisible transparentothers1" name="attr_carried" checked/>
                        <input type="text" class= "invisible" class="tf" name="attr_matched_to_skill" value="0" />
                        <span class="barbutton1 hideifhidesothers1notchecked"><input type="text" class="stf slashbookend" name="attr_ammo_loaded" />/<input type="text" class="stf slashbookend" name="attr_ammo_capacity"/></span>
                        <button class="barbutton2" type='roll' value='&{template:main} {{standard_roll=[[{1d100cs<1cf>96+?{Modifier|0}+@{ability_loss_modifier}+(@{shapeshift_skill_modifier}*@{matched_to_skill})}]]}} {{damage_total=[[ @{dp} + {@{inc_claws}*{round(@{claws}*0.2)}} + {@{inc_hth}*@{base_hth_damage}} + { @{inc_dm}*{floor({@{csr}-{1d100cs<1cf>96+?{Modifier|0}+@{ability_loss_modifier}+(@{shapeshift_skill_modifier}*@{matched_to_skill})+@{weapon_modifier}}}/10)} } ]] }} {{damage_without_modifier=[[ @{dp} + {@{inc_claws}*{round(@{claws}*0.2)}} + {@{inc_hth}*@{base_hth_damage}} ]] }} {{character_name=@{character_name}}} {{score_name=@{name}}} {{score=[[@{csr}]]}} {{ability_loss_modifier=[[@{ability_loss_modifier}]]}} {{shapeshift_skill_modifier=[[(@{shapeshift_skill_modifier}*@{matched_to_skill})]]}} {{damage_potential=[[@{dp}]]}} {{damage_type=@{damage_type}}} {{substance=@{substance}}} {{weapon_modifier=[[@{weapon_modifier}]]}} {{inc_dm=[[@{inc_dm}]]}} {{targets_max=[[@{targets_max}]]}} {{targets_hit= [[{[[@{targets_roll}]], [[@{targets_max}]]}dh1]] }} {{enchanted=[[@{enchanted}]]}} {{inc_hth=[[@{inc_hth}]]}} {{hth=@{base_hth_damage}}} {{inc_claws=[[@{inc_claws}]]}} {{claws=@{claws}}} '></button>
                        <input type="checkbox" class="edgebartouch" name="attr_maximized" />
                        <div class="edgebarvisual transparentiftransparentothers1notchecked"><input type="text" class="edgebarltf bar-header" name="attr_name" value="Click to edit" readonly/></div>
                        <div class="edgebarcontent">
                            <input type="checkbox" class="invisible hidesothers1" name="attr_lock_damage_value" />
                            <input type="checkbox" class="invisible hidesothers2" name="attr_show_rounds_fired" />
                            <input type="text" class= "invisible" class="tf" name="attr_targets_max" value="0" />
                            <input type="text" class= "invisible" class="tf" name="attr_targets_roll" value="0" />
                            <input type="text" class= "invisible" class="tf" name="attr_ability_loss_modifier" value="0" />
                            <h5>Name:</h5><span class="tfc"><input type="text" class="tf" name="attr_name" /></span>
                            <h5>CSR:</h5><span class="tfc"><input type="text" class="tf" name="attr_csr_input" placeholder="score or ability/edge/skill name" /></span>
                            <input type="checkbox" class="invisible hidesothers4" name="attr_csr" value="-1"/>
                            <h6>Value:</h6><span class="tfc hideifhidesothers4checked"><input type="text" class="tf" name="attr_csr" value="0" readonly /></span><span class="tfc hideifhidesothers4notchecked"><input type="text" class="tf" value="Couldn't find match" readonly /></span>
                            <h5>Modifier:</h5><span class="tfc"><input type="text" class="tf" name="attr_weapon_modifier" value="0" /></span>
                            <h5>Damage Potential:</h5><span class="tfc"><select name="attr_dp_input" class="tf"> 
                            <option value="Set Value">Set Value</option>
                            <option value="HTH">HTH</option>
                            <option value="HTHx2">HTHx2</option>
                            <option value="CSR">CSR</option>
                            </select></span>
                            <input type="checkbox" class="invisible hidesothers5" name="attr_show_damage_divider" value="1"/>
                            <span class ="hideifhidesothers5notchecked"><h6>Divided by:</h6><span class="tfc"><input type="text" class="tf" name="attr_damage_divider" value="1" /></span></span>
                            <span class ="hideifhidesothers1checked"><h6>Value:</h6><span class="tfc"><input type="text" class="tf" name="attr_dp" value="0" /></span></span>
                            <span class ="hideifhidesothers1notchecked"><h6>Value:</h6><span class="tfc"><input type="text" class="tf" name="attr_dp" value="0" readonly /></span></span>
                            <h5>Damage Type:</h5><span class="tfc"><select name="attr_damage_type" class="tf"> 
                                <option value="SP">Survival Points</option>
                                <option value="STR">STR</option>
                                <option value="DEX">DEX</option>
                                <option value="FIT">FIT</option>
                                <option value="INT">INT</option>
                                <option value="WILL">WILL</option>
                                <option value="PER">PER</option>
                                <option value="ATT">ATT</option>
                                <option value="LUCK">LUCK</option>
                                <option value="MA">MA</option>
                            </select></span>
                            <h5>Substance:</h5><span class="tfc"><input type="text" class="tf" name="attr_substance" /></span>
                            <input type="checkbox" class="invisible hidesothers6" name="attr_show_claws_instead_of_hth" value="1" />
                            <span class ="hideifhidesothers6checked"><h5>Add HTH:</h5><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_inc_hth" value="1" /></span></span>
                            <span class ="hideifhidesothers6notchecked"><h5>Add Claws÷5:</h5><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_inc_claws" value="1" /></span></span>
                            <h5>Add Damage Modifier</h5><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_inc_dm" value="1" checked/></span>
                            <h5>Target:</h5><span class="tfc"><select name="attr_target" class="tf"> 
                            <option value="Single">Single</option>
                            <option value="Semiautomatic">Multiple (Semiautomatic)</option>
                            <option value="Automatic">Multiple (Automatic)</option>
                            </select></span>
                            <span class ="hideifhidesothers2notchecked"><h5>No. Rounds Being Fired:</h5><span class="tfc"><input type="text" class="tf" name="attr_rounds_fired" /></span></span>
                            <h5>Ammo:</h5><span class="tfc"><span class="rightfloat"><input type="text" class="stf slashbookend" name="attr_ammo_loaded" />/<input type="text" class="stf slashbookend" name="attr_ammo_capacity"/></span></span></span>
                            <h5>Range:</h5><span class="tfc"><input type="text" class="tf" name="attr_range" /></span>
                            <h5>Hide:</h5><span class="tfc"><span class="rightfloat"><input type="text" class="stf" name="attr_hide" /><button class="bigbutton" type='roll' value='&{template:main} {{character_name=@{character_name}}} {{score_name=Hide @{name}}} {{score=[[@{hide}]]}} {{standard_roll=[[{1d10cs<1cf>11}]]}} {{inc_dm=[[0]]}}'></button></span></span>
                            <h5>Legal:</h5><span class="tfc"><select name="attr_legal" class="tf"> 
                            <option value="yes">Yes</option>
                            <option value="yes_suspect">Yes (Suspect)</option>
                            <option value="no">No</option>
                            <option value="no_felony">No (Felony)</option>
                            </select></span>
                            <h5>Enchanted:</h5><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_enchanted" value="1" /></span>
                            <input type="checkbox" class="invisible hidesothers3" name="attr_enchanted" value="1" />
                            <!-- The option to subtract WILL was broken during the last major rework, i've just hidden it for now until it can be revisited -->
                            <span class ="invisible hideifhidesothers3notchecked"><h6>Subtract WILL from Modifier:</h6><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_subtract_will" /></span></span>
                            <span class ="hideifhidesothers3notchecked"><h6>Attacker CSR modifier:</h6><span class="tfc"><input type="text" class="tf" name="attr_attacker_csr_modifier" value="0" /></span></span>
                            <span class ="hideifhidesothers3notchecked"><h6>Active/Held:</h6><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_active" /></span></span>
                            <h5>Carried:</h5><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_carried" checked/></span>
                            <h5>Notes:</h5>
                            <textarea class="ta" name="attr_notes"></textarea>
                        </div>
                    </div>
                </fieldset>
            </div>
        </div>
        <div class="col">
            <h2>Wearables</h2>
            <div class="absposhelper">
                <fieldset class="repeating_wearables">
                    <div class="row">
                        <input type="checkbox" class="invisible transparentothers1 hidesothers1" name="attr_carried" checked/>
                        <input type="checkbox" class="barbutton2 hideifhidesothers1notchecked" name="attr_worn" checked/>
                        <input type="checkbox" class="edgebartouch" name="attr_maximized" />
                        <div class="edgebarvisual transparentiftransparentothers1notchecked"><input type="text" class="edgebarltf bar-header" name="attr_name" value="Click to edit" readonly/><span class="edgebarltf bar-checkboxspace"></span></div>
                        <div class="edgebarcontent">
                            <input type="checkbox" class="invisible transparentothers1 hidesothers1" name="attr_carried" checked/>
                            <h5>Name:</h5><span class="tfc"><input type="text" class="tf" name="attr_name" /></span>
                            <h5>Attacker CSR Modifier:</h5><span class="tfc"><input type="text" class="tf" name="attr_attacker_csr_modifier" value="0" /></span>
                            <h5>Add:</h5><span class="tfc"><input type="text" class="htf" name="attr_add_value" value="0" /><select name="attr_add_ability" class="htf"> 
                            <option value="attractiveness">ATT</option>
                            <option value="strength">STR</option>
                            <option value="dexterity">DEX</option>
                            <option value="fitness">FIT</option>
                            <option value="intellect">INT</option>
                            <option value="will">WILL</option>
                            <option value="perception">PER</option>
                            <option value="luck">LUCK</option>
                            <option value="magic_ability">MA</option>
                            <option value="humanity">Humanity</option>
                            </select></span>
                            <h5>Root Magic:</h5><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_root_magic"/></span>
                            <h5>Quantity:</h5><span class="tfc"><input type="text" class="tf" name="attr_quantity" value="1" /></span>
                            <h5 class="hideifhidesothers1notchecked">Worn:</h5><span class="tfc hideifhidesothers1notchecked"><input type="checkbox" class="edgecheckbox" name="attr_worn" checked/></span>
                            <h5>Carried:</h5><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_carried" checked/></span>
                            <h5>Notes:</h5>
                            <textarea class="ta" name="attr_notes"></textarea>
                        </div>
                    </div>
                </fieldset>
            </div>
        </div>
        <div class="col">
            <h2>Other</h2>
            <div class="absposhelper">
                <fieldset class="repeating_miscellaneous">
                    <div class="row">
                        <input type="checkbox" class="invisible transparentothers1" name="attr_carried" checked/>
                        <span class="barbutton2"><input type="text" class="stf" name="attr_quantity" placeholder="1" /></span>
                        <input type="checkbox" class="edgebartouch" name="attr_maximized" />
                        <div class="edgebarvisual transparentiftransparentothers1notchecked"><input type="text" class="edgebarltf bar-header" name="attr_name" value="Click to edit" readonly/></div>
                        <div class="edgebarcontent">
                            <h5>Name:</h5><span class="tfc"><input type="text" class="tf" name="attr_name" /></span>
                            <h5>Quantity:</h5><span class="tfc"><input type="text" class="tf" name="attr_quantity" placeholder="1" /></span>
                            <h5>Carried:</h5><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_carried" checked/></span>
                            <h5>Notes:</h5>
                            <textarea class="ta" name="attr_notes"></textarea>
                        </div>
                    </div>
                </fieldset>
            </div>
        </div>
    </div>
    <br>
    <div class="table">
    <div class="col">
            <div class="cel">
                <h5>Cash $:</h5><span class="tfc"><input type="text" class="tf" name="attr_cash" value="0"/></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>Savings $:</h5><span class="tfc"><input type="text" class="tf" name="attr_savings" value="0"/></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>Root Magic Items Worn:</h5><span class="tfc"><span class="rightfloat"><input type="text" class="stf slashbookend" name="attr_root_magic_worn" value="0" readonly/>/<input type="text" class="stf slashbookend" value="3" readonly/></span></span>
            </div>
            <div class="cel">
                <h5>Total Attacker CSR Modifier:</h5><span class="tfc"><input type="text" class="tf" name="attr_attacker_csr" value="0" readonly/></span>
            </div>    
        </div>
    </div>
    <br><h1>Movement</h1><br>
    <div class="table">
        <div class="col">
            <input type="checkbox" class="invisible hidesothers1" name="attr_extra_movement_active" value="1"/>
            <div class="cel">
                <h5>Walking:</h5><span class="tfc"><input type="text" class="tf" name="attr_movement_walking" value="" readonly/></span>
            </div>
            <div class="cel">
                <h5>Crawling:</h5><span class="tfc"><input type="text" class="tf" name="attr_movement_crawling_prone" value="" readonly/></span>
            </div>
            <div class="cel">
                <h5>Climbing:</h5><span class="tfc"><input type="text" class="tf" name="attr_movement_climbing" value="" readonly/></span>
            </div>
            <div class="cel hideifhidesothers1notchecked">
                <input type="text" class="h5f" name="attr_active_extra_movement_name" readonly/><span class="tfc"><input type="text" class="tf" name="attr_active_extra_movement_value" readonly/></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>Jogging:</h5><span class="tfc"><input type="text" class="tf" name="attr_movement_jogging" value="" readonly/></span>
            </div>
            <div class="cel">
                <h5>Swimming:</h5><span class="tfc"><input type="text" class="tf" name="attr_movement_swimming" value="" readonly/></span>
            </div>
            <div class="cel">
                <h5>Standing Jump:</h5><span class="tfc"><input type="text" class="tf" name="attr_movement_jump_standing" value="" readonly/></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>Running:</h5><span class="tfc"><input type="text" class="tf" name="attr_movement_running" value="" readonly/></span>
            </div>
            <div class="cel">
                <h5>Backstroke:</h5><span class="tfc"><input type="text" class="tf" name="attr_movement_backstroke" value="" readonly/></span>
            </div>
            <div class="cel">
                <h5>Running Jump:</h5><span class="tfc"><input type="text" class="tf" name="attr_movement_jump_running" value="" readonly/></span>
            </div>
        </div>
    </div>
    <br><h1>Healing</h1><br>
    <div class="table">
        <div class="col">
            <div class="cel">
                <h5>SP:</h5><span class="tfc"><input type="text" class="tf" name="attr_healing_normal" value="" readonly/></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>Basic Ability:</h5><span class="tfc"><input type="text" class="tf" name="attr_healing_ability_damage" value="" readonly/></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>Death Tally:</h5><span class="tfc"><span class="rightfloat"><input type="text" class="stf slashbookend" name="attr_deaths" value="0" />/<input type="text" class="stf slashbookend" name="attr_fitness_max" value="" readonly/></span></span>
            </div>
        </div>
    </div>   
    <br><h1>Carrying</h1><br>
    <div class="table">
        <div class="col">
            <div class="cel">
                <h5>Comfortable:</h5><span class="tfc"><input type="text" class="tf" name="attr_carrying_comfortably" value="" readonly/></span>
            </div>
            <div class="cel">
                <h5>Swimming:</h5><span class="tfc"><input type="text" class="tf" name="attr_carrying_swimming" value="" readonly/></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>DEX Reducing:</h5><span class="tfc"><input type="text" class="tf" name="attr_carrying_causing_penalty" value="" readonly/></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>Dragging/Lifting:</h5><span class="tfc"><input type="text" class="tf" name="attr_dragging" value="" readonly/></span>
            </div>
        </div>
    </div>
    <br><h1>Throwing</h1><br>
    <div class="table">
        <div class="col">
            <div class="cel">
                <h5>Small Objects:</h5><span class="tfc"><input type="text" class="tf" name="attr_throwing" value="" readonly/></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>Spears:</h5><span class="tfc"><input type="text" class="tf" name="attr_throwing_spear" value="" readonly/></span>
            </div>
        </div>
        <div class="col">
            &nbsp;
        </div>
    </div>
    <br><h1>Miscellaneous</h1><br>
    <div class="table">
        <div class="col">
            <div class="cel">
                <h5>Evade Attempts:</h5><span class="tfc"><input type="text" class="tf" name="attr_evade_attempts" value="" readonly/></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>Average Day Humanity +/-:</h5><span class="tfc"><input type="text" class="tf" name="attr_net_humanity_change" value=""/></span>
            </div>
        </div>
        <div class="col">
            &nbsp;
        </div>
    </div>
    <br><h1>Income</h1><br>
    <div class="table">
        <div class="col">
            <div class="cel">
                <h5>Job Skill:</h5><span class="tfc"><input type="text" class="tf" name="attr_job_skill_name" value="none" readonly/></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>Monthly Expenses $:</h5><span class="tfc"><input type="text" class="tf" name="attr_monthly_expenses" value="0" /></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>Owns the Business:</h5><span class="tfc"><input type="checkbox" class="edgecheckbox" name="attr_business_owner" /></span>
            </div>
        </div>
    </div>
    <input type="checkbox" class="invisible hidesothers2" name="attr_business_owner" />
    <div class="table hideifhidesothers2notchecked">
        <div class="col">
            <div class="cel">
                <h5>LUCK auto-success $:</h5><span class="tfc"><input type="text" class="tf" name="attr_luck_auto_success_income" value="0" readonly/></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>LUCK auto-failure $:</h5><span class="tfc"><input type="text" class="tf" name="attr_luck_auto_failure_income" value="0" readonly/></span>
            </div>
        </div>
        <div class="col">
            <div class="cel">
                <h5>LUCK success $:</h5><span class="tfc"><input type="text" class="tf" name="attr_luck_success_income" value="0" readonly/></span>
            </div>
        </div>
    </div>
    <div class="table">
        <div class="col">
            &nbsp;
        </div>
        <div class="col">
            &nbsp;
        </div>
        <div class="col">
            <div class="cel">
                <h5>Normal Weekly $:</h5><span class="tfc"><input type="text" class="tf" name="attr_weekly_income" value="0" readonly/></span>
            </div>
        </div>
    </div>
</div>
<br>
<div class="comment">For a quick start guide, features and known issues please visit the wiki page <button type="roll" name="roll_none" class="hyperlink" title="This will post a URL in the chat" value="[Character Sheet Wiki Page: https://wiki.roll20.net/NightLife_Character_Sheet](https://wiki.roll20.net/NightLife_Character_Sheet)"></button>.</div>

<span class="invisible">
    <rolltemplate class="sheet-rolltemplate-individualinitiative">
        <b><div class="sheet-rolltemplate-header">{{character_name}}'s</div>
        <div class="sheet-rolltemplate-initiative-header">Initiative {{#rollTotal() initiative_rules 1}}(Street Velocity){{/rollTotal() initiative_rules 1}}{{#rollTotal() initiative_rules 2}}(Houseruled){{/rollTotal() initiative_rules 2}}</div></b>
        <div class="sheet-template-row"><span>Result: </span>{{initiative}}</div>
        <span class ="sheet-rolltemplate-italic">
            <div class="sheet-template-row">Includes Modifiers</div>
            {{#^rollTotal() initiative_rules 2}}
            <div class="sheet-template-row"><span>{{score_name}}:</span> <span class="sheet-noinlineroll">{{score}}</span></div>
            {{/^rollTotal() initiative_rules 2}}
            {{#rollTotal() initiative_rules 2}}
            <div class="sheet-template-row"><span>Dexterity:</span> <span class="sheet-noinlineroll">{{dexterity_rolled}}</span></div>
            <div class="sheet-template-row"><span>Perception:</span> <span class="sheet-noinlineroll">{{perception_rolled}}</span></div>
            {{/rollTotal() initiative_rules 2}}
            <div class="sheet-template-row"><span>Speed Edge:</span> <span class="sheet-noinlineroll">{{speed_edge}}</span></div>
            {{#rollTotal() initiative_rules 0}}
            <div class="sheet-template-row"><span>Edge or Combat Skill:</span> <span class="sheet-noinlineroll">{{edge_or_combat_skill}}</span></div>
            {{/rollTotal() initiative_rules 0}}
        </span>
    </rolltemplate>    

    <rolltemplate class="sheet-rolltemplate-main">
        <b><div class="sheet-rolltemplate-header">{{character_name}}'s</div>
        <div class="sheet-rolltemplate-header">{{score_name}}</div></b>
        <!-- Determines roll result one time once and use CSS to hide elements in the rest of the demplate based on the result
            this should make it slightly more human readable then including masses of repeated helper functions -->
        {{#rollTotal() inc_dm 1}} 
            {{#rollWasCrit() damage_total}}
                <div class="sheet-rolltemplate-rollautomaticsuccess"></div>
            {{/rollWasCrit() damage_total}}
            {{#^rollWasCrit() damage_total}}
                {{#^rollWasFumble() damage_total}}
                    {{#^rollLess() damage_total damage_without_modifier}}
                        <div class="sheet-rolltemplate-rollsuccess"></div>
                    {{/^rollLess() damage_total damage_without_modifier}}
                    {{#rollLess() damage_total damage_without_modifier}}
                        <div class="sheet-rolltemplate-rollfailure"></div>
                    {{/rollLess() damage_total damage_without_modifier}}
                {{/^rollWasFumble() damage_total}}
            {{/^rollWasCrit() damage_total}}
            {{#rollWasFumble() damage_total}}
                <div class="sheet-rolltemplate-rollautomaticfailure"></div>
            {{/rollWasFumble() damage_total}}
        {{/rollTotal() inc_dm 1}}
        {{#rollTotal() inc_dm 0}}
            {{#rollWasFumble() standard_roll}}
                <div class="sheet-rolltemplate-rollautomaticfailure"></div>
            {{/rollWasFumble() standard_roll}}
            {{#^rollWasCrit() standard_roll}}
                {{#^rollWasFumble() standard_roll}}
                    {{#rollGreater() standard_roll score}}
                        <div class="sheet-rolltemplate-rollfailure"></div>
                    {{/rollGreater() standard_roll score}}
                    {{#^rollGreater() standard_roll score}}
                    <div class="sheet-rolltemplate-rollsuccess"></div>
                    {{/^rollGreater() standard_roll score}}
                {{/^rollWasFumble() standard_roll}}
            {{/^rollWasCrit() standard_roll}}
            {{#rollWasCrit() standard_roll}}
                <div class="sheet-rolltemplate-rollautomaticsuccess"></div>
            {{/rollWasCrit() standard_roll}}
        {{/rollTotal() inc_dm 0}}
        <!-- Display roll result -->
        <span>Roll: </span>
        {{#rollTotal() inc_dm 0}}
            <span>{{standard_roll}}</span>
        {{/rollTotal() inc_dm 0}}
        {{#rollTotal() inc_dm 1}}
            <span class="rolltemplate-showifrollautomaticsuccess">1</span> 
            <span class="rolltemplate-showifrollsuccess">(Low or Equal)</span> 
            <span class="rolltemplate-showifrollfailure">(High)</span> 
            <span class="rolltemplate-showifrollautomaticfailure">(96 or More)</span> 
        {{/rollTotal() inc_dm 1}}
        vs <span class="sheet-noinlineroll">{{score}}</span>
        <br></br>
        <!-- Success of Failure Text (And dice icon) -->
        <span class="rolltemplate-showifrollautomaticsuccess">
            <div class="sheet-rolltemplate-d10" style="color:#3FB315;">0</div>
            <div style="font-weight: bold;">Automatic Success</div>
        </span> 
        <span class="rolltemplate-showifrollsuccess">
            <div class="sheet-rolltemplate-d10" style="color:darkgreen;">0</div>
            <div style="font-weight: bold;">Success</div>
        </span>
        <span class="rolltemplate-showifrollfailure">
            <div class="sheet-rolltemplate-d10" style="color:darkred;">0</div>
            <div style="font-weight: bold;">Failure</div>
        </span> 
        <span class="rolltemplate-showifrollautomaticfailure">
            <div class="sheet-rolltemplate-d10" style="color:#B31515;">0</div>
            <div style="font-weight: bold;">Automatic Failure</div>
        </span> 
        <!-- Modifier disclosure -->
        <span class ="sheet-rolltemplate-italic">
            {{#rollGreater() ability_loss_modifier 0}}
                <div class="sheet-template-row"><span>Ability Loss Modifier was</span> <span class="sheet-noinlineroll">{{ability_loss_modifier}}</span></div>
            {{/rollGreater() ability_loss_modifier 0}}
            {{#rollGreater() shapeshift_skill_modifier 0}}
                <div class="sheet-template-row"><span>Shapeshift Modifier was</span> <span class="sheet-noinlineroll">{{shapeshift_skill_modifier}}</span></div>
            {{/rollGreater() shapeshift_skill_modifier 0}}
            {{#rollLess() shapeshift_skill_modifier 0}}
                <div class="sheet-template-row"><span>Shapeshift Modifier was</span> <span class="sheet-noinlineroll">{{shapeshift_skill_modifier}}</span></div>
            {{/rollLess() shapeshift_skill_modifier 0}}
            {{#rollGreater() weapon_modifier 0}}
                <div class="sheet-template-row"><span>Weapon Modifier was</span> <span class="sheet-noinlineroll">{{weapon_modifier}}</span></div>
            {{/rollGreater() weapon_modifier 0}}
            {{#rollLess() weapon_modifier 0}}
                <div class="sheet-template-row"><span>Weapon Modifier was</span> <span class="sheet-noinlineroll">{{weapon_modifier}}</span></div>
            {{/rollLess() weapon_modifier 0}}
        </span>
        <!-- Damage -->
        {{#rollGreater() damage_potential 0}}
            <br></br>
            <div class="sheet-template-row"><span>Damage:</span><span class="sheet-noinlineroll"> {{damage_potential}}{{#rollTotal() inc_hth 1}} + {{hth}}{{/rollTotal() inc_hth 1}}{{#rollTotal() inc_claws 1}} + ({{claws}}÷5){{/rollTotal() inc_claws 1}}{{#rollTotal() inc_dm 1}} + (DM){{/rollTotal() inc_dm 1}}</div> 
            <div class="sheet-template-row" style="font-weight: bold;" >= </span>{{#rollTotal() inc_dm 0}}<span class="sheet-noinlineroll">{{/rollTotal() inc_dm 0}}{{damage_total}}{{#rollTotal() inc_dm 0}}</span>{{/rollTotal() inc_dm 0}} {{damage_type}}</div> 
            {{#substance}}
                <span class ="sheet-rolltemplate-italic">
                    <div class="sheet-template-row"><span class="sheet-noinlineroll">{{damage_potential}}</span> is subject to Substance Vulnerability ({{substance}})</div>
                </span>
            {{/substance}}
            {{#rollTotal() enchanted 1}}
                <span class ="sheet-rolltemplate-italic">
                    <div class="sheet-template-row">Weapon is enchanted</div>
                </span>
            {{/rollTotal() enchanted 1}}
        {{/rollGreater() damage_potential 0}}
        <!-- Targets -->
        {{#rollGreater() targets_max 1}}
            <br></br>
            <span>Targets Hit: </span><span class="rolltemplate-showifrollautomaticsuccess rolltemplate-showifrollsuccess">{{targets_hit}}</span><span class="rolltemplate-showifrollautomaticfailure rolltemplate-showifrollfailure">0</span>
        {{/rollGreater() targets_max 1}}
    </rolltemplate>
    <!-- Note that I currently don't specify the name of the skills/abilitys from which the attack score originates, it maybe worth including this in the future -->
</span>

<script type="text/worker">
    // For every ability (except survival points and humanity) sets changed ability, the hidden ability score used for dice rolls, ability loss modifer and ability score displayed over the top of the non-changed score when its being modified by items/shapechanging, alongside some miscellaneous other ability derived variables like luck as a skill
    on("change:strength change:strength_max change:strength_shapeshifted change:strength_item", function() { 
        getAttrs(["strength", "strength_max", "strength_rolled", "strength_loss_modifier", "base_hth_damage", "strength_shapeshifted", "strength_item"], function(values) {                
            let base_hth_damage = values.base_hth_damage;
            let newAttributes = GovernAbility (values.strength, values.strength_max, values.strength_rolled, values.strength_loss_modifier, values.strength_shapeshifted, values.strength_item);
            base_hth_damage = Math.round(newAttributes.ability_rolled/5);
            setAttrs({
                strength: newAttributes.ability,
                strength_rolled: newAttributes.ability_rolled,
                strength_loss_modifier: newAttributes.ability_loss_modifier,
                base_hth_damage: base_hth_damage,
                strength_tempmax: newAttributes.ability_tempmax 
            });
        });
    });
    on("change:dexterity change:dexterity_max change:dexterity_shapeshifted change:dexterity_item", function() { 
        getAttrs(["dexterity", "dexterity_max", "dexterity_rolled", "dexterity_loss_modifier", "dexterity_shapeshifted", "dexterity_item"], function(values) {                
            let newAttributes = GovernAbility (values.dexterity, values.dexterity_max, values.dexterity_rolled, values.dexterity_loss_modifier, values.dexterity_shapeshifted, values.dexterity_item);
            setAttrs({
                dexterity: newAttributes.ability,
                dexterity_rolled: newAttributes.ability_rolled,
                dexterity_loss_modifier: newAttributes.ability_loss_modifier,
                dexterity_tempmax: newAttributes.ability_tempmax 
            });
        });
    });
    on("change:fitness change:fitness_max change:fitness_shapeshifted change:fitness_item", function() { 
        getAttrs(["fitness", "fitness_max", "fitness_rolled", "fitness_loss_modifier", "fitness_shapeshifted", "fitness_item"], function(values) {                
            let newAttributes = GovernAbility (values.fitness, values.fitness_max, values.fitness_rolled, values.fitness_loss_modifier, values.fitness_shapeshifted, values.fitness_item);
            setAttrs({
                fitness: newAttributes.ability,
                fitness_rolled: newAttributes.ability_rolled,
                fitness_loss_modifier: newAttributes.ability_loss_modifier,
                fitness_tempmax: newAttributes.ability_tempmax 
            });
        });
    });
    on("change:intellect change:intellect_max change:intellect_shapeshifted change:intellect_item", function() { 
        getAttrs(["intellect", "intellect_max", "intellect_rolled", "intellect_loss_modifier", "intellect_shapeshifted", "intellect_item"], function(values) {                
            let newAttributes = GovernAbility (values.intellect, values.intellect_max, values.intellect_rolled, values.intellect_loss_modifier, values.intellect_shapeshifted, values.intellect_item);
            setAttrs({
                intellect: newAttributes.ability,
                intellect_rolled: newAttributes.ability_rolled,
                intellect_loss_modifier: newAttributes.ability_loss_modifier,
                intellect_tempmax: newAttributes.ability_tempmax 
            });
        });
    });
    on("change:will change:will_max change:will_shapeshifted change:will_item", function() { 
        getAttrs(["will", "will_max", "will_rolled", "will_loss_modifier", "will_shapeshifted", "will_item"], function(values) {                
            let newAttributes = GovernAbility (values.will, values.will_max, values.will_rolled, values.will_loss_modifier, values.will_shapeshifted, values.will_item);
            setAttrs({
                will: newAttributes.ability,
                will_rolled: newAttributes.ability_rolled,
                will_loss_modifier: newAttributes.ability_loss_modifier,
                will_tempmax: newAttributes.ability_tempmax 
            });
        });
    });
    on("change:perception change:perception_max change:perception_shapeshifted change:perception_item", function() { 
        getAttrs(["perception", "perception_max", "perception_rolled", "perception_loss_modifier", "perception_shapeshifted", "perception_item"], function(values) {                
            let newAttributes = GovernAbility (values.perception, values.perception_max, values.perception_rolled, values.perception_loss_modifier, values.perception_shapeshifted, values.perception_item);
            setAttrs({
                perception: newAttributes.ability,
                perception_rolled: newAttributes.ability_rolled,
                perception_loss_modifier: newAttributes.ability_loss_modifier,
                perception_tempmax: newAttributes.ability_tempmax 
            });
        });
    });
    on("change:attractiveness change:attractiveness_max change:attractiveness_shapeshifted change:attractiveness_item", function() { 
        getAttrs(["attractiveness", "attractiveness_max", "attractiveness_rolled", "attractiveness_loss_modifier", "attractiveness_shapeshifted", "attractiveness_item"], function(values) {                
            let newAttributes = GovernAbility (values.attractiveness, values.attractiveness_max, values.attractiveness_rolled, values.attractiveness_loss_modifier, values.attractiveness_shapeshifted, values.attractiveness_item);
            setAttrs({
                attractiveness: newAttributes.ability,
                attractiveness_rolled: newAttributes.ability_rolled,
                attractiveness_loss_modifier: newAttributes.ability_loss_modifier,
                attractiveness_tempmax: newAttributes.ability_tempmax 
            });
        });
    });
    on("change:luck change:luck_max change:luck_shapeshifted change:luck_item", function() { 
        getAttrs(["luck", "luck_max", "luck_rolled", "luck_shapeshifted", "luck_item"], function(values) {                
            let newAttributes = GovernAbility (values.luck, values.luck_max, values.luck_rolled, 0, values.luck_shapeshifted, values.luck_item);
            
            let luckAsSkill = Math.round( (parseInt(newAttributes.ability_rolled)||0) /5 );
            
            if (luckAsSkill > 20) {
                luckAsSkill = 20;
            }
            
            setAttrs({
                luck: newAttributes.ability,
                luck_rolled: newAttributes.ability_rolled,
                luck_loss_modifier: newAttributes.ability_loss_modifier,
                luck_as_a_skill: luckAsSkill,
                luck_tempmax: newAttributes.ability_tempmax 
            });
        });
    });
    on("change:magic_ability change:magic_ability_max change:magic_ability_shapeshifted change:magic_ability_item", function() { 
        getAttrs(["magic_ability", "magic_ability_max", "magic_ability_rolled", "magic_ability_shapeshifted", "magic_ability_item"], function(values) {                
            let newAttributes = GovernAbility (values.magic_ability, values.magic_ability_max, values.magic_ability_rolled, 0, values.magic_ability_shapeshifted, values.magic_ability_item);
            setAttrs({
                magic_ability: newAttributes.ability,
                magic_ability_rolled: newAttributes.ability_rolled,
                magic_ability_loss_modifier: newAttributes.ability_loss_modifier,
                magic_ability_tempmax: newAttributes.ability_tempmax 
            });
        });
    });
    on("change:street_face change:street_face_max change:will_rolled change:intimidation change:diplomacy change:leadership change:persuasion change:streetwise", function() { 
        getAttrs(["street_face", "street_face_max", "street_face_rolled", "will_rolled", "intimidation", "diplomacy", "leadership", "persuasion", "streetwise"], function(values) {                
            
            let possibleFaceMaxValues = [parseInt(values.will_rolled)||0, parseInt(values.intimidation)||0, parseInt(values.diplomacy)||0, parseInt(values.leadership)||0, parseInt(values.persuasion)||0, parseInt(values.streetwise)||0];
            let highestValue = 0;
            
            for (let i = 0; i < possibleFaceMaxValues.length; i++) { 
                if (possibleFaceMaxValues[i] > highestValue) {
                    highestValue = possibleFaceMaxValues[i];
                }
            }
            
            let newAttributes = GovernAbility (values.street_face, highestValue, values.street_face_rolled, 0, "notshifted");
            
            setAttrs({
                street_face: newAttributes.ability,
                street_face_max: highestValue,
                street_face_rolled: newAttributes.ability_rolled
            });
        });
    });
    function GovernAbility (ability, ability_max, ability_rolled, ability_loss_modifier, ability_shapeshifted, ability_item) {
        
        let original_ability_max = parseInt(ability_max)||0;
        ability_max = original_ability_max;
        ability_item = parseInt(ability_item)||0;
        
        ability_loss_modifier = 0;
        
        if (ability_shapeshifted !== "notshifted" && typeof ability_shapeshifted !== "undefined" ) {
            ability_max = parseInt(ability_shapeshifted)||0;
        }
        
        ability_max += ability_item;
        
        if (ability === "" || ability === "~") {
            ability = "~";
        } else {
            ability = parseInt(ability)||0;
            if (ability === ability_max) {
                ability = "~";
            }
        }
        if (ability === "~") {
            ability_rolled = ability_max;
        } else {
            
            ability_rolled = ability;
            
            if (ability < ability_max) {
                ability_loss_modifier = (ability_max - ability)*10; 
            }
        }
        
        if (ability_max === original_ability_max) {
            ability_max = "";
        }
        
        let newAttributes = new Object();
        newAttributes.ability = ability;
        newAttributes.ability_rolled = ability_rolled;
        newAttributes.ability_loss_modifier = ability_loss_modifier;
        newAttributes.ability_tempmax = ability_max;
        return newAttributes;
    }
    
    // Sets survival points based on luck and fit, also adapts them based on item/shapeshifting if that houserule is on
    on("change:fitness_rolled change:luck_rolled change:fitness_max change:luck_max change:changes_impact_survival_points", function() { 
       getAttrs(["fitness_rolled", "luck_rolled", "fitness_max", "luck_max", "survival_points", "survival_points_max", "changes_impact_survival_points"], function(values) {                
            let survival_points = parseInt(values.survival_points)||0;
            let survival_points_max = values.survival_points_max;
            let originalSurvivalPointsMax = survival_points_max;
            let changes_impact_survival_points = values.changes_impact_survival_points;
            let fitness;
            let luck;
            
            if (changes_impact_survival_points === "1") {
                fitness = parseInt(values.fitness_rolled)||0;
                luck = parseInt(values.luck_rolled)||0;
            } else {
                fitness = parseInt(values.fitness_max)||0;
                luck = parseInt(values.luck_max)||0;
            }
            
            survival_points_max = fitness + luck;
            if ( survival_points_max > (fitness*10) ) {
                survival_points_max = (fitness*10);
            }
            
            survival_points = survival_points + (survival_points_max - originalSurvivalPointsMax);
            
            setAttrs({                            
                survival_points: survival_points,
                survival_points_max: survival_points_max
            });
        });
    });
    
    // determines which humanity value should be rolled and the humanity value which displays over the top of max humanity when items are modifying it.  
    on("change:humanity change:humanity_max change:humanity_item", function() { 
       getAttrs(["humanity", "humanity_max", "humanity_rolled", "humanity_item"], function(values) {                
            let humanity = parseInt(values.humanity)||0;
            let humanityMax = parseInt(values.humanity_max)||0;
            let humanityTemp = humanity;
            let humanityRolled = parseInt(values.humanity_rolled)||0;
            
            humanityTemp += parseInt(values.humanity_item)||0;
            
            if (humanityTemp > humanityMax) {
               humanityRolled = humanityMax;
            } else {
               humanityRolled = humanityTemp; 
            }
            
            if (humanityTemp == humanity) {
                humanityTemp = "";
            }
            
            // May be worth revisiting and determining projected humanity gain/loss here, so players don't need to figure it out manually at the end of an adventure
            
            setAttrs({                            
                humanity: humanity,
                humanity_max: humanityMax,
                humanity_rolled: humanityRolled,
                humanity_temp: humanityTemp
            });
        });
    });
    
    // Triggers reload/refresh in all edges when rolled attributes (or ability loss modifiers) change to update ranges, scores etc - edge sheet workers register to refresh using change:repeating_edges:reload
    on("change:strength_rolled change:dexterity_rolled change:fitness_rolled change:intellect_rolled change:will_rolled change:perception_rolled change:attractiveness_rolled change:luck_rolled change:magic_ability_rolled change:base_hth_damage change:strength_loss_modifier change:dexterity_loss_modifier change:fitness_loss_modifier change:intellect_loss_modifier change:will_loss_modifier change:perception_loss_modifier change:attractiveness_loss_modifier change:luck_loss_modifier change:magic_ability_loss_modifier", function() {
        getSectionIDs('edges', (idarray) => {
            getAttrs(idarray.map((id) => `repeating_edges_${id}_reload`), (values) => {
                for(var i=0; i < idarray.length; i++) {
                    let edgeReload = parseInt(values[`repeating_edges_`+idarray[i]+`_reload`])||0;
                    edgeReload = +!edgeReload;
                    setAttrs({
                        [`repeating_edges_`+idarray[i]+`_reload`] : edgeReload
                    });
                }
            });
        });
    });
    
    // Triggers reload/refresh in all flaws when rolled abilities change to update rolls and damage - edge sheet workers register to refresh using change:repeating_flaws:reload
    on("change:strength_rolled change:dexterity_rolled change:fitness_rolled change:intellect_rolled change:will_rolled change:perception_rolled change:attractiveness_rolled change:luck_rolled change:magic_ability_rolled change:humanity_rolled", function() {
        getSectionIDs('flaws', (idarray) => {
            getAttrs(idarray.map((id) => `repeating_flaws_${id}_reload`), (values) => {
                for(var i=0; i < idarray.length; i++) {
                    let flawReload = parseInt(values[`repeating_flaws_`+idarray[i]+`_reload`])||0;
                    flawReload = +!flawReload;
                    setAttrs({
                        [`repeating_flaws_`+idarray[i]+`_reload`] : flawReload
                    });
                }
            });
        });
    });

    // (Optimization note to self about the above two workers, after recent changes it would now be much more efficient to make one for when abilities are changed and another for when loss modifiers are changed. The former could be used for edge/skill modifer refresh and the latter for flaws and edge range refresh, consider revisting)
    
    // Update flaws substance/enviroment damage when abilities or flaw configuration changes (Optimization note to self: Technically this only needs to be updated when the humanity ability changes, this implimentation is alittle inefficient, consider revisiting)
    on("change:repeating_flaws:reload change:repeating_flaws:flaw_damage_value change:repeating_flaws:flaw_damage_modifier", function() { 
       getAttrs(["repeating_flaws_flaw_damage_value", "repeating_flaws_flaw_damage_modifier", "humanity_rolled"], function(values) {                
            
            let substanceDamage = "none";
            let barSubstanceDamage = "";
            
            if (values.repeating_flaws_flaw_damage_value !== "") {
            
                // Calculate Substance damage modifier from Humanity change
                let modPerTenHumanity = parseInt(values.repeating_flaws_flaw_damage_modifier)||0;
                
                let humanityRolled = parseInt(values.humanity_rolled)||0;
                let tenHumanities = (50-humanityRolled)/10;
                
                if (tenHumanities > 0) {
                    tenHumanities = Math.floor(tenHumanities);
                }
                if (tenHumanities < 0) {
                    tenHumanities = Math.ceil(tenHumanities);
                }
                
                let damageMod = tenHumanities*modPerTenHumanity;
                
                // Put together final damage string
                let damageValueNum = parseInt(values.repeating_flaws_flaw_damage_value);
                
                let damageValueString;
                
                if (!isNaN(damageValueNum)) {
                    damageValueString = Math.max(0, (damageValueNum + damageMod)).toString()+" SP/BT";
                } else {
                    damageValueString = values.repeating_flaws_flaw_damage_value;
                    if (damageMod > 0) {
                        damageValueString += ("+"+damageMod);
                    } 
                    if (damageMod < 0) {
                        damageValueString += damageMod;
                    }
                }
                substanceDamage = damageValueString;
                barSubstanceDamage = "("+substanceDamage+")";
            }
            
            setAttrs({                            
                repeating_flaws_flaw_damage: substanceDamage,
                repeating_flaws_bar_flaw_damage: barSubstanceDamage
            });
        });
    });
    
    // Update flaw roll variables when abilties or flaw configuration changes
    on("change:repeating_flaws:reload change:repeating_flaws:flaw_roll_ability change:repeating_flaws:flaw_roll_modified change:repeating_flaws:flaw_damage", function() { 
        getAttrs(["repeating_flaws_flaw_damage", "repeating_flaws_flaw_roll_ability", "repeating_flaws_flaw_roll_modified", "humanity_rolled", "strength_rolled", "dexterity_rolled", "fitness_rolled", "intellect_rolled", "will_rolled", "perception_rolled", "attractiveness_rolled", "luck_rolled", "magic_ability_rolled"], function(values) {                
            let abilityString = values.repeating_flaws_flaw_roll_ability;
            let modifyWithHumanity = values.repeating_flaws_flaw_roll_modified;
            let rollText = "d100";
            let abilityScore = 0;
            let humanityMinusFifty = 0;
            let humanityRolled = parseInt(values.humanity_rolled)||0;
            let showRollButton = 0; 
            let flawDamageText = values.repeating_flaws_flaw_damage;
            
            if (modifyWithHumanity === "on") {
                humanityMinusFifty = humanityRolled-50;
                humanityMinusFifty = 0 - humanityMinusFifty;
                if (humanityMinusFifty > 0) {
                    rollText +="+"; 
                }
                if (humanityMinusFifty != 0) {
                    rollText += humanityMinusFifty;
                    
                }
            } 
            
            if (abilityString === "none") {
                rollText = abilityString;
                showRollButton = 0;
                
            } else {
                if (abilityString === "Humanity<50") {
                    abilityScore = (50 - humanityRolled);
                    if (abilityScore < 0) {
                        abilityScore = 0;
                    }
                } else {
                    abilityScore = SetScoreByAbilityScore (-1, abilityString, values, false, true);
                }
                rollText = rollText+" vs "+abilityScore;
                
                if (flawDamageText === "none") {
                    showRollButton = "on";
                } 
            }
            
            setAttrs({                            
                repeating_flaws_flaw_roll: rollText,
                repeating_flaws_flaw_roll_ability_score: abilityScore,
                repeating_flaws_flaw_roll_modifier: humanityMinusFifty,
                repeating_flaws_flaw_roll_set: showRollButton
            });
        });
    });
    
    // Sets an edge's score to its starting value whenever its base is set, (Not this can however lead to accidental wiping of scores if the base was set wrong to start with, not a perfect approach.)
    // (Note to self: I used to enforce scores not being able to be set lower then thier base here, but it proved to cause more problems then it solved, don't go down that route again)  
    on("change:repeating_edges:edge_base", function() { 
        getAttrs(["repeating_edges_edge_score", "repeating_edges_edge_base", "strength_max", "dexterity_max", "fitness_max", "intellect_max", "will_max", "perception_max", "attractiveness_max", "luck_max", "magic_ability_max"], function(values) {                
            let score = SetScoreByAbilityScore (values.repeating_edges_edge_score, values.repeating_edges_edge_base, values, false, false);
            setAttrs({
                repeating_edges_edge_score: score
            });
        });
    });
    
    // Set an edge's ability loss modifier for use by its roll button 
    on("change:repeating_edges:edge_base change:repeating_edges:reload", function() { 
        getAttrs(["repeating_edges_edge_base", "strength_loss_modifier", "dexterity_loss_modifier", "fitness_loss_modifier", "intellect_loss_modifier", "will_loss_modifier", "perception_loss_modifier", "attractiveness_loss_modifier", "luck_loss_modifier", "magic_ability_loss_modifier"], function(values) {                
            
            let ability_loss_modifier = GetAbilityLossModifier (values.repeating_edges_edge_base, values);
            
            setAttrs({
                repeating_edges_edge_ability_loss_modifier: ability_loss_modifier
            });
        });
    });
    
    // Set a skill's ability loss modifier for use by its roll button 
    on("change:repeating_skills:skill_base change:repeating_skills:reload", function() { 
        getAttrs(["repeating_skills_skill_base", "strength_loss_modifier", "dexterity_loss_modifier", "fitness_loss_modifier", "intellect_loss_modifier", "will_loss_modifier", "perception_loss_modifier", "attractiveness_loss_modifier", "luck_loss_modifier", "magic_ability_loss_modifier"], function(values) {                
            
            let ability_loss_modifier = GetAbilityLossModifier (values.repeating_skills_skill_base, values);
            
            setAttrs({
                repeating_skills_ability_loss_modifier: ability_loss_modifier
            });
        });
    });
    
    // Determines loss modifer using ability shorthand
    // (Optimization note to self, this is embarrassingly inefficient.  The select option values could just be changed to match the ability names removing the need for a switch.  Consider revisiting.)
    function GetAbilityLossModifier (ability, values) {
        
        let ability_loss_modifier = 0;
        
        switch(ability) {
            case "STR":
                ability_loss_modifier = values.strength_loss_modifier;
            break;
            case "DEX":
                ability_loss_modifier = values.dexterity_loss_modifier;
            break;
            case "FIT":
                ability_loss_modifier = values.fitness_loss_modifier;
            break;
            case "INT":
                ability_loss_modifier = values.intellect_loss_modifier;
            break;
            case "WILL":
                ability_loss_modifier = values.will_loss_modifier;
            break;
            case "PER":
                ability_loss_modifier = values.perception_loss_modifier;
            break;
            case "ATT":
                ability_loss_modifier = values.attractiveness_loss_modifier;
            break;
            case "LUCK":
                ability_loss_modifier = values.luck_loss_modifier;
            break;
            case "MA":
                ability_loss_modifier = values.magic_ability_loss_modifier;
            break;
            case "(STR+DEX)÷2":
                ability_loss_modifier = ( (parseInt(values.strength_loss_modifier)||0) + (parseInt(values.dexterity_loss_modifier)||0) ) *0.5;
            break;
        }
        
        return parseInt(ability_loss_modifier)||0;
    }
    
    // Makes Edges push relivent data to weapons/attacks which referance them when their configuration is updated or they're prompted to (via push2weapon) by being referanced in a weapon/attack's configuration 
    on("change:repeating_edges:push2weapon change:repeating_edges:name change:repeating_edges:edge_score change:repeating_edges:edge_ability_loss_modifier change:repeating_edges:edge_range", function() {
       getAttrs(["repeating_edges_name", "repeating_edges_edge_score", "repeating_edges_edge_ability_loss_modifier", "repeating_edges_edge_range"], function(edgeValues) {
    
            let edgeName = edgeValues.repeating_edges_name.toLowerCase().trim();
            let edgeScore = edgeValues.repeating_edges_edge_score;
            let edgeAbilityLossModifier = edgeValues.repeating_edges_edge_ability_loss_modifier;
            let edgeRange = edgeValues.repeating_edges_edge_range;
            
            getSectionIDs('weapons', function(idarray) {
                getAttrs(idarray.map(function(id) { return `repeating_weapons_${id}_csr_input`; }), function(weaponValues) { 
                    
                    // Parse through every weapon
                    for(var i=0; i < idarray.length; i++) {
                        // New approach: if edge name matches weapon's CSR input, transfer over variables
                        // I loop though everything without breaking because multiple weapons can be bound to one skill/edge
                        // Linked weapon is nolonger used and weapon name changes aren't pushed because whilst cleaner that technique didn't allow for multiple linked weapons
                        
                        let weaponCsrInput = weaponValues[`repeating_weapons_`+idarray[i]+`_csr_input`].toLowerCase().trim();
                        
                        if (weaponCsrInput === edgeName) {
                            setAttrs({
                                [`repeating_weapons_`+idarray[i]+`_csr`] : edgeScore,
                                [`repeating_weapons_`+idarray[i]+`_ability_loss_modifier`] : edgeAbilityLossModifier,
                                [`repeating_weapons_`+idarray[i]+`_range`] : edgeRange,
                                [`repeating_weapons_`+idarray[i]+`_matched_to_skill`] : "0"
                            });
                        }
                    }      
                });
            });
        });
    });
    
    // Sets the Edge humanity cost summary text
    on("change:repeating_edges:edge_acquisition_cost change:repeating_edges:edge_cost_ratio change:repeating_edges:edge_use_cost", function() { 
        getAttrs(["repeating_edges_edge_acquisition_cost", "repeating_edges_edge_cost_ratio", "repeating_edges_edge_use_cost"], function(values) {                
            let humanityCosts = values.repeating_edges_edge_acquisition_cost+"•"+values.repeating_edges_edge_cost_ratio+"•"+values.repeating_edges_edge_use_cost;
            setAttrs({
                repeating_edges_edge_humanity_costs: humanityCosts
            });
        });
    });
    
    // Sets the range text, if distance is checked this can be derived from numerous variables, I also automatically convert yards to feet as odds are good roll20's measuring tool will be configured to feet
    on("change:repeating_edges:edge_range_touch change:repeating_edges:edge_range_distance change:repeating_edges:edge_range_value change:repeating_edges:edge_range_multiplier change:repeating_edges:edge_range_measurement change:repeating_edges:edge_range_lineofsight change:repeating_edges:edge_range_eyecontact change:repeating_edges:edge_range_voice change:repeating_edges:edge_range_described change:repeating_edges:edge_range_description change:repeating_edges:edge_score change:repeating_edges:reload", function() { 
        getAttrs(["repeating_edges_edge_range_touch", "repeating_edges_edge_range_distance", "repeating_edges_edge_range_value", "repeating_edges_edge_range_multiplier", "repeating_edges_edge_range_measurement", "repeating_edges_edge_range_lineofsight", "repeating_edges_edge_range_eyecontact", "repeating_edges_edge_range_voice", "repeating_edges_edge_range_described", "repeating_edges_edge_range_description", "strength_rolled", "dexterity_rolled", "fitness_rolled", "intellect_rolled", "will_rolled", "perception_rolled", "attractiveness_rolled", "luck_rolled", "magic_ability_rolled", "repeating_edges_edge_score"], function(values) {
            let range = "";
            let addComma = function () {
                if (range !== "") {
                    range += ", ";
                }
            };
            if (values.repeating_edges_edge_range_touch === "on") {
                range += "Touch";
            }
            if (values.repeating_edges_edge_range_distance === "on") {
                let rangeValue = 0;
                if (values.repeating_edges_edge_range_value === "Score") {
                    rangeValue = parseInt(values.repeating_edges_edge_score)||0;
                } else {
                    rangeValue = SetScoreByAbilityScore (0, values.repeating_edges_edge_range_value, values, false, true);
                }
                rangeValue = rangeValue*values.repeating_edges_edge_range_multiplier;
                let rangeMeasurement = values.repeating_edges_edge_range_measurement;
                if (rangeMeasurement === "Yards") {
                    rangeValue *= 3; 
                    rangeMeasurement = "Feet";  
                } 
                range += rangeValue+" "+rangeMeasurement;
            }
            if (values.repeating_edges_edge_range_lineofsight === "on") {
                addComma();
                range += "Line of sight";
            }
            if (values.repeating_edges_edge_range_eyecontact === "on") {
                addComma();
                range += "Eye contact";
            }
            if (values.repeating_edges_edge_range_voice === "on") {
                addComma();
                range += "Voice";
            }
            if (values.repeating_edges_edge_range_described === "on" && values.repeating_edges_edge_range_description !== "") {
                addComma();
                range += values.repeating_edges_edge_range_description;
            }
            setAttrs({
                repeating_edges_edge_range: range
            });
        });
    });
    
    // Sets ability score using ability shorthand, widely used so has options
    // (Optimization note to self, this is embarrassingly inefficient.  The select option values could just be changed to match the ability names removing the need for a switch.  Consider revisiting.)
    function SetScoreByAbilityScore (stringOfScoreBeingSet, abilityAbbreviation, values, onlySetIfLower, useRolled) {
        
        let scoreBeingSet = parseInt(stringOfScoreBeingSet)||0;
        if (onlySetIfLower === false) {
            scoreBeingSet = 0;
        } 
        
        let indexEnd = "max";
        if (useRolled === true) {
            indexEnd = "rolled";
        }
        
        let ability = 0;
        switch(abilityAbbreviation) {
            case "STR":
                ability = parseInt(values["strength_"+indexEnd])||0;
            break;
            case "DEX":
                ability = parseInt(values["dexterity_"+indexEnd])||0;
            break;
            case "FIT":
                ability = parseInt(values["fitness_"+indexEnd])||0;
            break;
            case "INT":
                ability = parseInt(values["intellect_"+indexEnd])||0;
            break;
            case "WILL":
                ability = parseInt(values["will_"+indexEnd])||0;
            break;
            case "PER":
                ability = parseInt(values["perception_"+indexEnd])||0;
            break;
            case "ATT":
                ability = parseInt(values["attractiveness_"+indexEnd])||0;
            break;
            case "LUCK":
                ability = parseInt(values["luck_"+indexEnd])||0;
            break;
            case "MA":
                ability = parseInt(values["magic_ability_"+indexEnd])||0;
            break;
            case "5":
                ability = 5;
            break;
            case "1":
                ability = 1;
            break;
            case "(STR+DEX)÷2":
                ability = Math.round( ( (parseInt(values["strength_"+indexEnd])||0) + (parseInt(values["dexterity_"+indexEnd])||0) )/2 );
            break;
        }
        
        if (scoreBeingSet < ability) scoreBeingSet = ability;
        
        return scoreBeingSet;
    }
    
    // Sets edge's escape roll summary text based on its configuration
    on("change:repeating_edges:edge_escape_roll_ability change:repeating_edges:edge_escape_roll_success_effect", function() { 
        getAttrs(["repeating_edges_edge_escape_roll", "repeating_edges_edge_escape_roll_ability", "repeating_edges_edge_escape_roll_success_effect"], function(values) {                
            let escapeRoll = values.repeating_edges_edge_escape_roll;
            let ability = values.repeating_edges_edge_escape_roll_ability;
            let successEffect = values.repeating_edges_edge_escape_roll_success_effect;
            if (successEffect === "") {
                successEffect = "no effect";
            }
            if (ability !== "none") {
                escapeRoll = ability+" for "+successEffect;
            } else {
                escapeRoll = "none";
            }
            setAttrs({
                repeating_edges_edge_escape_roll: escapeRoll
            });
        });
    });
    
    // Sets edge's speed summary text based on its configuration, automatically converts yards to feet as odds are good roll20's measuring tool will be configured to feet
    on("change:repeating_edges:edge_speed_feet_measure change:repeating_edges:edge_speed_feet_option change:repeating_edges:edge_speed_feet_value change:repeating_edges:edge_speed_mph_option change:repeating_edges:edge_speed_mph_value change:repeating_edges:edge_score", function() { 
        getAttrs(["repeating_edges_edge_speed_feet_measure", "repeating_edges_edge_speed_feet_option", "repeating_edges_edge_speed_feet_value", "repeating_edges_edge_speed_mph_option", "repeating_edges_edge_speed_mph_value", "repeating_edges_edge_score", "repeating_edges_edge_speed"], function(values) {                
            let mphScore = parseInt(values.repeating_edges_edge_score)||0; 
            let feetScore = mphScore;
            if (values.repeating_edges_edge_speed_feet_measure === "yards") {
                feetScore *= 3;
            }
            let calcSpeed = function (score, option, value, unit) {
                let intValue = parseInt(value);
                let returnString = "";
                switch (option) {
                    case "multiply":
                        returnString += score*intValue;
                    break;
                    case "divide":
                        returnString += score/intValue;
                    break;
                } 
                if (returnString !== "") {
                    returnString = Math.round(returnString)+unit;
                }
                return returnString;
            };
            let feetString = calcSpeed(feetScore, values.repeating_edges_edge_speed_feet_option, values.repeating_edges_edge_speed_feet_value, "ft/BT");
            let mphString = calcSpeed(mphScore, values.repeating_edges_edge_speed_mph_option, values.repeating_edges_edge_speed_mph_value, "mph");
            if (feetString === "") {
                feetString = mphString;
            } else if (mphString !== "") {
                feetString += " ("+mphString+")";
            }
            setAttrs({
                repeating_edges_edge_speed: feetString
            });
        });
    });
    
    // When an edges shapeshift configuration is changed: sets global shapechanged abilities based on configuration values (if the edge has been marked active) and declares if a shapeshift form exists for this edge based on if any meaningful shapeshift configuration values have been entered.  Form exists is used as part of determining edge active checkbox visiblity 
    on("change:repeating_edges:edge_shapeshift_str_option change:repeating_edges:edge_shapeshift_str_value change:repeating_edges:edge_shapeshift_dex_option change:repeating_edges:edge_shapeshift_dex_value change:repeating_edges:edge_shapeshift_fit_option change:repeating_edges:edge_shapeshift_fit_value change:repeating_edges:edge_shapeshift_int_option change:repeating_edges:edge_shapeshift_int_value change:repeating_edges:edge_shapeshift_will_option change:repeating_edges:edge_shapeshift_will_value change:repeating_edges:edge_shapeshift_per_option change:repeating_edges:edge_shapeshift_per_value change:repeating_edges:edge_shapeshift_att_option change:repeating_edges:edge_shapeshift_att_value change:repeating_edges:edge_shapeshift_luck_option change:repeating_edges:edge_shapeshift_luck_value change:repeating_edges:edge_shapeshift_ma_option change:repeating_edges:edge_shapeshift_ma_value change:repeating_edges:edge_shapeshift_skill_modifier", function() { 
        getAttrs(["repeating_edges_edge_shapeshift_str_option", "repeating_edges_edge_shapeshift_str_value", "repeating_edges_edge_shapeshift_dex_option", "repeating_edges_edge_shapeshift_dex_value", "repeating_edges_edge_shapeshift_fit_option", "repeating_edges_edge_shapeshift_fit_value", "repeating_edges_edge_shapeshift_int_option", "repeating_edges_edge_shapeshift_int_value", "repeating_edges_edge_shapeshift_will_option", "repeating_edges_edge_shapeshift_will_value", "repeating_edges_edge_shapeshift_per_option", "repeating_edges_edge_shapeshift_per_value", "repeating_edges_edge_shapeshift_att_option", "repeating_edges_edge_shapeshift_att_value", "repeating_edges_edge_shapeshift_luck_option", "repeating_edges_edge_shapeshift_luck_value", "repeating_edges_edge_shapeshift_ma_option", "repeating_edges_edge_shapeshift_ma_value", "repeating_edges_edge_shapeshift_form_used", "repeating_edges_edge_shapeshift_skill_modifier", "shapeshift_skill_modifier", "strength_max", "dexterity_max", "fitness_max", "intellect_max", "will_max", "perception_max", "attractiveness_max", "luck_max", "magic_ability_max", "strength_shapeshifted", "dexterity_shapeshifted", "fitness_shapeshifted", "intellect_shapeshifted", "will_shapeshifted", "perception_shapeshifted", "attractiveness_shapeshifted", "luck_shapeshifted", "magic_ability_shapeshifted", "repeating_edges_edge_shapeshift_form_exists"], function(values) {
            let attrs2Set = new Object();
            let formExists = "off";
            let doesFormExist = function (option, value) {
                if (option === "=" || value !== "0") {
                    formExists = "on";
                } 
            };
            doesFormExist(values.repeating_edges_edge_shapeshift_str_option, values.repeating_edges_edge_shapeshift_str_value);
            doesFormExist(values.repeating_edges_edge_shapeshift_dex_option, values.repeating_edges_edge_shapeshift_dex_value);
            doesFormExist(values.repeating_edges_edge_shapeshift_fit_option, values.repeating_edges_edge_shapeshift_fit_value);
            doesFormExist(values.repeating_edges_edge_shapeshift_int_option, values.repeating_edges_edge_shapeshift_int_value);
            doesFormExist(values.repeating_edges_edge_shapeshift_will_option, values.repeating_edges_edge_shapeshift_will_value);
            doesFormExist(values.repeating_edges_edge_shapeshift_per_option, values.repeating_edges_edge_shapeshift_per_value);
            doesFormExist(values.repeating_edges_edge_shapeshift_att_option, values.repeating_edges_edge_shapeshift_att_value);
            doesFormExist(values.repeating_edges_edge_shapeshift_luck_option, values.repeating_edges_edge_shapeshift_luck_value);
            doesFormExist(values.repeating_edges_edge_shapeshift_ma_option, values.repeating_edges_edge_shapeshift_ma_value);
            attrs2Set.repeating_edges_edge_shapeshift_form_exists = formExists;
            if (values.repeating_edges_edge_shapeshift_form_used === "on") {
                attrs2Set = AddShapeshiftedVarsToObject (values, attrs2Set);
            }
            setAttrs(attrs2Set);
        });
    });
    
    // When an edge is marked active: Make it inactive again if other edge is marked active and when appropriate set/unset global shapechanged abilities and speed values based on this edge's configuration 
    on("change:repeating_edges:edge_shapeshift_form_activity", function() { 
        getAttrs(["repeating_edges_edge_shapeshift_str_option", "repeating_edges_edge_shapeshift_str_value", "repeating_edges_edge_shapeshift_dex_option", "repeating_edges_edge_shapeshift_dex_value", "repeating_edges_edge_shapeshift_fit_option", "repeating_edges_edge_shapeshift_fit_value", "repeating_edges_edge_shapeshift_int_option", "repeating_edges_edge_shapeshift_int_value", "repeating_edges_edge_shapeshift_will_option", "repeating_edges_edge_shapeshift_will_value", "repeating_edges_edge_shapeshift_per_option", "repeating_edges_edge_shapeshift_per_value", "repeating_edges_edge_shapeshift_att_option", "repeating_edges_edge_shapeshift_att_value", "repeating_edges_edge_shapeshift_luck_option", "repeating_edges_edge_shapeshift_luck_value", "repeating_edges_edge_shapeshift_ma_option", "repeating_edges_edge_shapeshift_ma_value", "repeating_edges_edge_shapeshift_form_activity", "repeating_edges_edge_shapeshift_form_used", "repeating_edges_edge_shapeshift_skill_modifier", "shapeshift_skill_modifier", "strength_max", "dexterity_max", "fitness_max", "intellect_max", "will_max", "perception_max", "attractiveness_max", "luck_max", "magic_ability_max", "strength_shapeshifted", "dexterity_shapeshifted", "fitness_shapeshifted", "intellect_shapeshifted", "will_shapeshifted", "perception_shapeshifted", "attractiveness_shapeshifted", "luck_shapeshifted", "magic_ability_shapeshifted", "repeating_edges_edge_shapeshift_form_exists", "repeating_edges_edge_speed", "repeating_edges_edge_speed_movement_type", "active_extra_movement_value"], function(values) {
            
            let attrs2Set = new Object();
            
            attrs2Set.repeating_edges_edge_shapeshift_form_activity = values.repeating_edges_edge_shapeshift_form_activity||"off";
            attrs2Set.repeating_edges_edge_shapeshift_form_used = values.repeating_edges_edge_shapeshift_form_used||"off";
            let activeStrengthShapeshifted = values.strength_shapeshifted||"notshifted";
            let activeExtraMovementValue = values.active_extra_movement_value||"";
            
            // User just ticked active
            if (attrs2Set.repeating_edges_edge_shapeshift_form_activity === "on") {
                if (activeStrengthShapeshifted === "notshifted" && activeExtraMovementValue === "") {
                    // no other edges are active, make a note to that this edge is the active edge
                    attrs2Set.repeating_edges_edge_shapeshift_form_used = "on";
                } else {
                    // another edge is active, turn untick active
                    attrs2Set.repeating_edges_edge_shapeshift_form_activity = "off";
                }
            }
    
            // if this edge is the active edge...
            if (attrs2Set.repeating_edges_edge_shapeshift_form_used === "on") {
                if (attrs2Set.repeating_edges_edge_shapeshift_form_activity !== "on") {
                    // but we've just been unticked, ethier by the user or the block above, remove all the global shapeshifting vars and global speed vars then note we're nolonger the active edge,
                    attrs2Set.strength_shapeshifted = "notshifted";
                    attrs2Set.dexterity_shapeshifted = "notshifted";
                    attrs2Set.fitness_shapeshifted = "notshifted";
                    attrs2Set.intellect_shapeshifted = "notshifted";
                    attrs2Set.will_shapeshifted = "notshifted";
                    attrs2Set.perception_shapeshifted = "notshifted";
                    attrs2Set.attractiveness_shapeshifted = "notshifted";
                    attrs2Set.luck_shapeshifted = "notshifted";
                    attrs2Set.magic_ability_shapeshifted = "notshifted";
                    attrs2Set.shapeshift_skill_modifier = 0;
    
                    attrs2Set.active_extra_movement_name = "";
                    attrs2Set.active_extra_movement_value = "";
    
                    attrs2Set.repeating_edges_edge_shapeshift_form_used = "off";
    
                } else {
                    // and we're just been ticked, set all the global vars to this edge's vars
                    attrs2Set = AddShapeshiftedVarsToObject (values, attrs2Set);
    
                    if (values.repeating_edges_edge_speed !== "n/a") {
                        attrs2Set.active_extra_movement_name = values.repeating_edges_edge_speed_movement_type+":";
                        attrs2Set.active_extra_movement_value = values.repeating_edges_edge_speed;
                    }
                }
                
            }
    
            setAttrs(attrs2Set);
        });
    });
    
    // Calculates shapechanged ability values based on edge configuration settings and current ability values
    // (Optimization note to self, its possible to impliment this more efficiently will less repetition, though it would probably involve changing variable names, which could be wipe existing player data.)
    function AddShapeshiftedVarsToObject (values, objectToAddTo) {
        let calcAbilityShapeshifted = function (option, value, abilityMax) {
            let abilityShapeshifted = 0;
            value = parseInt(value)||0;
            abilityMax = parseInt(abilityMax)||0;
            switch (option) {
                case "=":
                    abilityShapeshifted = value;
                break;
                case "+":
                    abilityShapeshifted = abilityMax + value;
                break;
                case "-":
                    abilityShapeshifted = abilityMax - value;
                break;
            } 
            return abilityShapeshifted;
        };
        objectToAddTo.strength_shapeshifted = calcAbilityShapeshifted(values.repeating_edges_edge_shapeshift_str_option, values.repeating_edges_edge_shapeshift_str_value, values.strength_max);
        objectToAddTo.dexterity_shapeshifted = calcAbilityShapeshifted(values.repeating_edges_edge_shapeshift_dex_option, values.repeating_edges_edge_shapeshift_dex_value, values.dexterity_max);
        objectToAddTo.fitness_shapeshifted = calcAbilityShapeshifted(values.repeating_edges_edge_shapeshift_fit_option, values.repeating_edges_edge_shapeshift_fit_value, values.fitness_max);
        objectToAddTo.intellect_shapeshifted = calcAbilityShapeshifted(values.repeating_edges_edge_shapeshift_int_option, values.repeating_edges_edge_shapeshift_int_value, values.intellect_max);
        objectToAddTo.will_shapeshifted = calcAbilityShapeshifted(values.repeating_edges_edge_shapeshift_will_option, values.repeating_edges_edge_shapeshift_will_value, values.will_max);
        objectToAddTo.perception_shapeshifted = calcAbilityShapeshifted(values.repeating_edges_edge_shapeshift_per_option, values.repeating_edges_edge_shapeshift_per_value, values.perception_max);
        objectToAddTo.attractiveness_shapeshifted = calcAbilityShapeshifted(values.repeating_edges_edge_shapeshift_att_option, values.repeating_edges_edge_shapeshift_att_value, values.attractiveness_max);
        objectToAddTo.luck_shapeshifted = calcAbilityShapeshifted(values.repeating_edges_edge_shapeshift_luck_option, values.repeating_edges_edge_shapeshift_luck_value, values.luck_max);
        objectToAddTo.magic_ability_shapeshifted = calcAbilityShapeshifted(values.repeating_edges_edge_shapeshift_ma_option, values.repeating_edges_edge_shapeshift_ma_value, values.magic_ability_max);
        objectToAddTo.shapeshift_skill_modifier = values.repeating_edges_edge_shapeshift_skill_modifier;
        return objectToAddTo;
    }
    
    // When an edges speed configuration is changed: sets global speed values based on configuration values (if the edge has been marked active)
    on("change:repeating_edges:edge_speed change:repeating_edges:edge_speed_movement_type", function() { 
        getAttrs(["repeating_edges_edge_shapeshift_form_used", "repeating_edges_edge_speed", "repeating_edges_edge_speed_movement_type"], function(values) {
            
            let attrs2Set = new Object();
    
            if (values.repeating_edges_edge_shapeshift_form_used === "on") {
                if (values.repeating_edges_edge_speed !== "n/a") {
                    attrs2Set.active_extra_movement_name = values.repeating_edges_edge_speed_movement_type+":";
                    attrs2Set.active_extra_movement_value = values.repeating_edges_edge_speed;
                } else {
                    attrs2Set.active_extra_movement_name = "";
                    attrs2Set.active_extra_movement_value = "";
                }
            }
    
            setAttrs(attrs2Set);
        });
    }); 
       
    // Sets speed exists varible based on if the speed summary text has been set, this is used as part of determining edge active checkbox visiblity 
    on("change:repeating_edges:edge_speed", function() { 
        getAttrs(["repeating_edges_edge_speed"], function(values) {
            
            let speedExists = "off"; 
    
            if (values.repeating_edges_edge_speed !== "n/a") {
                speedExists = "on";
            } 
            
            setAttrs({
                repeating_edges_edge_speed_exists: speedExists
            });
        });
    });
    
    // Sets extra movement active variable based on if we have set a global speed value, this is used to change the extra movement field's visiblity  
    on("change:active_extra_movement_value", function() { 
        getAttrs(["active_extra_movement_value"], function(values) {
            
            let extraMovementActive = "0"; 
    
            if (values.active_extra_movement_value !== "") {
                extraMovementActive = "1";
            } 
            setAttrs({
                extra_movement_active: extraMovementActive
            });
        });
    });
    
    // if an edge or a skill name matches one of a predetermined set of key words, update the global variable of that key word and note the match so the names border can be made green.  This ensures the diplomacy variable is set by a skill named diplomacy etc.
    // (Bug Note: There's an obvious issue here where you can set your diplomacy value from an edge, you claws value from a skill etc, consider revisiting) 
    on("change:repeating_edges:name change:repeating_edges:edge_score", function() { 
        getAttrs(["repeating_edges_name", "repeating_edges_edge_score"], function(values) {                
            
            let matchedKeyName = MakeSheetAttributeIfScoreHasKeyName (values.repeating_edges_name, values.repeating_edges_edge_score);
            
            setAttrs({
                repeating_edges_name_keyname: matchedKeyName
            });
        });
    });
    on("change:repeating_skills:name change:repeating_skills:skill_score", function() { 
        getAttrs(["repeating_skills_name", "repeating_skills_skill_score"], function(values) {                
            
            let matchedKeyName = MakeSheetAttributeIfScoreHasKeyName (values.repeating_skills_name, values.repeating_skills_skill_score);
            
            setAttrs({
                repeating_skills_name_keyname: matchedKeyName
            });
        });
    });
    on("remove:repeating_edges remove:repeating_skills", function(eventinfo) {
        if (eventinfo.removedInfo[eventinfo.sourceAttribute+"_name_keyname"] === "on") {
            MakeSheetAttributeIfScoreHasKeyName (eventinfo.removedInfo[eventinfo.sourceAttribute+"_name"], 0);
        }
    });
    function MakeSheetAttributeIfScoreHasKeyName (name, score) {
        
        let lowerCaseName = name.toLowerCase();
        lowerCaseName = lowerCaseName.replace(/\s+/g, '');
        
        let keyNames = ["claws", "intimidation", "diplomacy", "leadership", "persuasion", "streetwise", "speed", "business", "business,criminal"];
        
        for (let i = 0; i < keyNames.length; i++) { 
            
            if (keyNames[i] === lowerCaseName) {
                
                setAttrs({
                    [keyNames[i]] : score
                });   
                
                return "on";
            }
            
        }
        
        return 0;
    }  

    // Triggers reload/refresh in all skills when rolled attributes change - skill sheet workers register to refresh using change:repeating_skills:reload
    // (Optimization note to self: Since requirements have now changed it would now be much more efficient to have one trigger for when abilities are changed and another for when loss modifiers are changed as stated earlier in the sheet, then just use the loss modifier one instead of skill reloading, consider revisting)
    on("change:strength_rolled change:dexterity_rolled change:fitness_rolled change:intellect_rolled change:will_rolled change:perception_rolled change:attractiveness_rolled change:luck_rolled change:magic_ability_rolled change:strength_loss_modifier change:dexterity_loss_modifier change:fitness_loss_modifier change:intellect_loss_modifier change:will_loss_modifier change:perception_loss_modifier change:attractiveness_loss_modifier change:luck_loss_modifier change:magic_ability_loss_modifier", function() {
        getSectionIDs('skills', (idarray) => {
            getAttrs(idarray.map((id) => `repeating_skills_${id}_reload`), (values) => {
                for(var i=0; i < idarray.length; i++) {
                    let skillReload = parseInt(values[`repeating_skills_`+idarray[i]+`_reload`])||0;
                    skillReload = +!skillReload;
                    setAttrs({
                        [`repeating_skills_`+idarray[i]+`_reload`] : skillReload
                    });
                }
            });
        });
    });
    
    // if this skill the character's job skill, update the global job skill var when this skill score is changed 
    on("change:repeating_skills:skill_score", function() { 
        getAttrs(["repeating_skills_skill_score", "job_skill_name", "repeating_skills_name"], function(values) {                
            let score = values.repeating_skills_skill_score; 
            
            if (values.repeating_skills_name === values.job_skill_name) {
                setAttrs({
                    job_skill_score: score
                });
            }
        });
    });
    
    // When a skills base is changed, reset the its score to its base ability
    // (Note to self: I used to enforce scores not being able to be set lower then thier base here, but it proved to cause more problems then it solved, don't go down that route again)  
    on("change:repeating_skills:skill_base", function() { 
        getAttrs(["repeating_skills_skill_score", "repeating_skills_skill_base", "strength_max", "dexterity_max", "fitness_max", "intellect_max", "will_max", "perception_max", "attractiveness_max", "luck_max", "magic_ability_max"], function(values) {                
            let score = SetScoreByAbilityScore (values.repeating_skills_skill_score, values.repeating_skills_skill_base, values, false, false);
            setAttrs({
                repeating_skills_skill_score: score
            });
        });
    });
    
    // when a "make job skill" button is pressed (secretly a checkbox), we make the global job skill vars match those of the skill who's button was pressed  
    on("change:repeating_skills:setjobskillbutton", function() { 
        getAttrs(["repeating_skills_skill_score", "repeating_skills_name"], function(values) {                
            setAttrs({
                job_skill_name: values.repeating_skills_name,
                job_skill_score: values.repeating_skills_skill_score
            });
        });
    });
    
    // Tweaks the name of the language skill when its language field is edited
    on("change:language_native_brackets", function() { 
        getAttrs(["language_native_brackets"], function(values) {                
            let newLanguageName = "Language ("+values.language_native_brackets+")";
            setAttrs({
                language_native_name: newLanguageName
            });
        });
    });
    
    // Resolves numbers/names typed in a weapon/attacks CSR field, either parsing the number, fetching the appropaite ability score or triggering a matching skill or edge (repeating and player populated) to send thier values to the weapon 
    on("change:repeating_weapons:csr_input change:repeating_weapons:name change:repeating_weapons:reload", function() { 
        getAttrs(["repeating_weapons_name", "repeating_weapons_csr_input", "strength_rolled", "dexterity_rolled", "fitness_rolled", "intellect_rolled", "will_rolled",  "perception_rolled", "attractiveness_rolled", "luck_rolled",  "magic_ability_rolled", "luck_as_a_skill", "language_native_name", "language_native_score", "intellect_loss_modifier"], function(weaponValues) {                
            
            let csrInput = weaponValues.repeating_weapons_csr_input.toLowerCase().trim();
            
            // if inputed CSR was a number, we just set it to this
            let csrNumber = parseInt(csrInput);
            
            let abilityLossMod = 0;
            
            if (isNaN(csrNumber)) {
                // if inputed CSR is an ability, we set to that ability's value
                switch (csrInput) {
                    case "str":
                    case "strength":
                        csrNumber = parseInt(weaponValues.strength_rolled);
                    break;
                    case "dex":
                    case "dexterity":
                    case "hand-to-hand":
                    case "hand to hand":
                        csrNumber = parseInt(weaponValues.dexterity_rolled);
                    break;
                    case "fit":
                    case "fitness":
                        csrNumber = parseInt(weaponValues.fitness_rolled);
                    break;
                    case "int":
                    case "intellect":
                        csrNumber = parseInt(weaponValues.intellect_rolled);
                    break;
                    case "will":
                        csrNumber = parseInt(weaponValues.will_rolled);
                    break;
                    case "per":
                    case "perception":
                        csrNumber = parseInt(weaponValues.perception_rolled);
                    break;
                    case "att":
                    case "attractiveness":
                        csrNumber = parseInt(weaponValues.attractiveness_rolled);
                    break;
                    case "luck":
                        csrNumber = parseInt(weaponValues.luck_rolled);
                    break;
                    case "ma":
                    case "magic ability":
                        csrNumber = parseInt(weaponValues.magic_ability_rolled);
                    break;
                    case "luck as a skill":
                        csrNumber = parseInt(weaponValues.luck_as_a_skill);
                    break;
                    case weaponValues.language_native_name.toLowerCase().trim():
                        csrNumber = parseInt(weaponValues.language_native_score);
                        abilityLossMod = weaponValues.intellect_loss_modifier;
                    break;
                } 
            }
            
            if (!isNaN(csrNumber)) {
                // If we have a number from manual setting or an ability match we set it and stop before parsing through skills
                setAttrs({
                    repeating_weapons_csr: csrNumber,
                    repeating_weapons_ability_loss_modifier: abilityLossMod,
                    repeating_weapons_range: "",
                    repeating_weapons_matched_to_skill: "0"
                });
                return;
            }
            
            // Check if CSR input is a valid skill name, trigger the skill to send variables over if it is
            let weaponMatchedToSkill = false;
            
            getSectionIDs('skills', function(idarray) {
                getAttrs(idarray.map(function(id) { return `repeating_skills_${id}_name`; }).concat( idarray.map(function(id) { return `repeating_skills_${id}_push2weapon`; }) ) , function(skillValues) { 
                    
                    for(var i=0; i < idarray.length; i++) {
                        
                        let skillName = skillValues[`repeating_skills_`+idarray[i]+`_name`];
                        
                        if (csrInput === skillName.toLowerCase().trim()) {
                            
                             
                            let push2weapon = parseInt(skillValues[`repeating_skills_`+idarray[i]+`_push2weapon`])||0;
                            push2weapon = +!push2weapon;
                            
                            setAttrs({
                                [`repeating_skills_`+idarray[i]+`_push2weapon`] : push2weapon
                            });
                            weaponMatchedToSkill = true;
                            break;
                        } 
                    }
                    
                    // if we're matched to a skill after parsing through them we can call it a day.
                    if (weaponMatchedToSkill === true) {
                        return;
                    }
                    
                    // Otherwise we now parse through all the edges to see if we can find a match
                    let weaponMatchedToEdge = false;
                    
                    getSectionIDs('edges', function(idarray2) {
                        getAttrs(idarray2.map(function(id) { return `repeating_edges_${id}_name`; }).concat( idarray2.map(function(id) { return `repeating_edges_${id}_push2weapon`; }) ) , function(edgeValues) { 
                            for(var i=0; i < idarray2.length; i++) {
                                 
                                let edgeName = edgeValues[`repeating_edges_`+idarray2[i]+`_name`];
                                
                                if (csrInput === edgeName.toLowerCase().trim()) {
                                    
                                    let push2weapon = parseInt(edgeValues[`repeating_edges_`+idarray2[i]+`_push2weapon`])||0;
                                    push2weapon = +!push2weapon;
                                    
                                    setAttrs({
                                        [`repeating_edges_`+idarray2[i]+`_push2weapon`] : push2weapon
                                    });
                                    weaponMatchedToEdge = true;
                                    break;
                                }
                            }
                            
                            // if we matched an edge after parsing through them we can call it a day 
                            if (weaponMatchedToEdge === true) {
                                return;
                            }
                            
                            // if after checking both skills and edges we still have no match, we set the csr to -1, which will trigger a message to the user
                            setAttrs({
                                repeating_weapons_csr: "-1",
                                repeating_weapons_ability_loss_modifier: 0,
                                repeating_weapons_range: "",
                                repeating_weapons_matched_to_skill: "0"
                            });
                        });
                    });
                });
            });
        });
    });
    
    // When certain skill variables are changed, or a weapon prompts it to send its variables (via push2weapon), skill variables are copied over to weapons which referance them
    on("change:repeating_skills:push2weapon change:repeating_skills:name change:repeating_skills:skill_score change:repeating_skills:ability_loss_modifier", function() {
       getAttrs(["repeating_skills_name", "repeating_skills_skill_score", "repeating_skills_ability_loss_modifier"], function(skillValues) {
    
            let skillName = skillValues.repeating_skills_name.toLowerCase().trim();
            let skillScore = skillValues.repeating_skills_skill_score;
            let skillsAbilityLossModifier = skillValues.repeating_skills_ability_loss_modifier;
            
            getSectionIDs('weapons', function(idarray) {
                getAttrs(idarray.map(function(id) { return `repeating_weapons_${id}_csr_input`; }), function(weaponValues) { 
                    
                    // Parse through every weapon
                    for(var i=0; i < idarray.length; i++) {
                        // New approach: if Skill name matches weapon's CSR input, transfer over variables
                        // we loop though everything without breaking because multiple weapons can be bound to one skill
                        // Linked weapon is nolonger used and weapon name changes aren't pushed because whilst cleaner this technique didn't allow for multiple linked weapons
                        
                        let weaponCsrInput = weaponValues[`repeating_weapons_`+idarray[i]+`_csr_input`].toLowerCase().trim();
                        
                        if (weaponCsrInput === skillName) {
                            setAttrs({
                                [`repeating_weapons_`+idarray[i]+`_csr`] : skillScore,
                                [`repeating_weapons_`+idarray[i]+`_ability_loss_modifier`] : skillsAbilityLossModifier,
                                [`repeating_weapons_`+idarray[i]+`_range`] : "",
                                [`repeating_weapons_`+idarray[i]+`_matched_to_skill`] : "1"
                            });
                        }
                    }      
                });
            });
        });
    });    
    
    // Triggers reload/refresh in all weapons when influencing variables change - weapon sheet workers register to refresh using change:repeating_weapons:reload
    // (Optimization note to self: much like the other reload scripts, this could be made more effecient. Repeating_weapons:reload would still need to exist due to unique requirements like language_native_score, but could use generic reloads for abilities & loss modifiers rather then listing them all out again. Consider revisiting)
    on("change:strength_rolled change:dexterity_rolled change:fitness_rolled change:intellect_rolled change:will_rolled change:perception_rolled change:attractiveness_rolled change:luck_rolled change:magic_ability_rolled change:base_hth_damage change:strength_loss_modifier change:dexterity_loss_modifier change:fitness_loss_modifier change:intellect_loss_modifier change:will_loss_modifier change:perception_loss_modifier change:attractiveness_loss_modifier change:luck_loss_modifier change:magic_ability_loss_modifier change:language_native_name change:language_native_score", function() {
        getSectionIDs('weapons', (idarray) => {
            getAttrs(idarray.map((id) => `repeating_weapons_${id}_reload`), (values) => {
                for(var i=0; i < idarray.length; i++) {
                    let weaponReload = parseInt(values[`repeating_weapons_`+idarray[i]+`_reload`])||0;
                    weaponReload =+ !weaponReload;
                    setAttrs({
                        [`repeating_weapons_`+idarray[i]+`_reload`] : weaponReload
                    });
                }
            });
        });
    });
    
    // update movement, carrying and throwing
    // (Optimization note to self: This could be improved abit by splitting into two sheet workers. One for dex+fit, one for str+fit, consider revisiting)
    on("change:strength_rolled change:dexterity_rolled change:fitness_rolled", function() { 
        getAttrs(["strength_rolled", "dexterity_rolled", "fitness_rolled"], function(values) {                
            
            let dex = parseInt(values.dexterity_rolled)||0;
            let fit = parseInt(values.fitness_rolled)||0;
            let str = parseInt(values.strength_rolled)||0;
            
            let YardsToFeet = function (yards) {
                return yards*3;
            };
            
            let YardsToMPH = function (yards) {
                return Math.round(yards/3);
            };
            
            let runSpeedYardsPerBT = (Math.max(20, dex));
            let runTime = Math.round(fit/2);
            let run = YardsToFeet(runSpeedYardsPerBT)+"ft/BT ("+YardsToMPH(runSpeedYardsPerBT)+"mph) < "+runTime+"min";
            
            let jogSpeedYardsPerBT = (Math.max(10, Math.round(dex/2)));
            let jogTime = fit*2;
            let jog = YardsToFeet(jogSpeedYardsPerBT)+"ft/BT ("+YardsToMPH(jogSpeedYardsPerBT)+"mph) < "+jogTime+"min";
            
            let walkSpeedYardsPerBT = 7;
            let walkTime = fit*6;
            let walk = YardsToFeet(walkSpeedYardsPerBT)+"ft/BT ("+YardsToMPH(walkSpeedYardsPerBT)+"mph) < "+walkTime+"min";
            
            let crawlSpeedYardsPerBT = 3;
            let crawlTime = fit;
            let crawl = YardsToFeet(crawlSpeedYardsPerBT)+"ft/BT ("+YardsToMPH(crawlSpeedYardsPerBT)+"mph) < "+crawlTime+"min";
            
            let climbSpeedYardsPerBT = Math.round(dex/6);
            let climbUpTimeInBT = Math.round(fit/2);
            let climbDownTimeInBT = fit;
            let climb = YardsToFeet(climbSpeedYardsPerBT)+"ft/BT ("+YardsToMPH(climbSpeedYardsPerBT)+"mph) < "+climbUpTimeInBT+"-"+climbDownTimeInBT+"BT";
            
            let swimSpeedYardsPerBT = Math.round(dex/4);
            let swimTime = fit*3;
            let backstrokeSpeedYardsPerBT = Math.round(swimSpeedYardsPerBT/2);
            let backstrokeTime = swimTime*4;
            let maxPounds = "up to "+str+"lb";
            let swim = YardsToFeet(swimSpeedYardsPerBT)+"ft/BT ("+YardsToMPH(swimSpeedYardsPerBT)+"mph) < "+swimTime+"min";
            let backstroke = YardsToFeet(backstrokeSpeedYardsPerBT)+"ft/BT("+YardsToMPH(backstrokeSpeedYardsPerBT)+"mph)< "+backstrokeTime+"min";
            
            let runningJumpYards = Math.round(str/5);
            let standingJumpYards = Math.round(str/10);
            let runningJump = "up to "+YardsToFeet(runningJumpYards)+"ft";
            let standingJump = "up to "+YardsToFeet(standingJumpYards)+"ft";
            
            let comfortableCarryingPounds = str*2;
            let comfortableCarrying = "up to "+comfortableCarryingPounds+"lb"
            
            let penaltyCarryingPounds = str*5;
            let penaltyCarryingTimeBT = fit;
            let penaltyCarrying = "up to "+penaltyCarryingPounds+"lb < "+penaltyCarryingTimeBT+"BT";
            
            let draggingPounds = str*10;
            let dragging = "up to "+draggingPounds+"lb"
            
            let throwingDistanceYards = 20 + str;
            let throwing = "up to "+YardsToFeet(throwingDistanceYards)+"ft"
    
            let throwingSpearDistanceYards = 40 + str;
            let throwingSpear = "up to "+YardsToFeet(throwingSpearDistanceYards)+"ft"
            
            setAttrs({
                movement_running: run,
                movement_jogging: jog,
                movement_walking: walk,
                movement_crawling_prone: crawl,
                movement_climbing: climb,
                movement_swimming: swim,
                movement_backstroke: backstroke,
                movement_jump_running: runningJump,
                movement_jump_standing: standingJump,
                carrying_comfortably: comfortableCarrying,
                carrying_causing_penalty: penaltyCarrying,
                dragging: dragging,
                throwing: throwing,
                throwing_spear: throwingSpear,
                carrying_swimming: maxPounds 
            });
        });
    });
    
    // Updates healing rates
    // (Optimization note to self: Is this perhaps overkill? There's a big overhead for an extremely small return here.  Consider revisiting.)
    on("change:fitness_rolled change:strength_max change:dexterity_max change:fitness_max change:intellect_max change:will_max change:perception_max change:attractiveness_max change:luck_max change:magic_ability_max change:strength change:dexterity change:fitness change:intellect change:will change:perception change:attractiveness change:luck change:magic_ability", function() { 
        getAttrs(["fitness_rolled", "strength_max", "dexterity_max", "fitness_max", "intellect_max", "will_max", "perception_max", "attractiveness_max", "luck_max", "magic_ability_max", "strength", "dexterity", "fitness", "intellect", "will", "perception", "attractiveness", "luck", "magic_ability"], function(values) {                
            
            let fitRolled = parseInt(values.fitness_rolled)||0;
            let fitMax = parseInt(values.fitness_max)||0;
            
            let spHealingRate = Math.round(fitRolled/10);
            let abilityHealingRate = Math.round(fitMax/10);
            
            let abilitiesDamaged = 0;
            
            let IsAbilityDamaged = function (temp, max) {
                
                let maxInt = parseInt(max)||0;
                
                if ( (parseInt(temp)||maxInt) < maxInt ) {
                    abilitiesDamaged++;
                } 
            };
            
            IsAbilityDamaged(values.strength, values.strength_max);
            IsAbilityDamaged(values.dexterity, values.dexterity_max);
            IsAbilityDamaged(values.fitness, fitMax);
            IsAbilityDamaged(values.intellect, values.intellect_max);
            IsAbilityDamaged(values.will, values.will_max);
            IsAbilityDamaged(values.perception, values.perception_max);
            IsAbilityDamaged(values.attractiveness, values.attractiveness_max);
            IsAbilityDamaged(values.luck_rolled, values.luck_max);
            IsAbilityDamaged(values.magic_ability, values.magic_ability_max);
            
            let spHealing;
            if (abilitiesDamaged > 0) {
                spHealing = "Basic Abilities heal first";
            } else {
                spHealing = spHealingRate+" SP/24hrs";
            }
            
            let abilityHealing = abilityHealingRate+" score/week" 
            
            setAttrs({
                healing_normal: spHealing,
                healing_ability_damage: abilityHealing 
            });
        });
    });
    
    // Calculates the values for all the income fields whenever the job skill or editable income fields are changed 
    on("change:job_skill_name change:job_skill_score change:monthly_expenses change:business_owner change:business", function() { 
        getAttrs(["job_skill_name", "job_skill_score", "monthly_expenses", "business_owner", "business"], function(values) {                
            
            let skillName = values.job_skill_name;
            skillName = skillName.toLowerCase();
            skillName = skillName.replace(/\s+/g, '');
            let skillScore = parseInt(values.job_skill_score)||0;
            let monthlyExpenses = parseInt(values.monthly_expenses)||0;
            let businessOwner = values.business_owner;
            let weeklyExpenses = Math.round(monthlyExpenses/4.345);
            let business = parseInt(values.business)||0;
            
            if (businessOwner === "on") {
                skillScore = Math.min(skillScore, business);   
            }
            
            let normalWeeklyIncome = 0;
            if (skillName === "business,criminal"){
                normalWeeklyIncome = skillScore*20;
            } else {
                normalWeeklyIncome = skillScore*10;
            }
            
            let luckSuccessIncome = 0;
            let luckAutoSuccessIncome = 0;
            let luckAutoFailureIncome = 0;
            luckSuccessIncome =  Math.round(normalWeeklyIncome + (normalWeeklyIncome*0.1));
            luckAutoSuccessIncome = normalWeeklyIncome*2; 
            luckAutoFailureIncome = Math.round(normalWeeklyIncome/2);
            
            normalWeeklyIncome -= weeklyExpenses;
            luckSuccessIncome -= weeklyExpenses;
            luckAutoSuccessIncome -= weeklyExpenses;
            luckAutoFailureIncome -= weeklyExpenses;
            
            setAttrs({
                weekly_income: normalWeeklyIncome,
                luck_success_income: luckSuccessIncome,
                luck_auto_success_income: luckAutoSuccessIncome,
                luck_auto_failure_income: luckAutoFailureIncome
            });
        });
    });
    
    // Updates the evade attempts fields when perception rolled changes
    // (Optimization note to self: it would probably be more optimal to just move this into the main perception ability sheet worker, consider revisiting.)
    on("change:perception_rolled", function() { 
        getAttrs(["perception_rolled"], function(values) {                
            let perceptionRolled = parseInt(values.perception_rolled)||0;
            let evadeAttempts = Math.round(perceptionRolled/10);
            evadeAttempts = evadeAttempts+"/BT";
            
            setAttrs({
                evade_attempts: evadeAttempts
            });
        });
    });
    
    // Updates Total root magic items worn 
    // (Note to self: the variable names defined in this function are potentially misleading, consider revisiting)
    on("change:repeating_wearables:root_magic change:repeating_wearables:worn", function() { 
        getAttrs(["repeating_wearables_worn","repeating_wearables_root_magic", "repeating_wearables_root_magic_summed", "root_magic_worn"], function(values) {                
            
            let newRootMagicSummed; 
            if (values.repeating_wearables_root_magic === "on" && values.repeating_wearables_worn === "on") {
               newRootMagicSummed = 1;
            } else {
               newRootMagicSummed = 0; 
            }
            
            let oldRootMagicSummed = parseInt(values.repeating_wearables_root_magic_summed)||0;
            
            let totalRootMagicWornFieldValue = parseInt(values.root_magic_worn)||0;
            
            if (newRootMagicSummed !== oldRootMagicSummed) {
                totalRootMagicWornFieldValue += (newRootMagicSummed - oldRootMagicSummed);
                oldRootMagicSummed = newRootMagicSummed;
            }
            
            setAttrs({
                repeating_wearables_root_magic_summed: oldRootMagicSummed,
                root_magic_worn: totalRootMagicWornFieldValue
            });
        });
    });
    
    // Updates Total attacker CSR (from wearables)
    on("change:repeating_wearables:attacker_csr_modifier change:repeating_wearables:worn", function() { 
        getAttrs(["repeating_wearables_worn","repeating_wearables_attacker_csr_modifier", "repeating_wearables_attacker_csr_modifier_summed", "attacker_csr"], function(values) {                
            let newAttackerCsrModifier =  parseInt(values.repeating_wearables_attacker_csr_modifier)||0;
            let oldAttackerCsrModifier = parseInt(values.repeating_wearables_attacker_csr_modifier_summed)||0;
            let totalAttackerCsrModifier = parseInt(values.attacker_csr)||0;
            
            if (values.repeating_wearables_worn !== "on") {
                newAttackerCsrModifier = 0;
            }
            
            if (newAttackerCsrModifier !== oldAttackerCsrModifier) {
                totalAttackerCsrModifier += (newAttackerCsrModifier - oldAttackerCsrModifier);
                oldAttackerCsrModifier = newAttackerCsrModifier;
            }
            
            setAttrs({
                repeating_wearables_attacker_csr_modifier_summed: oldAttackerCsrModifier,
                attacker_csr: totalAttackerCsrModifier
            });
        });
    });
    
    // Updates Total attacker CSR (from weapons)
    on("change:repeating_weapons:attacker_csr_modifier change:repeating_weapons:enchanted change:repeating_weapons:active", function() { 
        getAttrs(["repeating_weapons_attacker_csr_modifier","repeating_weapons_enchanted", "repeating_weapons_active", "repeating_weapons_attacker_csr_modifier_summed", "attacker_csr"], function(values) {                
            let newAttackerCsrModifier =  parseInt(values.repeating_weapons_attacker_csr_modifier)||0;
            let oldAttackerCsrModifier = parseInt(values.repeating_weapons_attacker_csr_modifier_summed)||0;
            let totalAttackerCsrModifier = parseInt(values.attacker_csr)||0;
            
            if (values.repeating_weapons_enchanted !== "1" || values.repeating_weapons_active !== "on" ) {
                newAttackerCsrModifier = 0;
            }
            
            if (newAttackerCsrModifier !== oldAttackerCsrModifier) {
                totalAttackerCsrModifier += (newAttackerCsrModifier - oldAttackerCsrModifier);
                oldAttackerCsrModifier = newAttackerCsrModifier;
            }
            
            setAttrs({
                repeating_weapons_attacker_csr_modifier_summed: oldAttackerCsrModifier,
                attacker_csr: totalAttackerCsrModifier
            });
        });
    });
    
    // Updates Total ability boost from wearables
    on("change:repeating_wearables:add_value change:repeating_wearables:add_ability change:repeating_wearables:worn", function() { 
        getAttrs(["repeating_wearables_worn","repeating_wearables_add_value","repeating_wearables_add_ability", "repeating_wearables_add_value_summed", "strength_item", "dexterity_item", "fitness_item", "intellect_item", "will_item", "perception_item", "attractiveness_item", "luck_item", "magic_ability_item", "humanity_item", "repeating_wearables_add_ability_old"], function(values) {                
            
            let newValue = parseInt(values.repeating_wearables_add_value)||0;
            let oldValue = parseInt(values.repeating_wearables_add_value_summed)||0;
            let newAbility = values.repeating_wearables_add_ability;
            let oldAbility = values.repeating_wearables_add_ability_old;
            
            let totalAbilityValue = parseInt(values[newAbility+"_item"])||0;
            let totalOldAbilityValue = parseInt(values[oldAbility+"_item"])||0;
            
            if (newAbility !== oldAbility) {
                
                setAttrs({
                    [oldAbility+"_item"]: (totalOldAbilityValue-oldValue)
                });
                oldAbility = newAbility;
                oldValue = 0;
            }
            
            if (values.repeating_wearables_worn !== "on") {
                newValue = 0;
            }
            
            if (newValue !== oldValue) {
                totalAbilityValue += (newValue - oldValue);
                oldValue = newValue;
            }
            
            setAttrs({
                repeating_wearables_add_ability_old: oldAbility,
                repeating_wearables_add_value_summed: oldValue,
                [newAbility+"_item"]: totalAbilityValue
            });
        });
    });
    
    // Update relevant global vars if wearable is deleted
    on("remove:repeating_wearables", function(eventinfo) {
        getAttrs(["strength_item", "dexterity_item", "fitness_item", "intellect_item", "will_item", "perception_item", "attractiveness_item", "luck_item", "magic_ability_item", "humanity_item", "attacker_csr", "root_magic_worn"], function(values) {
            if (eventinfo.removedInfo[eventinfo.sourceAttribute+"_worn"] !== "0") {
                let value = parseInt(eventinfo.removedInfo[eventinfo.sourceAttribute+"_add_value"])||0;
                let ability = eventinfo.removedInfo[eventinfo.sourceAttribute+"_add_ability"]||"attractiveness";
                let totalAbilityValue = parseInt(values[ability+"_item"])||0;
                totalAbilityValue -= value;
                
                let attackerCsrModifier = parseInt(eventinfo.removedInfo[eventinfo.sourceAttribute+"_attacker_csr_modifier"])||0;
                let totalAttackerCsrModifier = parseInt(values.attacker_csr)||0;
                totalAttackerCsrModifier -= attackerCsrModifier;
                
                let rootMagic; 
                if (eventinfo.removedInfo[eventinfo.sourceAttribute+"_root_magic"] === "on") {
                   rootMagic = 1;
                } else {
                   rootMagic = 0; 
                }
                let totalRootMagicWorn = parseInt(values.root_magic_worn)||0;
                totalRootMagicWorn -= rootMagic;
                
                setAttrs({
                    root_magic_worn: totalRootMagicWorn,
                    attacker_csr: totalAttackerCsrModifier,
                    [ability+"_item"]: totalAbilityValue
                });
            }
        });
    });
    
    // Update total attacker csr mod if a weapon granting it is removed
    on("remove:repeating_weapons", function(eventinfo) {
        getAttrs(["attacker_csr"], function(values) {
            if (eventinfo.removedInfo[eventinfo.sourceAttribute+"_enchanted"] === "on" && eventinfo.removedInfo[eventinfo.sourceAttribute+"_active"] === "on" ) {
                let attackerCsrModifier = parseInt(eventinfo.removedInfo[eventinfo.sourceAttribute+"_attacker_csr_modifier"])||0;
                let totalAttackerCsrModifier = parseInt(values.attacker_csr)||0;
                totalAttackerCsrModifier -= attackerCsrModifier;
                
                setAttrs({
                    attacker_csr: totalAttackerCsrModifier
                });
            }
        });
    });
    
    // Sets a wearable being worn to not-worn if its nolonger carried
    on("change:repeating_wearables:carried", function() { 
        getAttrs(["repeating_wearables_carried"], function(values) {     
            if (values.repeating_wearables_carried !== "on") {
                setAttrs({
                    repeating_wearables_worn: 0
                });
            }
        });
    });
    
    // Hides weapon bar ammo fields if no ammo has been input
    on("change:repeating_weapons:ammo_capacity", function() { 
        getAttrs(["repeating_weapons_ammo_capacity"], function(values) {                
            
            let showAmmo = 0;
            
            if ( (parseInt(values.repeating_weapons_ammo_capacity)||0) === 0 ) {
                showAmmo = 0;
            } else {
                showAmmo = "on";
            }
            
            setAttrs({
                repeating_weapons_show_ammo: showAmmo
            });
        });
    });
    
    // Set if weapon damage value is locked and potentially set the value itself depending on what's put in the damage potential field, also controls visiblity of the add tickboxes and wipes them when thier hidden, also controls visiblity for divided by field
    on("change:repeating_weapons:damage_divider change:repeating_weapons:csr change:repeating_weapons:dp_input change:repeating_weapons:reload", function() { 
        getAttrs(["repeating_weapons_dp_input", "repeating_weapons_dp", "repeating_weapons_inc_hth", "repeating_weapons_inc_claws", "base_hth_damage", "repeating_weapons_csr", "repeating_weapons_damage_divider"], function(values) {                
            
            let damageValue = parseInt(values.repeating_weapons_dp)||0;
            let baseHthDamage = parseInt(values.base_hth_damage)||0; 
            let lockDamageValue = 0;
            let addHth = values.repeating_weapons_inc_hth;
            let addClaws = values.repeating_weapons_inc_claws;
            let showDamageDivider = 0;
            let showClawsInsteadOfHTH = 0;
            
            let divider;
            switch(values.repeating_weapons_dp_input) {
                case "Set Value":
                    addClaws = 0;
                break;
                case "HTH":
                    lockDamageValue = "on";
                    showClawsInsteadOfHTH = 1;
                    damageValue = baseHthDamage;
                    addHth = 0;
                break;
                case "HTHx2":
                    lockDamageValue = "on";
                    showClawsInsteadOfHTH = 1;
                    damageValue = baseHthDamage*2;
                    addHth = 0;
                break;
                case "CSR":
                    lockDamageValue = "on";
                    showDamageDivider = 1;
                    divider = parseFloat(values.repeating_weapons_damage_divider)||0;
                    if (divider === 0) {
                        divider = 1;
                    }
                    damageValue = (parseInt(values.repeating_weapons_csr)||0)/divider;
                    damageValue = Math.round(damageValue);
                    addClaws = 0;
                break;
            }
            
            setAttrs({
                repeating_weapons_dp: damageValue,
                repeating_weapons_lock_damage_value: lockDamageValue,
                repeating_weapons_inc_hth: addHth,
                repeating_weapons_inc_claws: addClaws,
                repeating_weapons_show_damage_divider: showDamageDivider,
                repeating_weapons_show_claws_instead_of_hth: showClawsInsteadOfHTH
            });
        });
    });
    
    // Reacts to changes in weapon target: sets the visiblity of the rounds fired field and sets the target roll value (used by roll button for figuring out how many targets are hit)
    on("change:repeating_weapons:target", function() { 
        getAttrs(["repeating_weapons_target"], function(values) {                
            
            let showRoundsFired = 0;
            let targetsRoll = 1;
            
            switch(values.repeating_weapons_target) {
                case "Semiautomatic":
                    showRoundsFired = "on";
                    targetsRoll = "1d5"
                break;
                case "Automatic":
                    showRoundsFired = "on";
                    targetsRoll = "1d10"
                break;
            }
            
            setAttrs({
                repeating_weapons_show_rounds_fired: showRoundsFired,
                repeating_weapons_targets_roll: targetsRoll
            });
        });
    });
    
    // Limits the values of the rounds fired field based on the weapon target, then sets the max targets (used by roll button for figuring out how many targets are hit)
    on("change:repeating_weapons:target change:repeating_weapons:rounds_fired", function() { 
        getAttrs(["repeating_weapons_target", "repeating_weapons_rounds_fired"], function(values) {                
            
            let roundsFired = parseInt(values.repeating_weapons_rounds_fired)||0;
            let targetsMax = 10;
            
            switch(values.repeating_weapons_target) {
                case "Single":
                    roundsFired = 1;
                    targetsMax = 1;
                break;
                case "Semiautomatic":
                    roundsFired = Math.min(Math.max(roundsFired, 2), 10);
                    targetsMax = Math.round(roundsFired/2);
                break;
                case "Automatic":
                    roundsFired = Math.ceil(Math.max(roundsFired, 1) / 10) * 10;
                    if (roundsFired === 20) {
                        targetsMax = 6;
                    }
                    if (roundsFired === 10) {
                        targetsMax = 3;
                    }
                break;
            }
            
            setAttrs({
                repeating_weapons_rounds_fired: roundsFired,
                repeating_weapons_targets_max: targetsMax
            });
        });
    });
    
    // Sets initiative variables (used by roll button) based on the setting checkboxes for initative
    on("change:initiative_rules", function() { 
        getAttrs(["initiative_rules"], function(values) {                
            
            let useNormalInitiative = 0, 
            useStreetVelocityInitiative = 0, 
            useHouseruledInitiative = 0;
    
            switch (parseInt(values.initiative_rules)||0) {
                case 0:
                    useNormalInitiative = 1;
                break;
                case 1:
                    useStreetVelocityInitiative = 1; 
                break;
                case 2:
                    useHouseruledInitiative = 1;  
                break;
            }
    
            setAttrs({
                initiative_rules_normal: useNormalInitiative,
                initiative_rules_streetvelocity: useStreetVelocityInitiative,
                initiative_rules_houseruled: useHouseruledInitiative
            });
        });
    });
</script>
