- const varObjects = {repeatingSectionDetails:[],actionAttributes:[],cascades:{attr_character_name:{name:'character_name',type:'text',defaultValue:'',affects:[],triggeredFuncs:['setActionCalls'],listenerFunc:'accessSheet',listener:'change:character_name'}},docs:{js:{},pug:{}}};
- let selectName = null;
- let selectTitle = null;
- let repeatingPrefix = '';
- const pugDoc = require
//- Element shortcut mixins
-
  varObjects.docs.pug.trigger = {
    type:'argument',
    description:"Many of the K-scaffold's mixins utilize the scaffold's trigger system. Triggers can be passed in any mixin that creates an attribute backed element, which is any element that you would give the `name` property to. The trigger is passed as a property of the object that defines the attribute backed element. See the [input mixin](#input) below for a simple example.\nTriggers are how the K-scaffold connects the attributes created in the html of the sheet with the javscript listeners to trigger sheetworker code. When accessed from a sheetworker, a trigger has all of the below properties. When passing a trigger into a mixin, it should only have any or all of the first four properties; `affects`,`initialFunc`, `calculation`, `triggeredFuncs`, and `listenerFunc`. Note that except for `listenerFunc`, the function that is called is passed arguments using the [destructuring assignment pattern](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment). This means that the functions referenced in ,`initialFunc`, `calculation`, and `triggeredFuncs` must be passed in an object associated with a key named as indicated in the arguments below.",
    arguments:[
      {type:'Array',name:'affects',description:'An array of attribute names that this attribute might affect. As an example, the `strength` attribute in a 5e based sheet would have `strength_mod` in its affects array.'},
      {type:'string',name:'initialFunc',description:'The name of a function that has been registered with the K-scaffold using [k.registerFuncs](https://github.com/Kurohyou/Roll20-Snippets/blob/main/K_Scaffold/readme_docs/k_scaffold_js_documentation.md#registerFuncs). This function will only be called if the change to the attribute is directly caused by the user as opposed to being changed by the sheetworkers.\nThe K-scaffold sends this function the following arguments:\n- `trigger`: The trigger object for the attribute that is being changed\n- `attributes`: the attributes object containing the entire state of the sheet.\n- `sections`: An object containing the row IDs of all the repeating sections, indexed by section name (e.g. repeating_equipment).'},
      {type:'string',name:'calculation',description:'The name of a function that has been registered with the K-scaffold using [k.registerFuncs](https://github.com/Kurohyou/Roll20-Snippets/blob/main/K_Scaffold/readme_docs/k_scaffold_js_documentation.md#registerFuncs). This function must return the calculated value of the attribute it is for, and is only called if the attribute is not changed directly by the user. Ideally, this function should be written as a pure function, reacting only to the arguments it is passed, and returning a value without modifying any of the arguments it is passed.\nThe K-scaffold sends this function the following arguments:\n- `trigger`: The trigger object for the attribute that is being changed\n- `attributes`: the attributes object containing the entire state of the sheet.\n- `sections`: An object containing the row IDs of all the repeating sections, indexed by section name (e.g. repeating_equipment).'},
      {type:'Array',name:'triggeredFuncs',description:'An array of function names that have been registered with the K-scaffold using [k.registerFuncs](https://github.com/Kurohyou/Roll20-Snippets/blob/main/K_Scaffold/readme_docs/k_scaffold_js_documentation.md#registerFuncs). These functions are called any time an attribute is changed, regardless of the source of the change, do not return any values, and will likely modify the arguments that are passed to them. These functions are used for doing complex logic to determine what should be done in response to a change.\nThe K-scaffold sends these functions the following arguments:\n- `trigger`: The trigger object for the attribute that is being changed\n- `attributes`: the attributes object containing the entire state of the sheet.\n- `sections`: An object containing the row IDs of all the repeating sections, indexed by section name (e.g. repeating_equipment), and in the order that they appear on the sheet.'},
      {type:'string',name:'listenerFunc',description:'The name of a function that has been registered with the K-scaffold using [k.registerFuncs](https://github.com/Kurohyou/Roll20-Snippets/blob/main/K_Scaffold/readme_docs/k_scaffold_js_documentation.md#registerFuncs). This function will be called directly from the event listener for this attribute instead of the default [accessSheet](https://github.com/Kurohyou/Roll20-Snippets/blob/main/K_Scaffold/readme_docs/k_scaffold_js_documentation.md#accesssheet) listener function. If a `listenerFunc` is specified, the automated handling of the rest of the previous trigger properties will be disabled. You can still use these properties, but will need to code that handling yourself.\nThe K-scaffold sends this function the following argument:\n- `event`: The event information object that is passed to the callback in the [sheet worker event listener](https://wiki.roll20.net/Sheet_Worker_Scripts#Event_listener). This is **NOT** passed using the object destructuring pattern, unlike the previous three function types.'},
      {type:'string',name:'name',description:'The name of the attribute. When accessed from inside the default function cascade of the K-scaffold, or the callback of [getAllAttrs](https://github.com/Kurohyou/Roll20-Snippets/blob/main/K_Scaffold/readme_docs/k_scaffold_js_documentation.md#getAllAttrs), repeating attributes will include their specific row id for that instance of the attribute.'},
      {type:'string',name:'type',description:'What type of attribute is this. This is determined by the type of element that first created the trigger. Can be `text`,`number`,`checkbox`,`select`,or `radio`, but will usually be `text` or `number` based on the type of default value that is assigned to the attribute.'},
      {type:'string|number',name:'defaultValue',description:'What the default value of the attribute is. The k-scaffold uses this to return the default value in the event the value of the attribute becomes corrupted. For checkboxes and radios, this is determined based on the check state of the element. For selects, this is determined by which option has the `selected` property.'}
    ]
  };
-
  varObjects.docs.pug.input = {
    type:'mixin',
    description:'A generic mixin to create an input. The mixin will replace spaces in the attribute name with underscores and will add a title property if one isn\'t supplied that will inform the user what the attribute call for the attribute is.',
    arguments:[
      {type:'object',name:'obj',description:'An object containing all of the properties to apply to the element. Must have the properties; `name` and `type`. Can have any property that is valid for an input element. May also have a [trigger](#trigger) property'},
        {type:'string',name:'obj.name',}
    ],
    example:[
      [
        `+input({name:'my attribute',type:'text',class:'some-class',trigger:{affects:['other_attribute']}})'`,
        `<input name="attr_my_attribute" type="text" class="some-class">'`
      ]
    ]
  };
mixin input(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - obj.name = replaceSpaces(obj.name);
  - obj.title = obj.title || attrTitle(obj.name);
  - obj.name = `attr_${obj.name}`;
  - const elementObj = makeElementObj(obj);
  - addFieldToFieldsetObj(obj);
  - storeTrigger(obj);
  input&attributes(elementObj)&attributes(attributes)
//-End Mixin
-
  varObjects.docs.pug.text = {
    type:'mixin',
    description:'Alias for [input](#input) that makes a text input.',
    example:[
      [
        `+text({name:'my text',class:'some-class',trigger:{affects:['other_attribute']}})`,
        '<input type="text" name="attr_my_text" class="some-class">'
      ]
    ]
  };
mixin text(obj)
  - obj.type = 'text';
  +input(obj)
//-End Mixin
-
  varObjects.docs.pug.checkbox = {
    type:'mixin',
    description:'Alias for [input](#input) that makes a checkbox input.',
    example:[
      [
        `+checkbox({name:'my checkbox',class:'some-class',trigger:{affects:['other_attribute']}})`,
        '<input type="checkbox" name="attr_my_checkbox" class="some-class">'
      ]
    ]
  };
mixin checkbox(obj)
  - obj.type = 'checkbox';
  +input(obj)&attributes(attributes)
//-End Mixin
-
  varObjects.docs.pug.collapse = {
    type:'mixin',
    description:'Alias for [checkbox](#checkbox) that creates a checkbox for use in collapsing/expanding a section. Sets the checkbox to unchecked with a checked value of `1` and a class of `collapse`. Additional classes/ids can be applied by applying them inline to the mixin call.',
    arguments:[
      {type:'string',name:'name',description:'The name to assign to the collapse button. Defaults to `collapse`'}
    ]
  };
mixin collapse(name='collapse')
  +checkbox({name,value:1,class:'collapse'})&attributes(attributes)
-
  varObjects.docs.pug.radio = {
    type:'mixin',
    description:'Alias for [input](#input) that makes a radio input.',
    example:[
      [
        `+radio({name:'my radio',class:'some-class',trigger:{affects:['other_attribute']}})`,
        '<input type="radio" name="attr_my_radio" class="some-class">'
      ]
    ]
  };
mixin radio(obj)
  - obj.type = 'radio';
  +input(obj)
//-End Mixin
-
  varObjects.docs.pug.number = {
    type:'mixin',
    description:'Alias for [input](#input) that makes a number input.',
    example:[
      [
        `+number({name:'my number',class:'some-class',trigger:{affects:['other_attribute']}})`,
        '<input type="number" name="attr_my_number" class="some-class">'
      ]
    ]
  };
mixin number(obj)
  - obj.type = 'number';
  +input(obj)
//-End Mixin
-
  varObjects.docs.pug.range = {
    type:'mixin',
    description:'Alias for [input](#input) that makes a range input.',
    example:[
      [
        `+range({name:'my range',class:'some-class',trigger:{affects:['other_attribute']}})`,
        '<input type="range" name="attr_my_range" class="some-class">'
      ]
    ]
  };
mixin range(obj)
  - obj.type = 'range';
  +input(obj)
//-End Mixin
-
  varObjects.docs.pug.hidden = {
    type:'mixin',
    description:'Alias for [input](#input) that makes a hidden input.',
    example:[
      [
        `+hidden({name:'my hidden',class:'some-class',trigger:{affects:['other_attribute']}})`,
        '<input type="hidden" name="attr_my_hidden" class="some-class">'
      ]
    ]
  };
mixin hidden(obj)
  - obj.type = 'hidden';
  +input(obj)
//-End Mixin
mixin radioGroup(objArray)
  each obj in objArray
    - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
    - obj.type='radio';
    +input(obj)
//-End Mixin
-
  varObjects.docs.pug.fillLeft = {
    type:'mixin',
    description:`A mixin that creates a construction that can be used to recreate sheet mechanics that fill to the left. Will apply BEM style classes in addition to the classes specified. BEM classes that can be applied are
    - \`fill-left\`: The class for the fill-left container.
    - \`fill-left__radio\`: The class applied to all the radio buttons in the container
    - \`fill-left__radio--clearer\`: The class applied to the clear value radio button`,
    arguments:[
      {type:'object',name:'radioObj',description:'The object containing the details of the radio input to create. Similar to the [radio mixin](#radio), but the value property passed is used as the default checked value.'},
      {type:'object',name:'divObj',description:'Optional object containing any details of the div to be applied such as class, id, or other properties. Class and ID can also be supplied by attaching them to the mixin invocation just like with a regular div.'},
      {type:'array',name:'valueArray',description:'Array containing the values to be used for the fill to left construction. These should be in the order that they should be displayed left to right.'},
      {name:'noClear',type:'boolean',description:'Optional argument that tells the mixin whether or not to apply the `fill-left__radio--clearer` class to the first radio button value. If falsy (or not passed), the class is applied. If truthy, the class is not applied.'}
    ],
    example:[
      [
        `+fillLeft({radioObj:{name:'track',class:'some-class',value:"0"},valueArray:[0,1,2]})`,
        `<div class="fill-left">\n  <input type="radio" name="attr_track" class="some-class fill-left__radio fill-left__radio--clearer" value="0" checked>\n  <input type="radio" name="attr_track" class="some-class fill-left__radio" value="1">\n  <input type="radio" name="attr_track" class="some-class fill-left__radio" value="2">\n</div>`
      ],
      [
        `+fillLeft({radioObj:{name:'track',class:'some-class',value:"0"},valueArray:[0,1,2],noClear:true})`,
        `<div class="fill-left">\n  <input type="radio" name="attr_track" class="some-class fill-left__radio" value="0" checked>\n  <input type="radio" name="attr_track" class="some-class fill-left__radio" value="1">\n  <input type="radio" name="attr_track" class="some-class fill-left__radio" value="2">\n</div>`
      ],
      [
        `+fillLeft({radioObj:{name:'track',class:'some-class',value:"0"},valueArray:[0,1,2],divObj:{'aria-label':'Accessible tracker'}}).custom-tracker-class`,
        `<div class="fill-left custom-tracker-class" aria-label:"Accessible tracker">\n  <input type="radio" name="attr_track" class="some-class fill-left__radio fill-left__radio--clearer" value="0" checked>\n  <input type="radio" name="attr_track" class="some-class fill-left__radio" value="1">\n  <input type="radio" name="attr_track" class="some-class fill-left__radio" value="2">\n</div>`
      ],
    ]
  };
mixin fillLeft({radioObj,divObj,valueArray,noClear})
  - divObj = divObj || {};
  .fill-left&attributes(divObj)&attributes(attributes)
    each value,index in valueArray
      - const usedObj = {...radioObj,value};
      -
        usedObj.class = usedObj.class ? 
          `${usedObj.class} fill-left__radio` :
          `fill-left__radio`;
      if value === radioObj.value
        - usedObj.checked = '';
      if !noClear && index === 0
        - usedObj.class = `${usedObj.class} fill-left__radio--clearer`;
      
      +radio(usedObj)
//- End Mixin
-
  varObjects.docs.pug.textarea = {
    type:'mixin',
    description:'Functions like [input](#input), but creates a textarea instead.',
    example:[
      [
        `+textarea({name:'my hidden',class:'some-class',placeholder:'Placeholder text',trigger:{affects:['other_attribute']}})`,
        '<textarea type="hidden" name="attr_my_hidden" class="some-class">Placeholder text</textarea>'
      ]
    ]
  };
mixin textarea(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - obj.name = replaceSpaces(obj.name);
  - obj.title = obj.title || attrTitle(obj.name);
  - obj.name = `attr_${obj.name}`;
  - addFieldToFieldsetObj(obj);
  - storeTrigger(obj);
  - const elementObj = makeElementObj(obj);
  textarea&attributes(elementObj)
//-End Mixin
-
  varObjects.docs.pug.option = {
    type:'mixin',
    description:'Creates an option attribute. Also stores the trigger for the select that the option is part of. See [select](#select) for example uses.'
  };
mixin option(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - const triggerObj = {...obj,name:selectName,title:selectTitle,type:'select'};
  - const elementObj = makeElementObj(obj);
  - storeTrigger(triggerObj);
  option&attributes(elementObj)
    block
//-End Mixin
-
  varObjects.docs.pug.select = {
    type:'mixin',
    description:'Functions like [input](#input), but creates a select instead.',
    example:[
      [
        `+select({name:'my select',class:'some-class'})\n  +option({value:'option 1','data-i18n':'some-text',trigger:{affects:['some-attribute']}})\n  +option({value:'option 2','data-i18n':'other-text'})`,
        '<select name="attr_my_select" class="some-class">\n  <option value="option 1" data-i18n="some-text"></option>\n  <option value="option 2" data-i18n="other-text"></option>\n</select>'
      ]
    ]
  };
mixin select(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - obj.name = replaceSpaces(obj.name);
  - obj.title = obj.title || attrTitle(obj.name);
  - obj.name = `attr_${obj.name}`;
  - selectName = obj.name;
  - selectTitle = obj.title;
  - addFieldToFieldsetObj(obj);
  select&attributes(obj)
    if block
      block
    else
      +option({value:'empty select, PEBKAC',selected:true})
//-End Mixin
-
  varObjects.docs.pug.img = {
    type:'mixin',
    description:'Functions like [input](#input), but creates an img instead. The name property is optional.',
    example:[
      [
        `+img({name:'my image',src:'my_image.jpg',class:'some-class'})`,
        '<img name="attr_my_image" src="my_image.jpg" class="some-class">'
      ]
    ]
  };
mixin img(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - obj['data-i18n-alt'] = obj['data-i18n-alt'] || obj.name;
  - obj.name = replaceSpaces(obj.name);
  - obj.title = obj.title || attrTitle(obj.name);
  - obj.name = `attr_${obj.name}`;
  img&attributes(obj)
//-End Mixin
-
  varObjects.docs.pug.img = {
    type:'mixin',
    description:'Functions like [input](#input), but creates a span instead. The name property is optional.',
    example:[
      [
        `+span({name:'my span',class:'some-class'})`,
        '<span name="attr_my_span" class="some-class"></span>'
      ]
    ]
  };
mixin span(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  if obj.name
    - obj.name = replaceSpaces(obj.name);
    - obj.title = obj.title || attrTitle(obj.name);
    - obj.name = `attr_${obj.name}`;
    - addFieldToFieldsetObj(obj);
  - const elementObj = makeElementObj(obj);
  span&attributes(elementObj)
    block
  if obj.name
    - obj.type = 'span';
    - storeTrigger(obj);
//-End Mixin
-
  varObjects.docs.pug.datalist = {
    type:'mixin',
    description:'Functions like [input](#input), but creates a datalist instead. Note that an ID should never be put inside a repeating section, although you can reference one from inside the repeating section.',
    example:[
      [
        `+select({name:'my select',list:'my-data'})\n+datalist({id:'my-data'})\n  +option({value:'option 1','data-i18n':'some-text',trigger:{affects:['some-attribute']}})\n  +option({value:'option 2','data-i18n':'other-text'})`,
        '<select name="attr_my_select" class="some-class"></select><datalist id="my-data">\n  <option value="option 1" data-i18n="some-text"></option>\n  <option value="option 2" data-i18n="other-text"></option>\n</datalist>'
      ]
    ]
  };
mixin datalist(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  datalist&attributes(obj)
    block
//-End Mixin
mixin div(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  if obj.name
    - obj.name = replaceSpaces(obj.name);
    - obj.title = obj.title || attrTitle(obj.name);
    - obj.name = `attr_${obj.name}`;
  div&attributes(obj)
    block
//-End Mixin
mixin h1(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  h1&attributes(obj)
    block
//-End Mixin
mixin h2(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  h2&attributes(obj)
    block
//-End Mixin
mixin h3(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  h3&attributes(obj)
    block
//-End Mixin
mixin h4(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  h4&attributes(obj)
    block
//-End Mixin
mixin h5(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  h5&attributes(obj)
    block
//-End Mixin
mixin h6(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  h6&attributes(obj)
    block
//-End Mixin
mixin p(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  p&attributes(obj)
    block
//-End Mixin
-
  varObjects.docs.pug.button = {
    type:'mixin',
    description:'Creates a button element. Valid types are `roll` or `action`. If a type is not specified in the object argument, a roll button is created. If an action button is created, spaces in the name are replaced with dashes instead of underscores.',
    example:[
      [
        `+button({name:'my button',value:'/r 3d10'})`,
        '<button type="roll" name="roll_my_button" value="/r 3d10"></button>'
      ],
      [
        `+button({name:'my button',type:'action','data-i18n':'action button'})`,
        '<button type="action" name="act_my-button" data-i18n="action button"></button>'
      ]
    ]
  };
mixin button(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - obj.name = replaceSpaces(obj.name);
  - obj.title = obj.title || buttonTitle(obj.name);
  if obj.type === 'action'
    - obj.name = `act_${obj.name}`;
  else
    - obj.type = 'roll';
    - obj.name = `roll_${obj.name}`;
  - const elementObj = makeElementObj(obj);
  if obj.type !== 'roll'
    - storeTrigger(obj);
  button&attributes(elementObj)
    block
//-End Mixin
-
  varObjects.docs.pug.action = {
    type:'mixin',
    description:'Alias for [button](#button) that creates a button element with a type of `action`. Spaces in the name are replaced with dashes instead of underscores.',
    example:[
      [
        `+action({name:'my button','data-i18n':'action button'})`,
        '<button type="action" name="act_my-button" data-i18n="action button"></button>'
      ]
    ]
  };
mixin action(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  - obj.type = 'action';
  - obj.name = obj.name.replace(/\s+/g,'-');
  +button(obj)
    block
//- End Mixin
-
  varObjects.docs.pug.navButton = {
    type:'mixin',
    description:'Alias for [button](#button) that creates a button element with a type of `action` for use in nav buttons. Spaces in the name are replaced with dashes instead of underscores. The name is prefixed with `nav_`. A [trigger](#trigger) object should be passed',
    example:[
      [
        `+navButton({name:'my button','data-i18n':'action button'})`,
        '<button type="action" name="act_nav-my-button" data-i18n="action button"></button>'
      ]
    ]
  };
mixin navButton(obj)
  - addIfUnique(obj.name,'navButtons');
  - obj.name = `nav ${obj.name}`;
  +action(obj)
    block
//- End Mixin
mixin rollerExtras(obj)
  - obj.class = obj.class ? `${replaceProblems(obj.class)} roller` : 'roller';
  - let attrName = replaceSpaces(actionInputName(obj.name));
  - let actionName = actionButtonName(attrName);
  - obj.value = `@{${attrName}}`;
  - actionObj = {name:actionName,hidden:''};
  - actionObj.trigger = obj.trigger || {listenerFunc:'initiateRoll'};
  block
  - addIfUnique(`${repeatingPrefix}${attrName}`,'actionAttributes');
  +action(actionObj)
  +hidden({name:attrName})
//- End Mixin
-
  varObjects.docs.pug.navButton = {
    type:'mixin',
    description:'Alias for [button](#button) that creates a combination roll button and action button element to get around the limitation that action buttons cannot be dragged to the macro quickbar. Requires sheetworker infrastructure to work, which should be triggered `on(sheet:opened)` and `on("change:character_name")`.',
    example:[
      [
        `+roller({name:'my roll'})`,
        '<button type="roll" name="roll_my_roll" value="@{my_roll_action}"></button>\n<button type="action" name="act_my-roll-action" hidden></button>\n<input type="hidden" name="attr_my_roll_action" value="">'
      ]
    ]
  };
mixin roller(obj)
  +rollerExtras(obj)
    - let rollObj = {...obj};
    - delete rollObj.trigger;
    +button(obj)
      block
mixin section(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  section&attributes(obj)
    block
//-End Mixin
mixin main(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  main&attributes(obj)
    block
//-End Mixin
mixin header(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  header&attributes(obj)
    block
//-End Mixin
mixin footer(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  footer&attributes(obj)
    block
//-End Mixin
mixin details(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  details&attributes(obj)
    block
//-End Mixin
mixin summary(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  summary&attributes(obj)
    block
//-End Mixin
mixin label(obj)
  - obj.class = obj.class ? replaceProblems(obj.class) : undefined;
  label&attributes(obj)
    block
//-End Mixin
mixin repeating_section(name,header,columnArr,id)
  section(class=`repeating-container--${name} repeating-container section` id=`${(id||name).replace(/\s+/g,'-')}`)
    if header
      h2(data-i18n=header)
    if columnArr
      .repeat-columns
        each head in columnArr
          h5(data-i18n=head)
    +customControlFieldset(name)
      block
//- End Mixin
-
  varObjects.docs.pug.customControlFieldset = {
    type:'mixin',
    description:'Alias for [fieldset](#fieldset) that creates to custom action buttons to add/remove rows to the repeating section. Useful when you need to trigger a sheetworker when a row is added. This also prevents the occassional error of a new row disappearing immediately after the user has clicked the button to create one. Proper use of this will require css to hide the default buttons that fieldsets create automatically. Note that currently this assumes the existence of an addItem and editSection sheetworker function.',
    arguments:[
      {name:'name',type:'string',description:'The name of the repeating section. Will be prefixed with `repeating_` and spaces will be replaced with dashes (`-`).'},
      {name:'trigger',type:'object',description:'Trigger that defines how to handle the removal of a row from the fieldset. `Optional`'},
      {name:'addClass',type:'string',description:'Any additional classes that should be used for the repeating section. Note that these are not added to the fieldset itself as adding additional classes to the fieldset itself interferes with calling action buttons from chat, but are added to a span that precedes the fieldset. This allows styling of the repcontainer via a css declaration like `.bonus-class + fieldset + .repcontainer`.'}
    ],
    example:[
      [
        `+customControlFieldset({name:'equipment'})\n  +text({name:'name',class:'underlined'})`,

        '<button type="action" name="add-equipment" class="repcontrol-button repcontrol-button--add"></button>\n<button type="action" name="edit-equipment" class="repcontrol-button repcontrol-button--edit"></button>\n<fieldset class="repeating_equipment">\n  <input type="text" name="attr_name" title="@{repeating_equipment_$x_name}">\n</fieldset>'
      ]
    ]
  };
mixin customControlFieldset({name,trigger,addClass})
  +action({name:`add ${name}`,class:'repcontrol-button repcontrol-button--add',trigger:{listenerFunc:'addItem'}})
  +action({name:`edit ${name}`,class:'repcontrol-button repcontrol-button--edit',trigger:{listenerFunc:'editSection'}})
  +fieldset({name,trigger,addClass})
    block
//- End Mixin
mixin inlineFieldset({name,trigger,addClass})
  - addClass = addClass ? `${addClass} inline-fieldset` : 'inline-fieldset';
  - varObjects.inlineFieldsets = varObjects.inlineFieldsets || [];
  - varObjects.inlineFieldsets.push(name);
  +fieldset({name,trigger,addClass})
    +radio({name:'display state',class:'display-control',value:'short-display',hidden:''})
    .inline-fieldset__summary.display-target
      label.pointer
        +checkbox({name:'collapse',value:1,hidden:'',trigger:{triggeredFuncs:['collapseSection']}})
        +span({name:'name',class:'inline-fieldset__summary__text'})
    +radio({name:'display state',class:'display-control',value:'display',checked:'',hidden:''})
    .inline-fieldset__detail.display-target
      +pseudoCollapse('collapse',{'data-i18n-title':collapseTitle})
      block
  +action({name:`add ${name}`,class:'repcontrol-button repcontrol-button--add repcontrol-button--inline',trigger:{listenerFunc:'sectionInteract'}})
  +action({name:`edit ${name}`,class:'repcontrol-button repcontrol-button--edit repcontrol-button--inline',trigger:{listenerFunc:'sectionInteract'}})
//- End Mixin
-
  varObjects.docs.pug.fieldset = {
    type:'mixin',
    description:'A mixin that creates a fieldset for the creation of a repeating section. The mixin prefixes the name with `repeating_` and replaces problem characters (e.g. spaces are replaced with dashes). Additionally, the auto-generated title properties from the K-scaffold\'s mixins will include the proper repeating section information.',
    arguments:[
      {name:'name',type:'string',description:'The name of the repeating section. Will be prefixed with `repeating_` and spaces will be replaced with dashes (`-`).'},
      {name:'trigger',type:'object',description:'Trigger that defines how to handle the removal of a row from the fieldset. `Optional`'},
      {name:'addClass',type:'string',description:'Any additional classes that should be used for the repeating section. Note that these are not added to the fieldset itself as adding additional classes to the fieldset itself interferes with calling action buttons from chat, but are added to a span that precedes the fieldset. This allows styling of the repcontainer via a css declaration like `.bonus-class + fieldset + .repcontainer`.'}
    ],
    example:[
      [
        `+fieldset({name:'equipment'})\n  +text({name:'name',class:'underlined'})`,
        
        '<fieldset class="repeating_equipment"></fieldset><div class="repcontainer" data-groupname="repeating_equipment">\n  <input type="text" name="attr_name" title="@{repeating_equipment_$x_name}">\n</div>'
      ],
      [
        `+fieldset({name:'equipment',trigger:{listenerFunc:'handleDeletedRow'},addClass:'class-1 class-2'})\n  +text({name:'name',class:'underlined'})`,

        `<span hidden class="class-1 class-2"></span>\n<fieldset class="repeating_equipment"></fieldset><div class="repcontainer" data-groupname="repeating_equipment">\n  <input type="text" name="attr_name" title="@{repeating_equipment_$x_name}">\n</div>`
      ]
    ]
  };
mixin fieldset({name,trigger,addClass})
  - name = name.replace(/\s+/g,'-');
  - let section = `repeating_${name}`;
  - repeatingPrefix = `${section}_$X_`;
  - createFieldsetObj(section)
  if trigger
    - storeTrigger({name:section,type:'fieldset',trigger})
  if addClass
    span(hidden="" class=addClass)
  fieldset(class=`${section}`)
    block
  - repeatingPrefix = '';
//-End Mixin
-
  varObjects.docs.pug['pseudo-button'] = {
    type:'mixin',
    description:'A mixin for creating pseudo buttons of paired checkboxes/radios and spans such as those that had to be used to create [tabbed sheets](https://wiki.roll20.net/CSS_Wizardry#Show.2FHide_Areas) before action buttons were introduced.',
    arguments:[
      {name:'label',type:'string',description:'The `data-i18n` translation key to use for the displayed text.'},
      {name:'inputObj',type:'object',description:'An object describing the input to be paired with the span. This is the same object that you would pass to [input](#input).'},
    ],
    example:[
      [
        `+pseudo-button('page 1',{name:'page',type:'radio',value:1,trigger:{triggeredFuncs:['changePage']}})`,

        `<input type="hidden" name="attr_page" title="@{page} value="1">\n<label class="pseudo-button"><span data-i8n="page 1" class="pseudo-button__span"></span>\n  <input type="radio" name="attr_page" value="1"></label>`
      ]
    ]
  };
mixin pseudo-button({label,inputObj,divObj,spanObj})
  - inputObj.class = inputObj.class ? replaceProblems(inputObj.class) : undefined;
  label.pseudo-button&attributes(divObj)
    - inputObj.class = inputObj.class ? `${inputObj.class} pseudo-button__input` : 'pseudo-button__input';
    +input(inputObj)
    span(data-i18n=label class='pseudo-button__span')&attributes(spanObj)
//-End Mixin
-
  varObjects.docs.pug['button-label'] = {
    type:'mixin',
    description:'A mixin to create a combined button and input that are within the same container. Similar to [input-label](#input-label), but does not use a label.',
    arguments:[
      {name:'inputObj',type:'object',description:'An object describing the input to be paired with the button. This is the same object that you would pass to [input](#input).'},
      {name:'buttonObj',type:'object',description:'An object describing the button to be paired with the input. This is the same object that you would pass to [button](#button).'},
      {name:'divObj',type:'object',description:'An object describing the container div. Similar to the first two objects, but will most likely only have a `class` property if it is passed at all.'}
    ],
    example:[
      [
        `+button-label({inputObj:{name:'strength',type:'number',class:'underlined',value:10,trigger:{affects:['athletics']}},buttonObj:{name:'strength_roll',type:'roll',value:'/r 1d20+@{strength}'},divObj:{class:'strength'}})`,

        `<div class="input-label input-label--button strength">\n  <button name="roll_strength_roll" type="roll" value="/r 1d20+@strength">\n  <input name="attr_strength" type="number" value="10">\n</div`
      ]
    ]
  };
mixin button-label({inputObj,buttonObj,divObj})
  if divObj
    - divObj.class = divObj.class ? replaceProblems(divObj.class) : undefined;
  - inputObj.class = inputObj.class ? replaceProblems(inputObj.class) : undefined;
  - buttonObj.class = buttonObj.class ? replaceProblems(buttonObj.class) : undefined;
  - inputObj.name = inputObj.name.replace(/\s+/g,'_');
  - buttonObj.name = (buttonObj.name || inputObj.name).replace(/\s+/g,'_');
  .input-label.input-label--button&attributes(divObj)
    - inputObj.class = inputObj.class ? `${inputObj.class} input-label__input` : 'input-label__input';
    if spanObj
      - buttonObj.class = buttonObj.class ? `${buttonObj.class} input-label__text` : 'input-label__text';
    +button(buttonObj)
    +input(inputObj)
//-End Mixin
-
  varObjects.docs.pug['roller-label'] = {
    type:'mixin',
    description:'Similar to the construction created by [button-label](#button-label), except that it creates a [roller](#roller) construction instead of just a straight button.',
    arguments:[
      {name:'inputObj',type:'object',description:'An object describing the input to be paired with the button. This is the same object that you would pass to [input](#input).'},
      {name:'buttonObj',type:'object',description:'An object describing the button to be paired with the input. This is the same object that you would pass to [roller](#roller).'},
      {name:'divObj',type:'object',description:'An object describing the container div. Similar to the first two objects, but will most likely only have a `class` property if it is passed at all.'}
    ]
  };
mixin roller-label({inputObj,buttonObj,divObj})
  +rollerExtras(buttonObj)
    +button-label({inputObj,buttonObj,divObj})
//-End Mixin
-
  varObjects.docs.pug['action-label'] = {
    type:'mixin',
    description:'Similar to the construction created by [button-label](#button-label), except that it specifcally creates an [action button](https://wiki.roll20.net/Button#Action_Button) as per [action](#action).',
    arguments:[
      {name:'inputObj',type:'object',description:'An object describing the input to be paired with the button. This is the same object that you would pass to [input](#input).'},
      {name:'buttonObj',type:'object',description:'An object describing the button to be paired with the input. This is the same object that you would pass to [action](#action).'},
      {name:'divObj',type:'object',description:'An object describing the container div. Similar to the first two objects, but will most likely only have a `class` property if it is passed at all.'}
    ]
  };
mixin action-label({inputObj,buttonObj,divObj})
  - buttonObj.type = 'action';
  +button-label(inputObj,buttonObj,divObj)
//-End Mixin
-
  varObjects.docs.pug['select-label'] = {
    type:'mixin',
    description:'Similar to the construction created by [input-label](#input-label), except that the input is replaced with a select.',
    arguments:[
      {name:'label',type:'string',description:'The `data-i18n` translation key to add to the span in the label.'},
      {name:'inputObj',type:'object',description:'An object describing the select to be paired with the button. This is the same object that you would pass to [select](#select).'},
      {name:'divObj',type:'object',description:'An object describing the container label. Similar to the inputObj, but will most likely only have a `class` property if it is passed at all.'},
      {name:'spanObj',type:'object',description:'An object describing the span to be paired with the input. This is the same object that you would pass to [span](#span).'},
      {name:'block',type:'block',description:'The mixin uses the pug block as the content of the select.'}
    ],
    example:[
      [
        `+select-label('Whisper to GM',{name:'whisper'},{class:'div-class'},{class:'span-class'})\n  +option({value:'','data-i18n':'never'})\n  +option({value:'/w gm ','data-i18n':'always'})`,

        `<label class="input-label div-class"><span data-i18n="Whisper to GM" class="input-label__text span-class"></span>\n  <select name="attr_whisper" class="input-label__input">\n    <option value="" data-i18n="never"></option>\n    <option value="/w gm " data-i18n="always"></option>\n  </select>\n</label>`
      ]
    ]
  };
mixin select-label({label,inputObj,divObj,spanObj})
  if divObj
    - divObj.class = divObj.class ? replaceProblems(divObj.class) : undefined;
  if inputObj
    - inputObj.class = inputObj.class ? replaceProblems(inputObj.class) : undefined;
  if spanObj
    - spanObj.class = spanObj.class ? replaceProblems(spanObj.class) : undefined;
  label.input-label&attributes(divObj)
    - inputObj.name = inputObj.name.replace(/\s+/g,'_');
    - inputObj.class = inputObj.class ? `${inputObj.class} input-label__input` : 'input-label__input';
    if spanObj
      - spanObj.class = spanObj.class ? `${spanObj.class} input-label__text` : 'input-label__text';
    span(data-i18n=label)&attributes(spanObj)
    +select(inputObj)
      block
//-End Mixin
-
  varObjects.docs.pug['input-label'] = {
    type:'mixin',
    description:'Creates a construction that nests the input and span in a label so that they are connected. This is beneficial for screen readers as well as making it easier to interact with the input via mouse by clicking on the text associated with it.',
    arguments:[
      {name:'label',type:'string',description:'The `data-i18n` translation key to add to the span in the label.'},
      {name:'inputObj',type:'object',description:'An object describing the input to be paired with the button. This is the same object that you would pass to [input](#input).'},
      {name:'divObj',type:'object',description:'An object describing the container label. Similar to the inputObj, but will most likely only have a `class` property if it is passed at all.'},
      {name:'spanObj',type:'object',description:'An object describing the span to be paired with the input. This is the same object that you would pass to [span](#span).'},
      {name:'block',type:'block',description:'The mixin uses the pug block as the content of the select.'}
    ],
    example:[
      [
        `+input-label({label:'strength',inputObj:{name:'strength',type:'number'},divObj:{class:'div-class'},spanObj:{class:'span-class'}})`,

        `<label class="input-label div-class"><span data-i18n="Whisper to GM" class="input-label__text span-class"></span>\n  <input name="attr_strength" type="number" class="input-label__input">\n</label>`
      ]
    ]
  };
mixin input-label({label,inputObj,divObj,spanObj})
  if divObj
    - divObj.class = divObj.class ? replaceProblems(divObj.class) : undefined;
  if inputObj
    - inputObj.class = inputObj.class ? replaceProblems(inputObj.class) : undefined;
  if spanObj
    - spanObj.class = spanObj.class ? replaceProblems(spanObj.class) : undefined;
  label.input-label&attributes(divObj)
    - inputObj.name = inputObj.name.replace(/\s+/g,'_');
    - inputObj.class = inputObj.class ? `${inputObj.class} input-label__input` : 'input-label__input';
    if spanObj
      - spanObj.class = spanObj.class ? `${spanObj.class} input-label__text` : 'input-label__text';
    span(data-i18n=label)&attributes(spanObj)
    +input(inputObj)
//-End Mixin
mixin dual-input-label({label,inputArr,divObj,spanObj})
  if divObj
    - divObj.class = divObj.class ? replaceProblems(divObj.class) : undefined;
  if spanObj
    - spanObj.class = spanObj.class ? replaceProblems(spanObj.class) : undefined;
  .input-label.input-label--dual&attributes(divObj)
    span(data-i18n=label)&attributes(spanObj)
    each inputObj,i in inputArr
      if inputObj
        - inputObj.class = inputObj.class ? replaceProblems(inputObj.class) : undefined;
      - inputObj.name = inputObj.name.replace(/\s+/g,'_');
      +input(inputObj)
      if i<1
        span(class='slash h2')='/'
//-End Mixin
-
  varObjects.docs.pug.headedTextarea = {
    type:'mixin',
    description:'Creates a construction for pairing a header with a textarea. Currently is locked to creating an `h3`.  This mixin also accepts classes and IDs appended directly to it (see the second example)',
    arguments:[
      {name:'textObj',type:'object',description:'The object describing the textarea as per [textarea](#textarea)'},
      {name:'header',type:'string',description:'The `data-i18n` translation key to use for the header'}
    ],
    example:[
      [
        `+headedTextarea({textObj:{name:'character description','data-i18n-placeholder':'The description of your character'},header:'description'})`,

        `<div class="headed-textarea">\n  <h3 data-i18n="description"></h3>\n  <textarea name="attr_character_description" data-i18n-placeholder:"The description of your character"></textarea>\n</div>`
      ],
      [
        `+headedTextarea({textObj:{name:'character description','data-i18n-placeholder':'The description of your character'},header:'description'}).character-description`,

        `<div class="headed-textarea character-description">\n  <h3 data-i18n="description"></h3>\n  <textarea name="attr_character_description" data-i18n-placeholder:"The description of your character"></textarea>\n</div>`
      ]
    ]
  };
mixin headedTextarea({textObj,header})
  .headed-textarea&attributes(attributes)
    - textObj.class = textObj.class ? `${textObj.class} headed-textarea__textarea` : 'headed-textarea__textarea';
    +h3({'data-i18n':header,class:'headed-textarea__header'})
    +textarea(textObj)
//-End Mixin
-
  varObjects.docs.pug.script = {
    type:'mixin',
    description:'Creates a generic [Roll20 script block](https://wiki.roll20.net/Building_Character_Sheets#JavaScript_2) for use with the sheetworker system.'
  };
-
  varObjects.docs.pug.adaptiveTextarea = {
    type:'mixin',
    description:'Creates an html construction for creating a [content-scaled](https://wiki.roll20.net/CSS_Wizardry#Content-scaled_Inputs) textarea.',
    arguments:[
      {name:'textObj',type:'object',description:'The object describing the textarea as per the [textarea](#textarea) mixin. You can apply classes and IDs to the container div by appending them to the mixin call (see the second example).'}
    ],
    example:[
      [
        `+adaptiveTextarea({name:'character description'})`,

        `<div class="adaptive adaptive--text"><span name:"attr_character_description" class="adaptive--text__span"></span>\n  <textarea name="attr_character_description" class="adaptive--text__textarea"></textarea>\n</div>`
      ],
      [
        `+adaptiveTextarea({name:'character description'}).custom-class`,

        `<div class="adaptive adaptive--text custom-class"><span name:"attr_character_description" class="adaptive--text__span"></span>\n  <textarea name="attr_character_description" class="adaptive--text__textarea"></textarea>\n</div>`
      ]
    ]
  };
mixin adaptiveTextarea(textObj)
  .adaptive.adaptive--text&attributes(attributes)
    - let spanObj = {name:textObj.name,class:'adaptive--text__span'};
    - textObj.class = textObj.class ? `${textObj.class} adaptive--text__textarea` : 'adaptive--text__textarea';
    +span(spanObj)
    +textarea(textObj)
//- End Mixin
//-
  varObjects.docs.pug.adaptiveInput = {
    type:'mixin',
    description:'Creates an html construction for creating a [content-scaled](https://wiki.roll20.net/CSS_Wizardry#Content-scaled_Inputs) input.',
    arguments:[
      {name:'textObj',type:'object',description:'The object describing the input as per the [input](#input) mixin. You can apply classes and IDs to the container div by appending them to the mixin call (see the second example).'}
    ],
    example:[
      [
        `+adaptiveInput({name:'character description',type:'text'})`,

        `<div class="adaptive adaptive--input"><span name:"attr_character_description" class="adaptive--input__span"></span>\n  <input name="attr_character_description" class="adaptive--input__input">\n</div>`
      ],
      [
        `+adaptiveInput({name:'character description',type:'text'}).custom-class`,

        `<div class="adaptive adaptive--input custom-class"><span name:"attr_character_description" class="adaptive--input__span"></span>\n  <input name="attr_character_description" class="adaptive--input__input">\n</div>`
      ]
    ]
  };
mixin adaptiveInput(textObj)
  .adaptive.adaptive--input&attributes(attributes)
    - let spanObj = {name:textObj.name,class:'adaptive--input__span','max-width':maxWidth};
    - textObj.class = textObj.class ? `${textObj.class} adaptive--input__input` : 'adaptive--input__input';
    +span(spanObj)
    +input(textObj)
//- End Mixin
-
  varObjects.docs.pug.compendiumAttributes = {
    type:'mixin',
    description:'Creates a set of compendium drop target attributes. Defaults to creating target attributes for the `Name` and `data` compendium attributes.',
    arguments:[
      {name:'prefix',type:'string',description:'A prefix to attach to the default attribute names.'},
      {name:'lookupAttributes',type:'array',description:'An array of the lookup attributes to create targets for. The target attributes are named based on the compendium attribute they are for. lookupAttributes defaults to `["Name","data"]`.'},
      {name:'triggerAccept',type:'string',description:'The compendium attribute that should trigger the sheetworkers to handle the compendium drop.'},
      {name:'trigger',type:'object',description:'The trigger object. Defaults to `{listenerFunc:"handleCompendiumDrop"}`'}
    ],
    example:[
      [
        `+compendiumAttributes({})`,

        `<input name="attr_drop_name" accept="Name" value="" type="hidden" title="@{drop_name}"/>\n<input name="attr_drop_data" accept="data" value="" type="hidden" title="@{drop_data}"/>`
      ],
      [
        `+compendiumAttributes({prefix:'prefix'})`,

        `<input name="attr_prefix_drop_name" accept="Name" value="" type="hidden" title="@{prefix_drop_name}"/>\n<input name="attr_prefix_drop_data" accept="data" value="" type="hidden" title="@{prefix_drop_data}"/>`
      ],
      [
        `+compendiumAttributes({lookupAttributes:['Name','data','Category'],prefix:'prefix})`,

        `<input name="attr_prefix_drop_name" accept="Name" value="" type="hidden" title="@{prefix_drop_name}"/>\n<input name="attr_prefix_drop_data" accept="data" value="" type="hidden" title="@{prefix_drop_data}"/>\n<input name="attr_prefix_drop_category" accept="Category" value="" type="hidden" title="@{prefix_drop_category}"/>`
      ]
    ]
  };
mixin compendiumAttributes({prefix,lookupAttributes = ['Name','data'],triggerAccept = 'Name',trigger = {listenerFunc:'handleCompendiumDrop'}})
  - prefix = prefix ? `${prefix} ` : '';
  each accept in lookupAttributes
    - let inputObj = {name:`${prefix}drop ${accept.toLowerCase()}`,accept,value:''};
    if accept === triggerAccept
      - inputObj.trigger = trigger;
    +hidden(inputObj)
//- End Mixin
//- Functions
-
  varObjects.docs.pug.attrTitle = {
    type:'function',
    description:'Converts an attribute name into an attribute call for that attribute. Converts `_max` attribute names to the proper attribute call syntax for `_max` attributes (see second example). If called from inside the block of a [fieldset](#fieldset) mixin, will also add the appropriate information for calling a repeating attribute.',
    arguments:[
      {name:'attrName',type:'string',description:'The attribute name to create an attribute call for.'}
    ],
    example:[
      [
        `- attrTitle('strength') => "@{strength}"`
      ],
      [
        `- attrTitle('hp_max') => "@{hp|max}"`
      ],
      [
        `+fieldset({name:'equipment'})\n  - attrTitle('weight') => "@{repeating_equipment_$X_weight}"`
      ]
    ],
    retValue:{
      type:'string'
    }
  };
mixin script
  script(type='text/worker')
    block
//-End Mixin
-
  varObjects.docs.pug.kscript = {
    type:'mixin',
    description:'Similar to [script](#script), but includes the K-scaffold\'s javascript function library.'
  };
mixin kscript(document=false)
  +script
    |const k = (function(){
    |const kFuncs = {};
    |const document = #{document};
    //- The below declarations import variables from the pug file and mixins into the sheetworker code
    - const propArray = ['cascades','repeatingSectionDetails','docs'];
    each prop in propArray
      |
      |const !{prop} = !{JSON.stringify(varObjects[prop])};
      |
      |kFuncs.!{prop} = !{prop};
      - delete varObjects[prop];
    |
    |
    include kvariables.js
    include utility.js
    include attribute_proxy.js
    include accessSheet.js
    include parse_cascade.js
    include sheetworker_aliases.js
    include listeners.js
    |return kFuncs;
    |}());
    |
    each content,prop in varObjects
      |
      if typeof content === 'object'
        |const !{prop} = !{JSON.stringify(content)};
      else
        |let !{prop} = !{content};
      |
    |
    block
//- End Mixin
- const attrTitle = (string) => `@{${repeatingPrefix}${replaceSpaces(string).replace(/_max$/,'|max')}}`;
-
  varObjects.docs.pug.buttonTitle = {
    type:'function',
    description:'Converts an ability name into an ability call for that attribute. If called from inside the block of a [fieldset](#fieldset) mixin, will also add the appropriate information for calling a repeating attribute.',
    arguments:[
      {name:'abilityName',type:'string',description:'The ability name to create an attribute call for.'}
    ],
    example:[
      [
        `- buttonTitle('strength') => "%{strength}"`
      ],
      [
        `+fieldset({name:'equipment'})\n  - buttonTitle('use') => "%{repeating_equipment_$X_use}"`
      ]
    ],
    retValue:{
      type:'string'
    }
  };
- const buttonTitle = (string) => `%{${repeatingPrefix}${replaceSpaces(string)}}`;
-
  varObjects.docs.pug.replaceSpaces = {
    type:'function',
    description:'Replaces spaces in a string with underscores (`_`).',
    arguments:[
      {name:'string',type:'string',description:'The string to work on'}
    ],
    example:[
      [
        `- replaceSpaces('attribute name') => "attribute_name"`
      ]
    ],
    retValue:{
      type:'string'
    }
  };
- const replaceSpaces = (string) => string.replace(/\s+/g,'_');
-
  varObjects.docs.pug.replaceProblems = {
    type:'function',
    description:'Escapes problem characters in a string for use as a regex.',
    arguments:[
      {name:'string',type:'string',description:'The string to work on'}
    ],
    example:[
      [
        `- replaceProblems("Here's a problem => [") => "Here's a problem => \["`
      ]
    ],
    retValue:{
      type:'string'
    }
  };
- const replaceProblems = (string) => string.replace(/[\(\)\[\]\|\/\\]/g,'-');
-
  varObjects.docs.pug.capitalize = {
    type:'function',
    description:'Capitalizes the first let of words in a string.',
    arguments:[
      {name:'string',type:'string',description:'The string to apply capitalization to.'}
    ],
    retValue:{type:'string'}
  };
-
  const capitalize = (string)=> string.replace(/(?:^|\s+|\/)[a-z]/ig,(letter)=>letter.toUpperCase());

- const actionButtonName = (name) => `${name.replace(/_|\s+/g,'-')}`;
- const actionInputName = (name) => `${name}_action`.replace(/roll_action/,'action');
- const titleToName = (string) => string.replace(/[@%]\{|\}/g,'');
-
  const addIfUnique = (item,arrName) => {
    varObjects[arrName] = varObjects[arrName] || [];
    if(varObjects[arrName].indexOf(item) === -1){
      varObjects[arrName].push(item);
    }
  };
-
  const storeTrigger = function(element){
    let trigger = element.trigger || {};
    const namePrefix = {
      roll:'roll_',
      action:'act_',
      fieldset:'fieldset_'
    };
    const typeDefs = {
      select:'',
      radio:0,
      checkbox:0,
      number:0,
      text:'',
      span:''
    };
    const eventTypes = {
      roll:'clicked',
      action:'clicked',
      fieldset:'remove'
    };
    let elementName = element.title ?
      titleToName(element.title) :
      element.name;
    trigger.name = elementName.replace(/\|/g,'_');
    let cascName = `${namePrefix[element.type] || 'attr_'}${trigger.name}`;
    let match = trigger.name.match(/(repeating_[^_]+)_[^_]+_(.+)/);
    let [,section,field] = match || [,,trigger.name];
    let eventType = eventTypes[element.type] || 'change';
    if(!varObjects.cascades[cascName]){
      if(trigger.listener || trigger.triggeredFuncs || trigger.listenerFunc || trigger.initialFunc || trigger.affects){
        trigger.listener = trigger.listener || `${eventType}:${section ? `${section}:` : ''}${field}`;
        trigger.listenerFunc = trigger.listenerFunc || 'accessSheet';
      }
      trigger.type = element.type;
      if(!namePrefix[element.type]){
        trigger.defaultValue = trigger.hasOwnProperty('defaultValue') ?
          trigger.defaultValue :
          (element.type === 'checkbox' && !element.hasOwnProperty('checked')) ?
            0 :
            element.hasOwnProperty('value') ?
              element.value :
              typeDefs.hasOwnProperty(element.type) ?
                typeDefs[element.type] :
                '';
        trigger.triggeredFuncs = trigger.triggeredFuncs || [];
        if(trigger.affects){
          trigger.affects = trigger.affects.map((affect)=>replaceSpaces(affect));
        }else{
          trigger.affects = [];
        }
      }
      varObjects.cascades[cascName] = {...trigger};
    }else{
      if(!namePrefix[varObjects.cascades[cascName].type]){
        varObjects.cascades[cascName].triggeredFuncs = trigger.triggeredFuncs ?
          [...new Set([...varObjects.cascades[cascName].triggeredFuncs,...trigger.triggeredFuncs])] :
          varObjects.cascades[cascName].triggeredFuncs;
        varObjects.cascades[cascName].affects = trigger.affects ?
          [...new Set([...varObjects.cascades[cascName].affects,...trigger.affects])] : 
          varObjects.cascades[cascName].affects;
        varObjects.cascades[cascName].calculation = varObjects.cascades[cascName].calculation || 
          trigger.calculation;
      }
      if(trigger.listenerFunc || trigger.triggeredFuncs || trigger.affects){
        varObjects.cascades[cascName].listener = varObjects.cascades[cascName].listener || trigger.listener || `${eventType}:${section ? `${section}:` : ''}${field}`;
        varObjects.cascades[cascName].listenerFunc = varObjects.cascades[cascName].listenerFunc || trigger.listenerFunc || 'accessSheet';
      }
    }
  };
-
  const getSectionDetails = function(section){
    return varObjects.repeatingSectionDetails.find((obj)=>obj.section === section);
  };
-
  const createFieldsetObj = function(section){
     !getSectionDetails(section) ? 
      varObjects.repeatingSectionDetails.push({section,fields:[]}) :
      null;
  };
-
  const addFieldToFieldsetObj = function(obj){
    let section = repeatingPrefix.replace(/_[^_]+_$/,'');
    let sectionDetails = getSectionDetails(section);
    let name = obj.name.replace(/^attr_/,'');
    if(sectionDetails && sectionDetails.fields.indexOf(name) < 0){
      sectionDetails.fields.push(name);
    }
  };
-
  const makeElementObj = function(obj){
    const newObj = {...obj};
    delete newObj.trigger;
    return newObj;
  };